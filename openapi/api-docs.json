{"openapi": "3.0.2", "info": {"description": "ArangoDB REST API Interface", "version": "1.0", "title": "ArangoDB", "license": {"name": "Apache License, Version 2.0"}}, "components": {"schemas": {"ARANGO_ERROR": {"description": "An ArangoDB Error code", "type": "integer"}, "ArangoError": {"description": "the arangodb error type", "properties": {"code": {"description": "the HTTP Status code", "type": "integer"}, "error": {"description": "boolean flag to indicate whether an error occurred (*true* in this case)", "type": "boolean"}, "errorMessage": {"description": "a descriptive error message describing what happened, may contain additional information", "type": "string"}, "errorNum": {"description": "the ARANGO_ERROR code", "type": "integer"}}}, "computed_field": {"description": "", "properties": {"computeOn": {"description": "An array of strings that defines on which write operations the value is\ncomputed. The possible values are `\"insert\"`, `\"update\"`, and `\"replace\"`.\n\n", "format": "string", "items": {"type": "string"}, "type": "array"}, "expression": {"description": "An AQL `RETURN` operation with an expression that computes the desired value.\n\n", "type": "string"}, "failOnWarning": {"description": "Whether the write operation fails if the expression produces a warning.\n\n", "type": "boolean"}, "keepNull": {"description": "Whether the target attribute is set if the expression evaluates to `null`.\n\n", "type": "boolean"}, "name": {"description": "The name of the target attribute.\n\n", "type": "string"}, "overwrite": {"description": "Whether the computed value takes precedence over a user-provided or\nexisting attribute.\n\n", "type": "boolean"}}, "type": "object"}, "edge_representation": {"description": "The complete deleted edge document.\nIncludes all attributes stored before this operation.\nWill only be present if returnOld is true.\n\n", "properties": {"_from": {"description": "The _from value of the stored data.\n\n", "type": "string"}, "_id": {"description": "The _id value of the stored data.\n\n", "type": "string"}, "_key": {"description": "The _key value of the stored data.\n\n", "type": "string"}, "_rev": {"description": "The _rev value of the stored data.\n\n", "type": "string"}, "_to": {"description": "The _to value of the stored data.\n\n", "type": "string"}}, "type": "object"}, "vertex_representation": {"description": "The internal attributes for the vertex.\n\n", "properties": {"_id": {"description": "The _id value of the stored data.\n\n", "type": "string"}, "_key": {"description": "The _key value of the stored data.\n\n", "type": "string"}, "_rev": {"description": "The _rev value of the stored data.\n\n", "type": "string"}}, "required": ["vertex"], "type": "object"}, "move_shard_operation": {"description": "", "properties": {"collection": {"description": "Collection ID of the collection the shard belongs to.\n\n", "format": "", "type": "number"}, "from": {"description": "The server name from which to move.\n\n", "type": "string"}, "isLeader": {"description": "True if this is a leader move shard operation.\n\n", "type": "boolean"}, "shard": {"description": "Shard ID of the shard to be moved.\n\n", "type": "string"}, "to": {"description": "The ID of the destination server.\n\n", "type": "string"}}, "type": "object"}, "get_api_control_pregel": {"description": "\n", "properties": {"algorithm": {"description": "The algorithm used by the job.\n\n", "type": "string"}, "computationTime": {"description": "The algorithm execution time. Is shown when the computation started. \n\n", "format": "float", "type": "number"}, "created": {"description": "The date and time when the job was created.\n\n", "type": "string"}, "detail": {"$ref": "#/components/schemas/get_api_control_pregel_detail"}, "edgeCount": {"description": "The total number of edges processed.\n\n", "format": "int64", "type": "integer"}, "expires": {"description": "The date and time when the job results expire. The expiration date is only\nmeaningful for jobs that were completed, canceled or resulted in an error. Such jobs\nare cleaned up by the garbage collection when they reach their expiration date/time.\n\n", "type": "string"}, "gss": {"description": "The number of global supersteps executed.\n\n", "format": "int64", "type": "integer"}, "gssTimes": {"description": "Computation time of each global super step. Is shown when the computation started.\n\n", "format": "number", "items": {"type": "number"}, "type": "array"}, "id": {"description": "The ID of the Pregel job, as a string.\n\n", "type": "string"}, "reports": {"description": "This attribute is used by Programmable Pregel Algorithms (`air`, experimental).\nThe value is only populated once the algorithm has finished.\n\n", "format": "object", "items": {"type": "object"}, "type": "array"}, "startupTime": {"description": "The startup runtime of the execution.\nThe startup time includes the data loading time and can be substantial.\n\n", "format": "float", "type": "number"}, "state": {"description": "The state of the execution. The following values can be returned:\n- `\"none\"`: The Pregel run did not yet start.\n- `\"loading\"`: The graph is loaded from the database into memory before the execution of the algorithm.\n- `\"running\"`: The algorithm is executing normally.\n- `\"storing\"`: The algorithm finished, but the results are still being written\n  back into the collections. Occurs only if the store parameter is set to true.\n- `\"done\"`: The execution is done. In version 3.7.1 and later, this means that\n  storing is also done. In earlier versions, the results may not be written back\n  into the collections yet. This event is announced in the server log (requires\n  at least info log level for the `pregel` log topic).\n- `\"canceled\"`: The execution was permanently canceled, either by the user or by\n  an error.\n- `\"fatal error\"`: The execution has failed and cannot recover.\n- `\"in error\"`: The execution is in an error state. This can be\n  caused by DB-Servers being not reachable or being non responsive. The execution\n  might recover later, or switch to `\"canceled\"` if it was not able to recover\n  successfully. \n- `\"recovering\"` (currently unused): The execution is actively recovering and\n  switches back to `running` if the recovery is successful.\n\n", "type": "string"}, "storageTime": {"description": "The time for storing the results if the job includes results storage.\nIs shown when the storing started.\n\n", "format": "float", "type": "number"}, "totalRuntime": {"description": "The total runtime of the execution up to now (if the execution is still ongoing).\n\n", "format": "float", "type": "number"}, "ttl": {"description": "The TTL (time to live) value for the job results, specified in seconds.\nThe TTL is used to calculate the expiration date for the job's results.\n\n", "format": "float", "type": "number"}, "vertexCount": {"description": "The total number of vertices processed.\n\n", "format": "int64", "type": "integer"}}, "required": ["detail"], "type": "object"}, "get_api_control_pregel_detail": {"description": "The Pregel run details.\n\n", "properties": {"aggregatedStatus": {"$ref": "#/components/schemas/get_api_control_pregel_detail_aggregated"}, "workerStatus": {"description": "The details of the Pregel for every DB-Server. Each object key is a DB-Server ID,\nand each value is a nested object similar to the `aggregatedStatus` attribute.\nIn a single server deployment, there is only a single entry with an empty string as key.\n", "format": "", "type": "object"}}, "required": ["aggregatedStatus"], "type": "object"}, "get_api_control_pregel_detail_aggregated": {"description": "The aggregated details of the full Pregel run. The values are totals of all the\nDB-Server.\n\n", "properties": {"allGssStatus": {"$ref": "#/components/schemas/get_api_control_pregel_detail_aggregated_gss"}, "graphStoreStatus": {"$ref": "#/components/schemas/get_api_control_pregel_detail_aggregated_store"}, "timeStamp": {"description": "The time at which the status was measured.\n\n", "type": "string"}}, "type": "object"}, "get_api_control_pregel_detail_aggregated_gss": {"description": "Information about the global supersteps.\n\n", "properties": {"items": {"description": "A list of objects with details for each global superstep.\n\n", "format": "get_api_control_pregel_detail_aggregated_gss_items", "items": {"$ref": "#/components/schemas/get_api_control_pregel_detail_aggregated_gss_items"}, "type": "array"}}, "type": "object"}, "get_api_control_pregel_detail_aggregated_gss_items": {"description": "", "properties": {"memoryBytesUsedForMessages": {"description": "The number of bytes used in memory for the messages in this step.\n\n", "format": "int64", "type": "integer"}, "messagesReceived": {"description": "The number of messages received in this step.\n\n", "format": "int64", "type": "integer"}, "messagesSent": {"description": "The number of messages sent in this step.\n\n", "format": "int64", "type": "integer"}, "verticesProcessed": {"description": "The number of vertices that have been processed in this step.\n\n", "format": "int64", "type": "integer"}}, "type": "object"}, "get_api_control_pregel_detail_aggregated_store": {"description": "The status of the in memory graph.\n\n", "properties": {"edgesLoaded": {"description": "The number of edges that are loaded from the database into memory.\n\n", "format": "int64", "type": "integer"}, "memoryBytesUsed": {"description": "The number of bytes used in-memory for the loaded graph.\n\n", "format": "int64", "type": "integer"}, "verticesLoaded": {"description": "The number of vertices that are loaded from the database into memory.\n\n", "format": "int64", "type": "integer"}, "verticesStored": {"description": "The number of vertices that are written back to the database after the Pregel\ncomputation finished. It is only set if the `store` parameter is set to `true`.\n\n", "format": "int64", "type": "integer"}}, "type": "object"}, "graph_edge_definition": {"description": "", "properties": {"collection": {"description": "Name of the edge collection, where the edge are stored in.\n\n", "type": "string"}, "from": {"description": "List of vertex collection names.\nEdges in collection can only be inserted if their _from is in any of the collections here.\n\n", "format": "string", "items": {"type": "string"}, "type": "array"}, "to": {"description": "List of vertex collection names.\nEdges in collection can only be inserted if their _to is in any of the collections here.\n", "format": "string", "items": {"type": "string"}, "type": "array"}}, "type": "object"}, "key_generator_type": {"description": "A object which contains key generation options\n\n", "properties": {"allowUserKeys": {"description": "if set to `true`, then it is allowed to supply\nown key values in the `_key` attribute of a document. If set to\n`false`, then the key generator is solely responsible for\ngenerating keys and supplying own key values in the `_key` attribute\nof documents is considered an error.\n\n", "type": "boolean"}, "lastValue": {"description": "\n", "format": "", "type": "integer"}, "type": {"description": "specifies the type of the key generator. The currently\navailable generators are `traditional`, `autoincrement`, `uuid`\nand `padded`.\n\n", "type": "string"}}, "type": "object"}, "get_api_query_rules": {"description": "", "properties": {"flags": {"type": "object", "description": "An object with the properties of the rule.\n\n", "format": "get_api_query_rules_flags"}, "name": {"type": "string", "description": "The name of the optimizer rule as seen in query explain outputs.\n\n", "format": ""}}, "required": ["flags"], "type": "object"}, "get_api_query_rules_flags": {"description": "An object with the properties of the rule.\n\n", "properties": {"canBeDisabled": {"type": "boolean", "description": "Whether users are allowed to disable this rule. A few rules are mandatory.\n\n", "format": ""}, "canCreateAdditionalPlans": {"type": "boolean", "description": "Whether this rule may create additional query execution plans.\n\n", "format": ""}, "clusterOnly": {"type": "boolean", "description": "Whether the rule is applicable in the cluster deployment mode only.\n\n", "format": ""}, "disabledByDefault": {"type": "boolean", "description": "Whether the optimizer considers this rule by default.\n\n", "format": ""}, "enterpriseOnly": {"description": "Whether the rule is available in the Enterprise Edition only.\n\n", "type": "boolean"}, "hidden": {"type": "boolean", "description": "Whether the rule is displayed to users. Internal rules are hidden.\n\n", "format": ""}}, "type": "object"}, "api_task_struct": {"description": "The function in question\n\n", "properties": {"command": {"description": "the javascript function for this task\n\n", "type": "string"}, "created": {"description": "The timestamp when this task was created\n\n", "format": "float", "type": "number"}, "database": {"description": "the database this task belongs to\n", "type": "string"}, "id": {"description": "A string identifying the task\n\n", "type": "string"}, "name": {"description": "The fully qualified name of the user function\n\n", "type": "string"}, "offset": {"description": "time offset in seconds from the created timestamp\n\n", "format": "float", "type": "number"}, "period": {"description": "this task should run each `period` seconds\n\n", "format": "", "type": "number"}, "type": {"description": "What type of task is this [ `periodic`, `timed`]\n  - periodic are tasks that repeat periodically\n  - timed are tasks that execute once at a specific time\n\n", "type": "string"}}, "type": "object"}, "collection_info": {"description": "\n", "properties": {"cacheEnabled": {"description": "Whether the in-memory hash cache for documents is enabled for this\ncollection.\n\n", "type": "boolean"}, "computedValues": {"description": "A list of objects, each representing a computed value.\n\n", "format": "computed_field", "items": {"$ref": "#/components/schemas/computed_field"}, "type": "array"}, "globallyUniqueId": {"description": "Unique identifier of the collection\n", "type": "string"}, "id": {"description": "unique identifier of the collection; *deprecated*\n\n", "type": "string"}, "isSmart": {"description": "Whether the collection is used in a SmartGraph (Enterprise Edition only).\n_(cluster only)_\n\n", "type": "boolean"}, "isSystem": {"description": "true if this is a system collection; usually `name` will start with an underscore.\n\n", "type": "boolean"}, "keyOptions": {"$ref": "#/components/schemas/key_generator_type"}, "name": {"description": "literal name of this collection\n\n", "type": "string"}, "numberOfShards": {"description": "The number of shards of the collection. _(cluster only)_\n\n", "format": "", "type": "integer"}, "replicationFactor": {"description": "contains how many copies of each shard are kept on different DB-Servers.\nIt is an integer number in the range of 1-10 or the string `\"satellite\"`\nfor a SatelliteCollection (Enterprise Edition only). _(cluster only)_\n\n", "format": "", "type": "integer"}, "schema": {"description": "The collection level schema for documents.\n\n", "format": "", "type": "object"}, "shardKeys": {"description": "contains the names of document attributes that are used to\ndetermine the target shard for documents. _(cluster only)_\n\n", "format": "string", "items": {"type": "string"}, "type": "array"}, "shardingStrategy": {"description": "the sharding strategy selected for the collection.\nOne of 'hash' or 'enterprise-hash-smart-edge'. _(cluster only)_\n\n", "type": "string"}, "smartGraphAttribute": {"description": "Attribute that is used in SmartGraphs (Enterprise Edition only). _(cluster only)_\n\n", "type": "string"}, "smartJoinAttribute": {"description": "Determines an attribute of the collection that must contain the shard key value\nof the referred-to SmartJoin collection (Enterprise Edition only). _(cluster only)_\n\n", "type": "string"}, "type": {"description": "The type of the collection:\n  - `0`: \"unknown\"\n  - `2`: regular document collection\n  - `3`: edge collection\n\n", "format": "", "type": "integer"}, "waitForSync": {"description": "If `true` then creating, changing or removing\ndocuments will wait until the data has been synchronized to disk.\n\n", "type": "boolean"}, "writeConcern": {"description": "determines how many copies of each shard are required to be\nin sync on the different DB-Servers. If there are less then these many copies\nin the cluster a shard will refuse to write. Writes to shards with enough\nup-to-date copies will succeed at the same time however. The value of\n`writeConcern` cannot be larger than `replicationFactor`. _(cluster only)_\n\n", "format": "", "type": "integer"}}, "required": ["keyOptions"], "type": "object"}, "rebalance_compute": {"description": "\n\n", "properties": {"databasesExcluded": {"description": "A list of database names to exclude from the analysis. (Default: `[]`)\n\n", "format": "string", "items": {"type": "string"}, "type": "array"}, "leaderChanges": {"description": "Allow leader changes without moving data. (Default: `true`)\n\n", "type": "boolean"}, "maximumNumberOfMoves": {"description": "Maximum number of moves to be computed. (Default: `1000`)\n\n", "format": "", "type": "number"}, "moveFollowers": {"description": "Allow moving followers. (Default: `false`)\n\n", "type": "boolean"}, "moveLeaders": {"description": "Allow moving leaders. (Default: `false`)\n\n", "type": "boolean"}, "piFactor": {"description": "(Default: `256e6`)\n\n", "format": "", "type": "number"}, "version": {"description": "Must be set to `1`.\n\n", "format": "", "type": "number"}}, "required": [""], "type": "object"}, "explain_options": {"type": "object", "properties": {"allPlans": {"type": "boolean", "description": "if set to *true*, all possible execution plans will be returned.\nThe default is *false*, meaning only the optimal plan will be returned.\n\n", "format": ""}, "maxNumberOfPlans": {"type": "integer", "description": "an optional maximum number of plans that the optimizer is\nallowed to generate. Setting this attribute to a low value allows to put a\ncap on the amount of work the optimizer does.\n\n", "format": "int64"}, "optimizer": {"type": "object", "description": "Options related to the query optimizer.\n\n", "format": "explain_options_optimizer"}}}, "explain_options_optimizer": {"type": "object", "properties": {"rules": {"type": "array", "description": "A list of to-be-included or to-be-excluded optimizer rules can be put into this\nattribute, telling the optimizer to include or exclude specific rules. To disable\na rule, prefix its name with a `-`, to enable a rule, prefix it with a `+`. There is\nalso a pseudo-rule `all`, which matches all optimizer rules. `-all` disables all rules.\n\n", "items": {"type": "string"}}}}, "jwt_secret_struct": {"type": "object", "properties": {"active": {"type": "object", "description": "An object with the SHA-256 hash of the active secret.\n\n", "format": ""}, "passive": {"type": "array", "description": "An array of objects with the SHA-256 hashes of the passive secrets.\nCan be empty.\n\n", "items": {"type": "object"}}}}, "cluster_endpoints_struct": {"type": "object", "properties": {"endpoint": {"type": "string", "description": "The bind of the Coordinator, like `tcp://[::1]:8530`\n\n", "format": ""}}}, "version_details_struct": {"type": "object", "properties": {"architecture": {"type": "string", "description": "The CPU architecture, i.e. *64bit*\n\n", "format": ""}, "arm": {"type": "string", "description": "*false* - this is not running on an ARM cpu\n\n", "format": ""}, "asan": {"type": "string", "description": "has this been compiled with the asan address sanitizer turned on? (should be false)\n\n", "format": ""}, "asm-crc32": {"type": "string", "description": "do we have assembler implemented CRC functions?\n\n", "format": ""}, "assertions": {"type": "string", "description": "do we have assertions compiled in (=> developer version)\n\n", "format": ""}, "boost-version": {"type": "string", "description": "which boost version do we bind\n\n", "format": ""}, "build-date": {"type": "string", "description": "the date when this binary was created\n\n", "format": ""}, "build-repository": {"type": "string", "description": "reference to the git-ID this was compiled from\n\n", "format": ""}, "compiler": {"type": "string", "description": "which compiler did we use\n\n", "format": ""}, "cplusplus": {"type": "string", "description": "C++ standards version\n\n", "format": ""}, "debug": {"type": "string", "description": "*false* for production binaries\n\n", "format": ""}, "endianness": {"type": "string", "description": "currently only *little* is supported\n\n", "format": ""}, "failure-tests": {"type": "string", "description": "*false* for production binaries (the facility to invoke fatal errors is disabled)\n\n", "format": ""}, "fd-client-event-handler": {"type": "string", "description": "which method do we use to handle fd-sets, *poll* should be here on linux.\n\n", "format": ""}, "fd-setsize": {"type": "string", "description": "if not *poll* the fd setsize is valid for the maximum number of filedescriptors\n\n", "format": ""}, "full-version-string": {"type": "string", "description": "The full version string\n\n", "format": ""}, "icu-version": {"type": "string", "description": "Which version of ICU do we bundle\n\n", "format": ""}, "jemalloc": {"type": "string", "description": "*true* if we use jemalloc\n\n", "format": ""}, "maintainer-mode": {"type": "string", "description": "*false* if this is a production binary\n\n", "format": ""}, "openssl-version": {"type": "string", "description": "which openssl version do we link?\n\n", "format": ""}, "platform": {"type": "string", "description": "the host os - *linux*, *windows* or *darwin*\n\n", "format": ""}, "reactor-type": {"type": "string", "description": "*epoll* TODO\n\n", "format": ""}, "rocksdb-version": {"type": "string", "description": "the rocksdb version this release bundles\n\n", "format": ""}, "server-version": {"type": "string", "description": "the ArangoDB release version\n\n", "format": ""}, "sizeof int": {"type": "string", "description": "number of bytes for *integers*\n\n", "format": ""}, "sizeof void*": {"type": "string", "description": "number of bytes for *void pointers*\n\n", "format": ""}, "sse42": {"type": "string", "description": "do we have a SSE 4.2 enabled cpu?\n\n", "format": ""}, "unaligned-access": {"type": "string", "description": "does this system support unaligned memory access?\n\n", "format": ""}, "v8-version": {"type": "string", "description": "the bundled V8 javascript engine version\n\n", "format": ""}, "vpack-version": {"type": "string", "description": "the version of the used velocypack implementation\n\n", "format": ""}, "zlib-version": {"type": "string", "description": "the version of the bundled zlib\n\n", "format": ""}, "mode": {"type": "string", "description": "the mode we're runnig as - one of [*server*, *console*, *script*]\n\n", "format": ""}}}, "admin_echo_server_struct": {"type": "object", "properties": {"address": {"type": "string", "description": "The bind address of the endpoint this request was sent to\n\n", "format": ""}, "port": {"type": "integer", "description": "The port this request was sent to\n\n", "format": ""}, "endpoint": {"type": "string", "description": "The endpoint this request was sent to\n\n", "format": ""}}}, "admin_echo_client_struct": {"type": "object", "properties": {"address": {"type": "integer", "description": "The IP address of the client\n\n", "format": ""}, "port": {"type": "integer", "description": "The port of the TCP connection on the client-side\n\n", "format": ""}, "id": {"type": "string", "description": "A server generated ID\n\n", "format": ""}}}, "get_admin_status_server_info": {"type": "object", "properties": {"progress": {"type": "object", "description": "Startup and recovery information.\n\nYou can check for changes to determine whether progress was made between two\ncalls, but you should not rely on specific values as they may change between\nArangoDB versions. The values are only expected to change during the startup and\nshutdown, i.e. while `maintenance` is `true`.\n\nYou need to start _arangod_ with the `--server.early-connections` startup option\nenabled to be able to query the endpoint during the startup process.\nIf authentication is enabled, then you need to use the super-user JWT for the\nrequest because the user management is not available during the startup.\n\n", "format": "get_admin_status_server_info_progress"}, "role": {"type": "string", "description": "Either `\"SINGLE\"`, `\"COORDINATOR\"`, `\"PRIMARY\"` (DB-Server), or `\"AGENT\"`.\n\n", "format": ""}, "writeOpsEnabled": {"type": "boolean", "description": "Whether writes are enabled. **Deprecated**, use `readOnly` instead.\n\n", "format": ""}, "readOnly": {"type": "boolean", "description": "Whether writes are disabled.\n\n", "format": ""}, "maintenance": {"type": "boolean", "description": "Whether the maintenance mode is enabled.\n\n", "format": ""}, "persistedId": {"type": "string", "description": "The persisted ID, e. g. `\"CRDN-e427b441-5087-4a9a-9983-2fb1682f3e2a\"`.\n*Cluster only* (Agents, Coordinators, and DB-Servers).\n\n", "format": ""}, "rebootId": {"type": "number", "description": "The reboot ID. Changes on every restart.\n*Cluster only* (Agents, Coordinators, and DB-Servers).\n\n", "format": ""}, "state": {"type": "string", "description": "Either `\"STARTUP\"`, `\"SERVING\"`, or `\"SHUTDOWN\"`.\n*Cluster only* (Coordinators and DB-Servers).\n\n", "format": ""}, "address": {"type": "string", "description": "The address of the server, e.g. `tcp://[::1]:8530`.\n*Cluster only* (Coordinators and DB-Servers).\n\n", "format": ""}, "serverId": {"type": "string", "description": "The server ID, e.g. `\"CRDN-e427b441-5087-4a9a-9983-2fb1682f3e2a\"`.\n*Cluster only* (Coordinators and DB-Servers).\n\n", "format": ""}}}, "get_admin_status_server_info_progress": {"type": "object", "properties": {"phase": {"type": "string", "description": "Name of the lifecycle phase the instance is currently in. Normally one of\n`\"in prepare\"`, `\"in start\"`, `\"in wait\"`, `\"in shutdown\"`, `\"in stop\"`,\nor `\"in unprepare\"`.\n\n", "format": ""}, "feature": {"type": "string", "description": "Internal name of the feature that is currently being prepared, started,\nstopped or unprepared.\n\n", "format": ""}, "recoveryTick": {"type": "number", "description": "Current recovery sequence number value, if the instance is currently recovering.\nIf the instance is already past the recovery, this attribute will contain the\nlast handled recovery sequence number.\n\n", "format": ""}}}, "get_admin_status_agency": {"type": "object", "properties": {"agencyComm": {"type": "object", "description": "Information about the communication with the Agency.\n*Cluster only* (Coordinators and DB-Servers).\n\n", "format": "get_admin_status_agency_comm"}}}, "get_admin_status_agency_comm": {"type": "object", "properties": {"endpoints": {"type": "array", "description": "A list of possible Agency endpoints.\n\n", "items": {"type": "string"}}}}, "get_admin_status_coordinator": {"type": "object", "properties": {"foxxmaster": {"type": "array", "description": "The server ID of the Coordinator that is the Foxx master.\n\n", "items": {"type": "string"}}, "isFoxxmaster": {"type": "array", "description": "Whether the queried Coordinator is the Foxx master.\n\n", "items": {"type": "string"}}}}, "get_admin_status_agent": {"type": "object", "properties": {"id": {"type": "string", "description": "Server ID of the queried Agent.\n\n", "format": ""}, "leaderId": {"type": "string", "description": "Server ID of the leading Agent.\n\n", "format": ""}, "leading": {"type": "boolean", "description": "Whether the queried Agent is the leader.\n\n", "format": ""}, "endpoint": {"type": "string", "description": "The endpoint of the queried Agent.\n\n", "format": ""}}}, "license_features": {"type": "object", "properties": {"expires": {"type": "number", "description": "The `expires` key lists the expiry date as Unix timestamp (seconds since\nJanuary 1st, 1970 UTC).\n\n", "format": ""}}}, "aql_userfunction_struct": {"type": "object", "properties": {"name": {"type": "string", "description": "The fully qualified name of the user function\n\n", "format": ""}, "code": {"type": "string", "description": "A string representation of the function body\n\n", "format": ""}, "isDeterministic": {"type": "boolean", "description": "an optional boolean value to indicate whether the function\nresults are fully deterministic (function return value solely depends on\nthe input value and return value is the same for repeated calls with same\ninput). The *isDeterministic* attribute is currently not used but may be\nused later for optimizations.\n\n", "format": ""}}}, "jwt_keys_struct": {"type": "object", "properties": {"encryption-keys": {"type": "array", "description": "An array of objects with the SHA-256 hashes of the key secrets.\nCan be empty.\n\n", "items": {"type": "object"}}}}, "get_admin_cluster_rebalance_result": {"type": "object", "properties": {"leader": {"type": "object", "description": "Information about the leader imbalance.\n\n", "format": "leader_imbalance_struct"}, "shards": {"type": "object", "description": "Information about the shard imbalance.\n\n", "format": "shard_imbalance_struct"}}}, "post_api_index_inverted_fields": {"type": "object", "properties": {"name": {"type": "string", "description": "An attribute path. The `.` character denotes sub-attributes.\nYou can expand one array attribute with `[*]`.\n\n", "format": ""}, "analyzer": {"type": "string", "description": "The name of an Analyzer to use for this field.\n\nDefault: the value defined by the top-level `analyzer` option.\n\n", "format": ""}, "features": {"type": "array", "description": "A list of Analyzer features to use for this field. You can set this option to\noverwrite what features are enabled for the `analyzer`. Possible features:\n- `\"frequency\"`\n- `\"norm\"`\n- `\"position\"`\n- `\"offset\"`\n\nDefault: the features as defined by the Analyzer itself, or inherited from the\ntop-level `features` option if the `analyzer` option adjacent to this option is\nnot set.\n\n", "items": {"type": "string"}}, "includeAllFields": {"type": "boolean", "description": "This option only applies if you use the inverted index in a `search-alias` Views.\n\nIf set to `true`, then all sub-attributes of this field are indexed, excluding\nany sub-attributes that are configured separately by other elements in the\n`fields` array (and their sub-attributes). The `analyzer` and `features`\nproperties apply to the sub-attributes.\n\nIf set to `false`, then sub-attributes are ignored.\n\nDefault: the value defined by the top-level `includeAllFields` option.\n\n", "format": ""}, "searchField": {"type": "boolean", "description": "This option only applies if you use the inverted index in a `search-alias` Views.\n\nYou can set the option to `true` to get the same behavior as with `arangosearch`\nViews regarding the indexing of array values for this field. If enabled, both,\narray and primitive values (strings, numbers, etc.) are accepted. Every element\nof an array is indexed according to the `trackListPositions` option.\n\nIf set to `false`, it depends on the attribute path. If it explicitly expands an\narray (`[*]`), then the elements are indexed separately. Otherwise, the array is\nindexed as a whole, but only `geopoint` and `aql` Analyzers accept array inputs.\nYou cannot use an array expansion if `searchField` is enabled.\n\nDefault: the value defined by the top-level `searchField` option.\n\n", "format": ""}, "trackListPositions": {"type": "boolean", "description": "This option only applies if you use the inverted index in a `search-alias` Views.\n\nIf set to `true`, then track the value position in arrays for array values.\nFor example, when querying a document like `{ attr: [ \"valueX\", \"valueY\", \"valueZ\" ] }`,\nyou need to specify the array element, e.g. `doc.attr[1] == \"valueY\"`.\n\nIf set to `false`, all values in an array are treated as equal alternatives.\nYou don't specify an array element in queries, e.g. `doc.attr == \"valueY\"`, and\nall elements are searched for a match.\n\nDefault: the value defined by the top-level `trackListPositions` option.\n\n", "format": ""}, "nested": {"type": "array", "description": "Index the specified sub-objects that are stored in an array. Other than with the\n`fields` property, the values get indexed in a way that lets you query for\nco-occurring values. For example, you can search the sub-objects and all the\nconditions need to be met by a single sub-object instead of across all of them.\n\nThis property is available in the Enterprise Edition only.\n\n", "items": {"$ref": "#/components/schemas/post_api_index_inverted_nested"}}}}, "post_api_index_inverted_nested": {"type": "object", "properties": {"name": {"type": "string", "description": "An attribute path. The `.` character denotes sub-attributes.\n\n", "format": ""}, "analyzer": {"type": "string", "description": "The name of an Analyzer to use for this field.\nDefault: the value defined by the parent field, or the top-level `analyzer` option.\n\n", "format": ""}, "features": {"type": "array", "description": "A list of Analyzer features to use for this field. You can set this option to\noverwrite what features are enabled for the `analyzer`. Possible features:\n- `\"frequency\"`\n- `\"norm\"`\n- `\"position\"`\n- `\"offset\"`\n\nDefault: the features as defined by the Analyzer itself, or inherited from the\nthe parent field's or top-level `features` option if no `analyzer` option is set\nat a deeper level, closer to this option.\n\n", "items": {"type": "string"}}, "searchField": {"type": "boolean", "description": "This option only applies if you use the inverted index in a `search-alias` Views.\n\nYou can set the option to `true` to get the same behavior as with `arangosearch`\nViews regarding the indexing of array values for this field. If enabled, both,\narray and primitive values (strings, numbers, etc.) are accepted. Every element\nof an array is indexed according to the `trackListPositions` option.\n\nIf set to `false`, it depends on the attribute path. If it explicitly expands an\narray (`[*]`), then the elements are indexed separately. Otherwise, the array is\nindexed as a whole, but only `geopoint` and `aql` Analyzers accept array inputs.\nYou cannot use an array expansion if `searchField` is enabled.\n\nDefault: the value defined by the top-level `searchField` option.\n\n", "format": ""}, "nested": {"type": "array", "description": "You can recursively index sub-objects. See the above description of the\n`nested` option.\n\n", "items": {"type": "object"}}}}, "post_api_index_inverted_storedvalues": {"type": "object", "properties": {"fields": {"type": "array", "description": "A list of attribute paths. The `.` character denotes sub-attributes.\n\n", "items": {"type": "string"}}, "compression": {"type": "string", "description": "Defines how to compress the attribute values. Possible values:\n- `\"lz4\"` (default): use LZ4 fast compression.\n- `\"none\"`: disable compression to trade space for speed.\n\n", "format": ""}}}, "post_api_index_inverted_primarysort": {"type": "object", "properties": {"fields": {"type": "array", "description": "An array of the fields to sort the index by and the direction to sort each field in.\n\n", "items": {"$ref": "#/components/schemas/post_api_index_inverted_primarysort_fields"}}, "compression": {"type": "string", "description": "Defines how to compress the primary sort data. Possible values:\n- `\"lz4\"` (default): use LZ4 fast compression.\n- `\"none\"`: disable compression to trade space for speed.\n\n", "format": ""}}}, "post_api_index_inverted_primarysort_fields": {"type": "object", "properties": {"field": {"type": "string", "description": "An attribute path. The `.` character denotes sub-attributes.\n\n", "format": ""}, "direction": {"type": "string", "description": "The sorting direction. Possible values:\n- `\"asc` for ascending\n- `\"desc\"` for descending\n\n", "format": ""}}}, "post_api_index_inverted_policy": {"type": "object", "properties": {"type": {"type": "string", "description": "The segment candidates for the \"consolidation\" operation are selected based\nupon several possible configurable formulas as defined by their types.\nThe supported types are:\n\n- `\"tier\"` (default): consolidate based on segment byte size and live\n  document count as dictated by the customization attributes.\n\n", "format": ""}, "segmentsBytesFloor": {"type": "integer", "description": "Defines the value (in bytes) to treat all smaller segments as equal for\nconsolidation selection. Default: `2097152`\n\n", "format": ""}, "segmentsBytesMax": {"type": "integer", "description": "The maximum allowed size of all consolidated segments in bytes.\nDefault: `5368709120`\n\n", "format": ""}, "segmentsMax": {"type": "integer", "description": "The maximum number of segments that are evaluated as candidates for\nconsolidation. Default: `10`\n\n", "format": ""}, "segmentsMin": {"type": "integer", "description": "The minimum number of segments that are evaluated as candidates for\nconsolidation. Default: `1`\n\n", "format": ""}, "minScore": {"type": "integer", "description": "Filter out consolidation candidates with a score less than this. Default: `0`\n\n", "format": ""}}}, "put_api_collection_properties_computed_field": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the target attribute. Can only be a top-level attribute, but you\nmay return a nested object. Cannot be `_key`, `_id`, `_rev`, `_from`, `_to`,\nor a shard key attribute.\n\n", "format": ""}, "expression": {"type": "string", "description": "An AQL `RETURN` operation with an expression that computes the desired value.\nSee [Computed Value Expressions](https://www.arangodb.com/docs/devel/data-modeling-documents-computed-values.html#computed-value-expressions) for details.\n\n", "format": ""}, "overwrite": {"type": "boolean", "description": "Whether the computed value shall take precedence over a user-provided or\nexisting attribute.\n\n", "format": ""}, "computeOn": {"type": "array", "description": "An array of strings to define on which write operations the value shall be\ncomputed. The possible values are `\"insert\"`, `\"update\"`, and `\"replace\"`.\nThe default is `[\"insert\", \"update\", \"replace\"]`.\n\n", "items": {"type": "string"}}, "keepNull": {"type": "boolean", "description": "Whether the target attribute shall be set if the expression evaluates to `null`.\nYou can set the option to `false` to not set (or unset) the target attribute if\nthe expression returns `null`. The default is `true`.\n\n", "format": ""}, "failOnWarning": {"type": "boolean", "description": "Whether to let the write operation fail if the expression produces a warning.\nThe default is `false`.\n\n", "format": ""}}}, "post_api_collection_computed_field": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the target attribute. Can only be a top-level attribute, but you\nmay return a nested object. Cannot be `_key`, `_id`, `_rev`, `_from`, `_to`,\nor a shard key attribute.\n\n", "format": ""}, "expression": {"type": "string", "description": "An AQL `RETURN` operation with an expression that computes the desired value.\nSee [Computed Value Expressions](https://www.arangodb.com/docs/devel/data-modeling-documents-computed-values.html#computed-value-expressions) for details.\n\n", "format": ""}, "overwrite": {"type": "boolean", "description": "Whether the computed value shall take precedence over a user-provided or\nexisting attribute.\n\n", "format": ""}, "computeOn": {"type": "array", "description": "An array of strings to define on which write operations the value shall be\ncomputed. The possible values are `\"insert\"`, `\"update\"`, and `\"replace\"`.\nThe default is `[\"insert\", \"update\", \"replace\"]`.\n\n", "items": {"type": "string"}}, "keepNull": {"type": "boolean", "description": "Whether the target attribute shall be set if the expression evaluates to `null`.\nYou can set the option to `false` to not set (or unset) the target attribute if\nthe expression returns `null`. The default is `true`.\n\n", "format": ""}, "failOnWarning": {"type": "boolean", "description": "Whether to let the write operation fail if the expression produces a warning.\nThe default is `false`.\n\n", "format": ""}}}, "post_api_collection_opts": {"type": "object", "properties": {"type": {"type": "string", "description": "specifies the type of the key generator. The currently available generators are\n`traditional`, `autoincrement`, `uuid` and `padded`.\n\n- The `traditional` key generator generates numerical keys in ascending order.\n  The sequence of keys is not guaranteed to be gap-free.\n\n- The `autoincrement` key generator generates numerical keys in ascending order,\n  the initial offset and the spacing can be configured (**note**: `autoincrement`\n  is currently only supported for non-sharded collections).\n  The sequence of generated keys is not guaranteed to be gap-free, because a new key\n  will be generated on every document insert attempt, not just for successful\n  inserts.\n\n- The `padded` key generator generates keys of a fixed length (16 bytes) in\n  ascending lexicographical sort order. This is ideal for usage with the _RocksDB_\n  engine, which will slightly benefit keys that are inserted in lexicographically\n  ascending order. The key generator can be used in a single-server or cluster.\n  The sequence of generated keys is not guaranteed to be gap-free.\n\n- The `uuid` key generator generates universally unique 128 bit keys, which\n  are stored in hexadecimal human-readable format. This key generator can be used\n  in a single-server or cluster to generate \"seemingly random\" keys. The keys\n  produced by this key generator are not lexicographically sorted.\n\nPlease note that keys are only guaranteed to be truly ascending in single\nserver deployments and for collections that only have a single shard (that includes\ncollections in a OneShard database).\nThe reason is that for collections with more than a single shard, document keys\nare generated on coordinator(s). For collections with a single shard, the document\nkeys are generated on the leader DB server, which has full control over the key\nsequence.\n\n"}, "allowUserKeys": {"type": "boolean", "description": "If set to `true`, then you are allowed to supply own key values in the\n`_key` attribute of documents. If set to `false`, then the key generator\nis solely be responsible for generating keys and an error is raised if you\nsupply own key values in the `_key` attribute of documents.\n\n", "format": ""}, "increment": {"type": "integer", "description": "increment value for `autoincrement` key generator. Not used for other key\ngenerator types.\n\n", "format": "int64"}, "offset": {"type": "integer", "description": "Initial offset value for `autoincrement` key generator.\nNot used for other key generator types.\n\n", "format": "int64"}}}, "collection_figures": {"type": "object", "properties": {"indexes": {"type": "object", "description": "\n", "format": "collection_figures_indexes"}}}, "collection_figures_indexes": {"type": "object", "properties": {"count": {"type": "integer", "description": "The total number of indexes defined for the collection, including the pre-defined\nindexes (e.g. primary index).\n\n", "format": "int64"}, "size": {"type": "integer", "description": "The total memory allocated for indexes in bytes.\n\n", "format": "int64"}}}, "get_api_database_new_OPTIONS": {"type": "object", "properties": {"sharding": {"type": "string", "description": "The sharding method to use for new collections in this database. Valid values\nare: \"\", \"flexible\", or \"single\". The first two are equivalent. _(cluster only)_\n\n", "format": ""}, "replicationFactor": {"type": "integer", "description": "Default replication factor for new collections created in this database.\nSpecial values include \"satellite\", which will replicate the collection to\nevery DB-Server (Enterprise Edition only), and 1, which disables replication.\n_(cluster only)_\n\n", "format": ""}, "writeConcern": {"type": "number", "description": "Default write concern for new collections created in this database.\nIt determines how many copies of each shard are required to be\nin sync on the different DB-Servers. If there are less then these many copies\nin the cluster a shard will refuse to write. Writes to shards with enough\nup-to-date copies will succeed at the same time however. The value of\n*writeConcern* can not be larger than *replicationFactor*. _(cluster only)_\n\n", "format": ""}}}, "get_api_database_new_USERS": {"type": "object", "properties": {"username": {"type": "string", "description": "Login name of an existing user or one to be created.\n\n", "format": ""}, "passwd": {"type": "string", "description": "The user password as a string. If not specified, it will default to an empty\nstring. The attribute is ignored for users that already exist.\n\n", "format": "password"}, "active": {"type": "boolean", "description": "A flag indicating whether the user account should be activated or not.\nThe default value is *true*. If set to *false*, then the user won't be able to\nlog into the database. The default is *true*. The attribute is ignored for users\nthat already exist.\n\n", "format": ""}, "extra": {"type": "object", "description": "A JSON object with extra user information. It is used by the web interface\nto store graph viewer settings and saved queries. Should not be set or\nmodified by end users, as custom attributes will not be preserved.\n\n", "format": ""}}}, "post_api_view_searchalias_indexes": {"type": "object", "properties": {"collection": {"type": "string", "description": "The name of a collection.\n\n", "format": ""}, "index": {"type": "string", "description": "The name of an inverted index of the `collection`, or the index ID without\nthe `<collection>/` prefix.\n\n", "format": ""}}}, "put_api_view_searchalias_indexes": {"type": "object", "properties": {"collection": {"type": "string", "description": "The name of a collection.\n\n", "format": ""}, "index": {"type": "string", "description": "The name of an inverted index of the `collection`, or the index ID without\nthe `<collection>/` prefix.\n\n", "format": ""}}}, "put_api_view_searchalias_indexes_reply": {"type": "object", "properties": {"collection": {"type": "string", "description": "The name of a collection.\n\n", "format": ""}, "index": {"type": "string", "description": "The name of an inverted index of the `collection`.\n\n", "format": ""}}}, "patch_api_view_searchalias_indexes": {"type": "object", "properties": {"collection": {"type": "string", "description": "The name of a collection.\n\n", "format": ""}, "index": {"type": "string", "description": "The name of an inverted index of the `collection`, or the index ID without\nthe `<collection>/` prefix.\n\n", "format": ""}, "operation": {"type": "string", "description": "Whether to add or remove the index to the stored `indexes` property of the View.\nPossible values: `\"add\"`, `\"del\"`. The default is `\"add\"`.\n\n", "format": ""}}}, "patch_api_view_searchalias_indexes_reply": {"type": "object", "properties": {"collection": {"type": "string", "description": "The name of a collection.\n\n", "format": ""}, "index": {"type": "string", "description": "The name of an inverted index of the `collection`.\n\n", "format": ""}}}, "graph_list": {"type": "object", "properties": {"graph": {"type": "object", "description": "The information about the newly created graph\n\n", "format": "graph_representation"}}}, "graph_representation": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the graph\n\n", "format": ""}, "edgeDefinitions": {"type": "array", "description": "An array of definitions for the relations of the graph.\nEach has the following type:\n\n", "items": {"$ref": "#/components/schemas/graph_edge_definition"}}, "orphanCollections": {"type": "array", "description": "An array of additional vertex collections.\nDocuments within these collections do not have edges within this graph.\n\n", "items": {"type": "string"}}, "numberOfShards": {"type": "integer", "description": "Number of shards created for every new collection in the graph.\n\n", "format": ""}, "_id": {"type": "string", "description": "The internal id value of this graph.\n\n", "format": ""}, "_rev": {"type": "string", "description": "The revision of this graph. Can be used to make sure to not override\nconcurrent modifications to this graph.\n\n", "format": ""}, "replicationFactor": {"type": "integer", "description": "The replication factor used for every new collection in the graph.\nCan also be the string `\"satellite\"` for a SmartGraph (Enterprise Edition only).\n\n", "format": ""}, "isSmart": {"type": "boolean", "description": "Whether the graph is a SmartGraph (Enterprise Edition only).\n\n", "format": ""}, "isDisjoint": {"type": "boolean", "description": "Whether the graph is a Disjoint SmartGraph (Enterprise Edition only).\n\n", "format": ""}, "smartGraphAttribute": {"type": "string", "description": "Name of the sharding attribute in the SmartGraph case (Enterprise Edition only).\n\n", "format": ""}}}, "post_api_gharial_create_opts": {"type": "object", "properties": {"smartGraphAttribute": {"type": "string", "description": "Only has effect in Enterprise Edition and it is required if isSmart is true.\nThe attribute name that is used to smartly shard the vertices of a graph.\nEvery vertex in this SmartGraph has to have this attribute.\nCannot be modified later.\n\n", "format": ""}, "satellites": {"type": "array", "description": "An array of collection names that is used to create SatelliteCollections\nfor a (Disjoint) SmartGraph using SatelliteCollections (Enterprise Edition only).\nEach array element must be a string and a valid collection name.\nThe collection type cannot be modified later.\n\n", "items": {"type": "string"}}, "numberOfShards": {"type": "integer", "description": "The number of shards that is used for every collection within this graph.\nCannot be modified later.\n\n", "format": ""}, "replicationFactor": {"type": "integer", "description": "The replication factor used when initially creating collections for this graph.\nCan be set to `\"satellite\"` to create a SatelliteGraph, which will ignore\n*numberOfShards*, *minReplicationFactor* and *writeConcern*\n(Enterprise Edition only).\n\n", "format": ""}, "writeConcern": {"type": "integer", "description": "Write concern for new collections in the graph.\nIt determines how many copies of each shard are required to be\nin sync on the different DB-Servers. If there are less then these many copies\nin the cluster a shard will refuse to write. Writes to shards with enough\nup-to-date copies will succeed at the same time however. The value of\n*writeConcern* can not be larger than *replicationFactor*. _(cluster only)_\n\n", "format": ""}}}, "post_api_vertex_create_opts": {"type": "object", "properties": {"satellites": {"type": "array", "description": "An array of collection names that is used to create SatelliteCollections\nfor a (Disjoint) SmartGraph using SatelliteCollections (Enterprise Edition only).\nEach array element must be a string and a valid collection name.\nThe collection type cannot be modified later.\n\n", "items": {"type": "string"}}}}, "post_api_edgedef_create_opts": {"type": "object", "properties": {"satellites": {"type": "array", "description": "An array of collection names that is used to create SatelliteCollections\nfor a (Disjoint) SmartGraph using SatelliteCollections (Enterprise Edition only).\nEach array element must be a string and a valid collection name.\nThe collection type cannot be modified later.\n\n", "items": {"type": "string"}}}}, "post_api_edgedef_modify_opts": {"type": "object", "properties": {"satellites": {"type": "array", "description": "An array of collection names that is used to create SatelliteCollections\nfor a (Disjoint) SmartGraph using SatelliteCollections (Enterprise Edition only).\nEach array element must be a string and a valid collection name.\nThe collection type cannot be modified later.\n\n", "items": {"type": "string"}}}}, "post_api_cursor_opts": {"type": "object", "properties": {"fullCount": {"type": "boolean", "description": "if set to *true* and the query contains a *LIMIT* clause, then the\nresult will have an *extra* attribute with the sub-attributes *stats*\nand *fullCount*, `{ ... , \"extra\": { \"stats\": { \"fullCount\": 123 } } }`.\nThe *fullCount* attribute will contain the number of documents in the result before the\nlast top-level LIMIT in the query was applied. It can be used to count the number of\ndocuments that match certain filter criteria, but only return a subset of them, in one go.\nIt is thus similar to MySQL's *SQL_CALC_FOUND_ROWS* hint. Note that setting the option\nwill disable a few LIMIT optimizations and may lead to more documents being processed,\nand thus make queries run longer. Note that the *fullCount* attribute may only\nbe present in the result if the query has a top-level LIMIT clause and the LIMIT\nclause is actually used in the query.\n\n", "format": ""}, "fillBlockCache": {"type": "boolean", "description": "if set to *true* or not specified, this will make the query store the data it \nreads via the RocksDB storage engine in the RocksDB block cache. This is usually \nthe desired behavior. The option can be set to *false* for queries that are\nknown to either read a lot of data which would thrash the block cache, or for queries\nthat read data which are known to be outside of the hot set. By setting the option\nto *false*, data read by the query will not make it into the RocksDB block cache if\nnot already in there, thus leaving more room for the actual hot set.\n\n", "format": ""}, "maxPlans": {"type": "integer", "description": "Limits the maximum number of plans that are created by the AQL query optimizer.\n\n", "format": "int64"}, "maxNodesPerCallstack": {"type": "integer", "description": "The number of execution nodes in the query plan after that stack splitting is\nperformed to avoid a potential stack overflow. Defaults to the configured value\nof the startup option `--query.max-nodes-per-callstack`.\n\nThis option is only useful for testing and debugging and normally does not need\nany adjustment.\n\n", "format": "int64"}, "maxWarningCount": {"type": "integer", "description": "Limits the maximum number of warnings a query will return. The number of warnings\na query will return is limited to 10 by default, but that number can be increased\nor decreased by setting this attribute.\n\n", "format": "int64"}, "failOnWarning": {"type": "boolean", "description": "When set to *true*, the query will throw an exception and abort instead of producing\na warning. This option should be used during development to catch potential issues\nearly. When the attribute is set to *false*, warnings will not be propagated to\nexceptions and will be returned with the query result.\nThere is also a server configuration option `--query.fail-on-warning` for setting the\ndefault value for *failOnWarning* so it does not need to be set on a per-query level.\n\n", "format": ""}, "stream": {"type": "boolean", "description": "Can be enabled to execute the query lazily. If set to *true*, then the query is\nexecuted as long as necessary to produce up to `batchSize` results. These\nresults are returned immediately and the query is suspended until the client\nasks for the next batch (if there are more results). Depending on the query\nthis can mean that the first results will be available much faster and that\nless memory is needed because the server only needs to store a subset of\nresults at a time. Read-only queries can benefit the most, unless `SORT`\nwithout index or `COLLECT` are involved that make it necessary to process all\ndocuments before a partial result can be returned. It is advisable to only use\nthis option for queries without exclusive locks.\n\nRemarks:\n- The query will hold resources until it ends (such as RocksDB snapshots, which\n  prevents compaction to some degree). Writes will be in memory until the query\n  is committed.\n- If existing documents are modified, then write locks are held on these\n  documents and other queries trying to modify the same documents will fail\n  because of this conflict.\n- A streaming query may fail late because of a conflict or for other reasons\n  after some batches were already returned successfully, possibly rendering the\n  results up to that point meaningless.\n- The query options `cache`, `count` and `fullCount` are not supported for\n  streaming queries.\n- Query statistics, profiling data and warnings are delivered as part of the\n  last batch.\n\nIf the `stream` option is *false* (default), then the complete result of the\nquery is calculated before any of it is returned to the client. The server\nstores the full result in memory (on the contacted Coordinator if in a cluster).\nAll other resources are freed immediately (locks, RocksDB snapshots). The query\nwill fail before it returns results in case of a conflict.\n\n", "format": ""}, "optimizer": {"type": "object", "description": "Options related to the query optimizer.\n\n", "format": "post_api_cursor_opts_optimizer"}, "profile": {"type": "integer", "description": "If set to `true` or `1`, then the additional query profiling information is returned\nin the `profile` sub-attribute of the `extra` return attribute, unless the query result\nis served from the query cache. If set to `2`, the query includes execution stats\nper query plan node in `stats.nodes` sub-attribute of the `extra` return attribute.\nAdditionally, the query plan is returned in the `extra.plan` sub-attribute.\n\n", "format": ""}, "satelliteSyncWait": {"type": "number", "description": "This *Enterprise Edition* parameter allows to configure how long a DB-Server has time\nto bring the SatelliteCollections involved in the query into sync.\nThe default value is `60.0` seconds. When the maximal time is reached, the query\nis stopped.\n\n", "format": "double"}, "maxRuntime": {"type": "number", "description": "The query has to be executed within the given runtime or it is killed.\nThe value is specified in seconds. The default value is `0.0` (no timeout).\n\n", "format": "double"}, "maxTransactionSize": {"type": "integer", "description": "The transaction size limit in bytes.\n\n", "format": "int64"}, "intermediateCommitSize": {"type": "integer", "description": "The maximum total size of operations after which an intermediate commit is performed\nautomatically.\n\n", "format": "int64"}, "intermediateCommitCount": {"type": "integer", "description": "The maximum number of operations after which an intermediate commit is performed\nautomatically.\n\n", "format": "int64"}, "skipInaccessibleCollections": {"type": "boolean", "description": "Let AQL queries (especially graph traversals) treat collection to which a user\nhas no access rights for as if these collections are empty. Instead of returning a\nforbidden access error, your queries execute normally. This is intended to help\nwith certain use-cases: A graph contains several collections and different users\nexecute AQL queries on that graph. You can naturally limit the accessible\nresults by changing the access rights of users on collections.\n\nThis feature is only available in the Enterprise Edition.\n\n", "format": ""}}}, "post_api_cursor_opts_optimizer": {"type": "object", "properties": {"rules": {"type": "array", "description": "A list of to-be-included or to-be-excluded optimizer rules can be put into this\nattribute, telling the optimizer to include or exclude specific rules. To disable\na rule, prefix its name with a `-`, to enable a rule, prefix it with a `+`. There is\nalso a pseudo-rule `all`, which matches all optimizer rules. `-all` disables all rules.\n\n", "items": {"type": "string"}}}}, "post_api_cursor_extra": {"type": "object", "properties": {"warnings": {"type": "array", "description": "A list of query warnings.\n\n", "items": {"$ref": "#/components/schemas/post_api_cursor_extra_warnings"}}, "stats": {"type": "object", "description": "An object with query statistics.\n\n", "format": "post_api_cursor_extra_stats"}, "profile": {"type": "object", "description": "The duration of the different query execution phases in seconds.\n\n", "format": "post_api_cursor_extra_profile"}, "plan": {"type": "object", "description": "The execution plan.\n\n", "format": "post_api_cursor_extra_plan"}}}, "post_api_cursor_extra_warnings": {"type": "object", "properties": {"code": {"type": "integer", "description": "An error code.\n\n", "format": ""}, "message": {"type": "string", "description": "A description of the problem.\n\n", "format": ""}}}, "post_api_cursor_extra_stats": {"type": "object", "properties": {"writesExecuted": {"type": "integer", "description": "The total number of data-modification operations successfully executed.\n\n", "format": ""}, "writesIgnored": {"type": "integer", "description": "The total number of data-modification operations that were unsuccessful,\nbut have been ignored because of the `ignoreErrors` query option.\n\n", "format": ""}, "scannedFull": {"type": "integer", "description": "The total number of documents iterated over when scanning a collection \nwithout an index. Documents scanned by subqueries are included in the result, but\noperations triggered by built-in or user-defined AQL functions are not.\n\n", "format": ""}, "scannedIndex": {"type": "integer", "description": "The total number of documents iterated over when scanning a collection using\nan index. Documents scanned by subqueries are included in the result, but operations\ntriggered by built-in or user-defined AQL functions are not.\n\n", "format": ""}, "cursorsCreated": {"type": "integer", "description": "The total number of cursor objects created during query execution. Cursor\nobjects are created for index lookups.\n\n", "format": ""}, "cursorsRearmed": {"type": "integer", "description": "The total number of times an existing cursor object was repurposed.\nRepurposing an existing cursor object is normally more efficient compared to destroying an\nexisting cursor object and creating a new one from scratch.\n\n", "format": ""}, "cacheHits": {"type": "integer", "description": "The total number of index entries read from in-memory caches for indexes\nof type edge or persistent. This value is only non-zero when reading from indexes\nthat have an in-memory cache enabled, and when the query allows using the in-memory\ncache (i.e. using equality lookups on all index attributes).\n\n", "format": ""}, "cacheMisses": {"type": "integer", "description": "The total number of cache read attempts for index entries that could not\nbe served from in-memory caches for indexes of type edge or persistent. This value\nis only non-zero when reading from indexes that have an in-memory cache enabled, the\nquery allows using the in-memory cache (i.e. using equality lookups on all index attributes)\nand the looked up values are not present in the cache.\n\n", "format": ""}, "filtered": {"type": "integer", "description": "The total number of documents removed after executing a filter condition\nin a `FilterNode` or another node that post-filters data. Note that nodes of the\n`IndexNode` type can also filter documents by selecting only the required index range \nfrom a collection, and the `filtered` value only indicates how much filtering was done by a\npost filter in the `IndexNode` itself or following `FilterNode` nodes.\nNodes of the `EnumerateCollectionNode` and `TraversalNode` types can also apply\nfilter conditions and can report the number of filtered documents.\n\n", "format": ""}, "httpRequests": {"type": "integer", "description": "The total number of cluster-internal HTTP requests performed.\n\n", "format": ""}, "fullCount": {"type": "integer", "description": "The total number of documents that matched the search condition if the query's\nfinal top-level `LIMIT` operation were not present.\nThis attribute may only be returned if the `fullCount` option was set when starting the \nquery and only contains a sensible value if the query contains a `LIMIT` operation on\nthe top level.\n\n", "format": ""}, "executionTime": {"type": "number", "description": "The query execution time (wall-clock time) in seconds.\n\n", "format": ""}, "peakMemoryUsage": {"type": "integer", "description": "The maximum memory usage of the query while it was running. In a cluster,\nthe memory accounting is done per shard, and the memory usage reported is the peak\nmemory usage value from the individual shards.\nNote that to keep things lightweight, the per-query memory usage is tracked on a relatively \nhigh level, not including any memory allocator overhead nor any memory used for temporary\nresults calculations (e.g. memory allocated/deallocated inside AQL expressions and function \ncalls).\n\n", "format": ""}, "nodes": {"type": "array", "description": "When the query is executed with the `profile` option set to at least `2`,\nthen this attribute contains runtime statistics per query execution node.\nFor a human readable output, you can execute\n`db._profileQuery(<query>, <bind-vars>)` in arangosh.\n\n", "items": {"$ref": "#/components/schemas/post_api_cursor_extra_stats_nodes"}}}}, "post_api_cursor_extra_stats_nodes": {"type": "object", "properties": {"id": {"type": "integer", "description": "The execution node ID to correlate the statistics with the `plan` returned in\nthe `extra` attribute.\n\n", "format": ""}, "calls": {"type": "integer", "description": "The number of calls to this node.\n\n", "format": ""}, "items": {"type": "integer", "description": "The number of items returned by this node. Items are the temporary results\nreturned at this stage.\n\n", "format": ""}, "runtime": {"type": "number", "description": "The execution time of this node in seconds.\n\n", "format": ""}}}, "post_api_cursor_extra_profile": {"type": "object", "properties": {"initializing": {"type": "number", "description": "", "format": ""}, "parsing": {"type": "number", "description": "", "format": ""}, "optimizing ast": {"type": "number", "description": "", "format": ""}, "loading collections": {"type": "number", "description": "", "format": ""}, "instantiating plan": {"type": "number", "description": "", "format": ""}, "optimizing plan": {"type": "number", "description": "", "format": ""}, "executing": {"type": "number", "description": "", "format": ""}, "finalizing": {"type": "number", "description": "\n", "format": ""}}}, "post_api_cursor_extra_plan": {"type": "object", "properties": {"nodes": {"type": "array", "description": "A nested list of the execution plan nodes.\n\n", "items": {"type": "object"}}, "rules": {"type": "array", "description": "A list with the names of the applied optimizer rules.\n\n", "items": {"type": "string"}}, "collections": {"type": "array", "description": "A list of the collections involved in the query. The list only includes the\ncollections that can statically be determined at query compile time.\n\n", "items": {"$ref": "#/components/schemas/post_api_cursor_extra_plan_collections"}}, "variables": {"type": "array", "description": "All of the query variables, including user-created and internal ones.\n\n", "items": {"type": "object"}}, "estimatedCost": {"type": "integer", "description": "The estimated cost of the query.\n\n", "format": ""}, "estimatedNrItems": {"type": "integer", "description": "The estimated number of results.\n\n", "format": ""}, "isModificationQuery": {"type": "boolean", "description": "Whether the query contains write operations.\n\n", "format": ""}}}, "post_api_cursor_extra_plan_collections": {"type": "object", "properties": {"name": {"type": "string", "description": "The collection name.\n\n", "format": ""}, "type": {"type": "string", "description": "How the collection is used. Can be `\"read\"`, `\"write\"`, or `\"exclusive\"`.\n\n", "format": ""}}}, "get_cluster_maintenance_dbserver_result": {"type": "object", "properties": {"Mode": {"type": "string", "description": "The mode of the DB-Server. The value is `\"maintenance\"`.\n\n", "format": ""}, "Until": {"type": "string", "description": "Until what date and time the maintenance mode currently lasts, in the\nISO 8601 date/time format.\n\n", "format": "dateTime"}}}}}, "paths": {"/_api/user": {"post": {"description": "Create a new user. You need server access level *Administrate* in order to\nexecute this REST call.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"user": {"type": "string", "description": "The name of the user as a string. This is mandatory.\n"}, "passwd": {"type": "string", "description": "The user password as a string. If not specified, it will default to an empty\nstring.\n"}, "active": {"type": "boolean", "description": "An optional flag that specifies whether the user is active. If not\nspecified, this will default to *true*.\n"}, "extra": {"type": "object", "description": "A JSON object with extra user information. It is used by the web interface\nto store graph viewer settings and saved queries. Should not be set or\nmodified by end users, as custom attributes will not be preserved.\n"}}, "required": ["user", "passwd"]}}}}, "responses": {"201": {"description": "Returned if the user can be added by the server\n"}, "400": {"description": "If the JSON representation is malformed or mandatory data is missing\nfrom the request.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}, "409": {"description": "Returned if a user with the same name already exists.\n"}}, "tags": ["User Management"]}}, "/_api/user/{user}/database/{dbname}": {"put": {"description": "Sets the database access levels for the database *dbname* of user *user*. You\nneed the *Administrate* server access level in order to execute this REST\ncall.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"grant": {"type": "string", "description": "- Use \"rw\" to set the database access level to *Administrate*.\n- Use \"ro\" to set the database access level to *Access*.\n- Use \"none\" to set the database access level to *No access*.\n"}}, "required": ["grant"]}}}}, "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user.\n", "in": "path"}, {"name": "dbname", "schema": {"type": "string"}, "required": true, "description": "The name of the database.\n", "in": "path"}], "responses": {"200": {"description": "Returned if the access level was changed successfully.\n"}, "400": {"description": "If the JSON representation is malformed or mandatory data is missing\nfrom the request.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}}, "tags": ["User Management"]}, "delete": {"description": "Clears the database access level for the database *dbname* of user *user*. As\nconsequence the default database access level is used. If there is no defined\ndefault database access level, it defaults to *No access*. You need permission\nto the *_system* database in order to execute this REST call.\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user.\n", "in": "path"}, {"name": "dbname", "schema": {"type": "string"}, "required": true, "description": "The name of the database.\n", "in": "path"}], "responses": {"202": {"description": "Returned if the access permissions were changed successfully.\n"}, "400": {"description": "If the JSON representation is malformed or mandatory data is missing\nfrom the request.\n"}}, "tags": ["User Management"]}, "get": {"description": "Fetch the database access level for a specific database\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user for which you want to query the databases.\n", "in": "path"}, {"name": "dbname", "schema": {"type": "string"}, "required": true, "description": "The name of the database to query\n", "in": "path"}], "responses": {"200": {"description": "Returned if the access level can be returned\n"}, "400": {"description": "If the access privileges are not right etc.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}}, "tags": ["User Management"]}}, "/_api/user/{user}/database/{dbname}/{collection}": {"put": {"description": "Sets the collection access level for the *collection* in the database *dbname*\nfor user *user*. You need the *Administrate* server access level in order to\nexecute this REST call.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"grant": {"type": "string", "description": "Use \"rw\" to set the collection level access to *Read/Write*.\nUse \"ro\" to set the collection level access to  *Read Only*.\nUse \"none\" to set the collection level access to *No access*.\n"}}, "required": ["grant"]}}}}, "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user.\n", "in": "path"}, {"name": "dbname", "schema": {"type": "string"}, "required": true, "description": "The name of the database.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"200": {"description": "Returned if the access permissions were changed successfully.\n"}, "400": {"description": "If the JSON representation is malformed or mandatory data is missing\nfrom the request.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}}, "tags": ["User Management"]}, "delete": {"description": "Clears the collection access level for the collection *collection* in the\ndatabase *dbname* of user *user*.  As consequence the default collection\naccess level is used. If there is no defined default collection access level,\nit defaults to *No access*.  You need permissions to the *_system* database in\norder to execute this REST call.\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user.\n", "in": "path"}, {"name": "dbname", "schema": {"type": "string"}, "required": true, "description": "The name of the database.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"202": {"description": "Returned if the access permissions were changed successfully.\n"}, "400": {"description": "If there was an error\n"}}, "tags": ["User Management"]}, "get": {"description": "Returns the collection access level for a specific collection\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user for which you want to query the databases.\n", "in": "path"}, {"name": "dbname", "schema": {"type": "string"}, "required": true, "description": "The name of the database to query\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the collection\n", "in": "path"}], "responses": {"200": {"description": "Returned if the access level can be returned\n"}, "400": {"description": "If the access privileges are not right etc.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}}, "tags": ["User Management"]}}, "/_api/user/{user}/database/": {"get": {"description": "Fetch the list of databases available to the specified *user*. You need\n*Administrate* for the server access level in order to execute this REST call.\nThe call will return a JSON object with the per-database access\nprivileges for the specified user. The *result* object will contain\nthe databases names as object keys, and the associated privileges\nfor the database as values.\nIn case you specified *full*, the result will contain the permissions\nfor the databases as well as the permissions for the collections.\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user for which you want to query the databases.\n", "in": "path"}, {"name": "full", "schema": {"type": "boolean"}, "required": false, "description": "Return the full set of access levels for all databases and all collections.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the list of available databases can be returned.\n"}, "400": {"description": "If the access privileges are not right etc.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}}, "tags": ["User Management"]}}, "/_api/user/{user}": {"put": {"description": "Replaces the data of an existing user. You need server access level\n*Administrate* in order to execute this REST call. Additionally, a user can\nchange his/her own data.\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"passwd": {"type": "string", "description": "The user password as a string. If not specified, it will default to an empty\nstring.\n"}, "active": {"type": "boolean", "description": "An optional flag that specifies whether the user is active. If not\nspecified, this will default to *true*.\n"}, "extra": {"type": "object", "description": "A JSON object with extra user information. It is used by the web interface\nto store graph viewer settings and saved queries. Should not be set or\nmodified by end users, as custom attributes will not be preserved.\n"}}, "required": ["passwd"]}}}}, "responses": {"200": {"description": "Is returned if the user data can be replaced by the server.\n"}, "400": {"description": "The JSON representation is malformed or mandatory data is missing from the request\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}, "404": {"description": "The specified user does not exist\n"}}, "tags": ["User Management"]}, "patch": {"description": "Partially updates the data of an existing user. You need server access level\n*Administrate* in order to execute this REST call. Additionally, a user can\nchange his/her own data.\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"passwd": {"type": "string", "description": "The user password as a string.\n"}, "active": {"type": "boolean", "description": "An optional flag that specifies whether the user is active.\n"}, "extra": {"type": "object", "description": "A JSON object with extra user information. It is used by the web interface\nto store graph viewer settings and saved queries. Should not be set or\nmodified by end users, as custom attributes will not be preserved.\n"}}, "required": ["passwd"]}}}}, "responses": {"200": {"description": "Is returned if the user data can be replaced by the server.\n"}, "400": {"description": "The JSON representation is malformed or mandatory data is missing from the request.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}, "404": {"description": "The specified user does not exist\n"}}, "tags": ["User Management"]}, "delete": {"description": "Removes an existing user, identified by *user*.  You need *Administrate* for\nthe server access level in order to execute this REST call.\n", "parameters": [{"name": "user", "schema": {"type": "string"}, "required": true, "description": "The name of the user\n", "in": "path"}], "responses": {"202": {"description": "Is returned if the user was removed by the server\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}, "404": {"description": "The specified user does not exist\n"}}, "tags": ["User Management"]}}, "/_api/user/": {"get": {"description": "Fetches data about all users.  You need the *Administrate* server access level\nin order to execute this REST call.  Otherwise, you will only get information\nabout yourself.\nThe call will return a JSON object with at least the following\nattributes on success:\n- *user*: The name of the user as a string.\n- *active*: An optional flag that specifies whether the user is active.\n- *extra*: A JSON object with extra user information. It is used by the web\n  interface to store graph viewer settings and saved queries.\n", "responses": {"200": {"description": "The users that were found.\n"}, "401": {"description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n"}, "403": {"description": "Returned if you have *No access* server access level.\n"}}, "tags": ["User Management"]}}, "/_api/analyzer": {"post": {"description": "Creates a new Analyzer based on the provided configuration.\n", "operationId": " RestAnalyzerHandler:Create", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "The Analyzer name.\n"}, "type": {"type": "string", "description": "The Analyzer type.\n"}, "properties": {"type": "object", "description": "The properties used to configure the specified Analyzer type.\n"}, "features": {"type": "array", "items": {"type": "string"}, "description": "The set of features to set on the Analyzer generated fields.\nThe default value is an empty array.\n"}}, "required": ["name", "type"]}}}}, "responses": {"200": {"description": "An Analyzer with a matching name and definition already exists.\n"}, "201": {"description": "A new Analyzer definition was successfully created.\n"}, "400": {"description": "One or more of the required parameters is missing or one or more of the parameters\nis not valid.\n"}, "403": {"description": "The user does not have permission to create and Analyzer with this configuration.\n"}}, "tags": ["Analyzers"]}, "get": {"description": "Retrieves a an array of all Analyzer definitions.\nThe resulting array contains objects with the following attributes:\n- *name*: the Analyzer name\n- *type*: the Analyzer type\n- *properties*: the properties used to configure the specified type\n- *features*: the set of features to set on the Analyzer generated fields\n", "operationId": " RestAnalyzerHandler:List", "responses": {"200": {"description": "The Analyzer definitions was retrieved successfully.\n"}}, "tags": ["Analyzers"]}}, "/_api/analyzer/{analyzer-name}": {"get": {"description": "Retrieves the full definition for the specified Analyzer name.\nThe resulting object contains the following attributes:\n- *name*: the Analyzer name\n- *type*: the Analyzer type\n- *properties*: the properties used to configure the specified type\n- *features*: the set of features to set on the Analyzer generated fields\n", "operationId": " RestAnalyzerHandler:GetDefinition", "parameters": [{"name": "analyzer-name", "schema": {"type": "string"}, "required": true, "description": "The name of the Analyzer to retrieve.\n", "in": "path"}], "responses": {"200": {"description": "The Analyzer definition was retrieved successfully.\n"}, "404": {"description": "Such an Analyzer configuration does not exist.\n"}}, "tags": ["Analyzers"]}, "delete": {"description": "Removes an Analyzer configuration identified by *analyzer-name*.\nIf the Analyzer definition was successfully dropped, an object is returned with\nthe following attributes:\n- *error*: *false*\n- *name*: The name of the removed Analyzer\n", "operationId": " RestAnalyzerHandler:Delete", "parameters": [{"name": "analyzer-name", "schema": {"type": "string"}, "required": true, "description": "The name of the Analyzer to remove.\n", "in": "path"}, {"name": "force", "schema": {"type": "boolean"}, "required": false, "description": "The Analyzer configuration should be removed even if it is in-use.\nThe default value is *false*.\n", "in": "query"}], "responses": {"200": {"description": "The Analyzer configuration was removed successfully.\n"}, "400": {"description": "The *analyzer-name* was not supplied or another request parameter was not\nvalid.\n"}, "403": {"description": "The user does not have permission to remove this Analyzer configuration.\n"}, "404": {"description": "Such an Analyzer configuration does not exist.\n"}, "409": {"description": "The specified Analyzer configuration is still in use and *force* was omitted or\n*false* specified.\n"}}, "tags": ["Analyzers"]}}, "/_api/explain": {"post": {"description": "To explain how an AQL query would be executed on the server, the query string\ncan be sent to the server via an HTTP POST request. The server will then validate\nthe query and create an execution plan for it. The execution plan will be\nreturned, but the query will not be executed.\nThe execution plan that is returned by the server can be used to estimate the\nprobable performance of the query. Though the actual performance will depend\non many different factors, the execution plan normally can provide some rough\nestimates on the amount of work the server needs to do in order to actually run\nthe query.\nBy default, the explain operation will return the optimal plan as chosen by\nthe query optimizer The optimal plan is the plan with the lowest total estimated\ncost. The plan will be returned in the attribute *plan* of the response object.\nIf the option *allPlans* is specified in the request, the result will contain\nall plans created by the optimizer. The plans will then be returned in the\nattribute *plans*.\nThe result will also contain an attribute *warnings*, which is an array of\nwarnings that occurred during optimization or execution plan creation. Additionally,\na *stats* attribute is contained in the result with some optimizer statistics.\nIf *allPlans* is set to *false*, the result will contain an attribute *cacheable*\nthat states whether the query results can be cached on the server if the query\nresult cache were used. The *cacheable* attribute is not present when *allPlans*\nis set to *true*.\nEach plan in the result is a JSON object with the following attributes:\n- *nodes*: the array of execution nodes of the plan.\n- *estimatedCost*: the total estimated cost for the plan. If there are multiple\n  plans, the optimizer will choose the plan with the lowest total cost.\n- *collections*: an array of collections used in the query\n- *rules*: an array of rules the optimizer applied.\n- *variables*: array of variables used in the query (note: this may contain\n  internal variables created by the optimizer)\n", "operationId": " explainQuery", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"query": {"type": "string", "description": "the query which you want explained; If the query references any bind variables,\nthese must also be passed in the attribute *bindVars*. Additional\noptions for the query can be passed in the *options* attribute.\n"}, "bindVars": {"type": "array", "format": "object", "items": {"type": "object"}, "description": "key/value pairs representing the bind parameters.\n"}, "options": {"$ref": "#/components/schemas/explain_options", "description": "Options for the query\n"}}, "required": ["query"]}}}}, "responses": {"200": {"description": "If the query is valid, the server will respond with *HTTP 200* and\nreturn the optimal execution plan in the *plan* attribute of the response.\nIf option *allPlans* was set in the request, an array of plans will be returned\nin the *allPlans* attribute instead.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\nor if the query contains a parse error. The body of the response will\ncontain the error details embedded in a JSON object.\nOmitting bind variables if the query references any will also result\nin an *HTTP 400* error.\n"}, "404": {"description": "The server will respond with *HTTP 404* in case a non-existing collection is\naccessed in the query.\n"}}, "tags": ["AQL"]}}, "/_api/query": {"post": {"description": "This endpoint is for query validation only. To actually query the database,\nsee `/api/cursor`.\n", "operationId": " parseQuery", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"query": {"type": "string", "description": "To validate a query string without executing it, the query string can be\npassed to the server via an HTTP POST request.\n"}}, "required": ["query"]}}}}, "responses": {"200": {"description": "If the query is valid, the server will respond with *HTTP 200* and\nreturn the names of the bind parameters it found in the query (if any) in\nthe *bindVars* attribute of the response. It will also return an array\nof the collections used in the query in the *collections* attribute.\nIf a query can be parsed successfully, the *ast* attribute of the returned\nJSON will contain the abstract syntax tree representation of the query.\nThe format of the *ast* is subject to change in future versions of\nArangoDB, but it can be used to inspect how ArangoDB interprets a given\nquery. Note that the abstract syntax tree will be returned without any\noptimizations applied to it.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\nor if the query contains a parse error. The body of the response will\ncontain the error details embedded in a JSON object.\n"}}, "tags": ["AQL"]}}, "/_api/query/rules": {"get": {"description": "A list of all optimizer rules and their properties.\n", "operationId": " queryRules", "responses": {"200": {"description": "is returned if the list of optimizer rules can be retrieved successfully.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"": {"$ref": "#/components/schemas/get_api_query_rules", "items": {"type": "get_api_query_rules"}, "description": "An array of objects. Each object describes an AQL optimizer rule.\n"}}, "required": [""]}}}}}, "tags": ["AQL"]}}, "/_api/query/properties": {"get": {"description": "Returns the current query tracking configuration. The configuration is a\nJSON object with the following properties:\n- *enabled*: if set to *true*, then queries will be tracked. If set to\n  *false*, neither queries nor slow queries will be tracked.\n- *trackSlowQueries*: if set to *true*, then slow queries will be tracked\n  in the list of slow queries if their runtime exceeds the value set in\n  *slowQueryThreshold*. In order for slow queries to be tracked, the *enabled*\n  property must also be set to *true*.\n- *trackBindVars*: if set to *true*, then bind variables used in queries will\n  be tracked.\n- *maxSlowQueries*: the maximum number of slow queries to keep in the list\n  of slow queries. If the list of slow queries is full, the oldest entry in\n  it will be discarded when additional slow queries occur.\n- *slowQueryThreshold*: the threshold value for treating a query as slow. A\n  query with a runtime greater or equal to this threshold value will be\n  put into the list of slow queries when slow query tracking is enabled.\n  The value for *slowQueryThreshold* is specified in seconds.\n- *maxQueryStringLength*: the maximum query string length to keep in the\n  list of queries. Query strings can have arbitrary lengths, and this property\n  can be used to save memory in case very long query strings are used. The\n  value is specified in bytes.\n", "operationId": " readQueryProperties", "responses": {"200": {"description": "Is returned if properties were retrieved successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\n"}}, "tags": ["AQL"]}, "put": {"description": "The properties need to be passed in the attribute *properties* in the body\nof the HTTP request. *properties* needs to be a JSON object.\nAfter the properties have been changed, the current set of properties will\nbe returned in the HTTP response.\n", "operationId": " replaceProperties", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"enabled": {"type": "boolean", "description": "If set to *true*, then queries will be tracked. If set to\n*false*, neither queries nor slow queries will be tracked.\n"}, "trackSlowQueries": {"type": "boolean", "description": "If set to *true*, then slow queries will be tracked\nin the list of slow queries if their runtime exceeds the value set in\n*slowQueryThreshold*. In order for slow queries to be tracked, the *enabled*\nproperty must also be set to *true*.\n"}, "trackBindVars": {"type": "boolean", "description": "If set to *true*, then the bind variables used in queries will be tracked\nalong with queries.\n"}, "maxSlowQueries": {"type": "integer", "format": "int64", "description": "The maximum number of slow queries to keep in the list\nof slow queries. If the list of slow queries is full, the oldest entry in\nit will be discarded when additional slow queries occur.\n"}, "slowQueryThreshold": {"type": "integer", "format": "int64", "description": "The threshold value for treating a query as slow. A\nquery with a runtime greater or equal to this threshold value will be\nput into the list of slow queries when slow query tracking is enabled.\nThe value for *slowQueryThreshold* is specified in seconds.\n"}, "maxQueryStringLength": {"type": "integer", "format": "int64", "description": "The maximum query string length to keep in the list of queries.\nQuery strings can have arbitrary lengths, and this property\ncan be used to save memory in case very long query strings are used. The\nvalue is specified in bytes.\n"}}, "required": ["enabled", "trackSlowQueries", "trackBindVars", "maxSlowQueries", "slowQueryThreshold", "maxQueryStringLength"]}}}}, "responses": {"200": {"description": "Is returned if the properties were changed successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\n"}}, "tags": ["AQL"]}}, "/_api/query/current": {"get": {"description": "Returns an array containing the AQL queries currently running in the selected\ndatabase. Each query is a JSON object with the following attributes:\n- *id*: the query's id\n- *database*: the name of the database the query runs in\n- *user*: the name of the user that started the query\n- *query*: the query string (potentially truncated)\n- *bindVars*: the bind parameter values used by the query\n- *started*: the date and time when the query was started\n- *runTime*: the query's run time up to the point the list of queries was\n  queried\n- *state*: the query's current execution state (as a string). One of:\n  - `\"initializing\"`\n  - `\"parsing\"`\n  - `\"optimizing ast\"`\n  - `\"loading collections\"`\n  - `\"instantiating plan\"`\n  - `\"optimizing plan\"`\n  - `\"executing\"`\n  - `\"finalizing\"`\n  - `\"finished\"`\n  - `\"killed\"`\n  - `\"invalid\"`\n- *stream*: whether or not the query uses a streaming cursor\n", "operationId": " readQuery:current", "parameters": [{"name": "all", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, will return the currently running queries in all databases,\nnot just the selected one.\nUsing the parameter is only allowed in the system database and with superuser\nprivileges.\n", "in": "query"}], "responses": {"200": {"description": "Is returned when the list of queries can be retrieved successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\n"}, "403": {"description": "*HTTP 403* is returned in case the *all* parameter was used, but the request\nwas made in a different database than _system, or by an non-privileged user.\n"}}, "tags": ["AQL"]}}, "/_api/query/slow": {"get": {"description": "Returns an array containing the last AQL queries that are finished and\nhave exceeded the slow query threshold in the selected database.\nThe maximum amount of queries in the list can be controlled by setting\nthe query tracking property `maxSlowQueries`. The threshold for treating\na query as *slow* can be adjusted by setting the query tracking property\n`slowQueryThreshold`.\nEach query is a JSON object with the following attributes:\n- *id*: the query's id\n- *database*: the name of the database the query runs in\n- *user*: the name of the user that started the query\n- *query*: the query string (potentially truncated)\n- *bindVars*: the bind parameter values used by the query\n- *started*: the date and time when the query was started\n- *runTime*: the query's total run time\n- *state*: the query's current execution state (will always be \"finished\"\n  for the list of slow queries)\n- *stream*: whether or not the query uses a streaming cursor\n", "operationId": " readQuery:Slow", "parameters": [{"name": "all", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, will return the slow queries from all databases, not just\nthe selected one.\nUsing the parameter is only allowed in the system database and with superuser\nprivileges.\n", "in": "query"}], "responses": {"200": {"description": "Is returned when the list of queries can be retrieved successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\n"}, "403": {"description": "*HTTP 403* is returned in case the *all* parameter was used, but the request\nwas made in a different database than _system, or by an non-privileged user.\n"}}, "tags": ["AQL"]}, "delete": {"description": "Clears the list of slow AQL queries in the currently selected database\n", "operationId": " deleteSlowQueries", "parameters": [{"name": "all", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, will clear the slow query history in all databases, not just\nthe selected one.\nUsing the parameter is only allowed in the system database and with superuser\nprivileges.\n", "in": "query"}], "responses": {"200": {"description": "The server will respond with *HTTP 200* when the list of queries was\ncleared successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request.\n"}}, "tags": ["AQL"]}}, "/_api/query/{query-id}": {"delete": {"description": "\nKills a running query in the currently selected database. The query will be \nterminated at the next cancelation point.\n\n", "operationId": " deleteQuery", "parameters": [{"name": "query-id", "schema": {"type": "string"}, "required": true, "description": "The id of the query.\n", "in": "path"}, {"name": "all", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, will attempt to kill the specified query in all databases, \nnot just the selected one.\nUsing the parameter is only allowed in the system database and with superuser\nprivileges.\n\n", "in": "query"}], "responses": {"200": {"description": "The server will respond with *HTTP 200* when the query was still running when\nthe kill request was executed and the query's kill flag was set.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request.\n"}, "403": {"description": "*HTTP 403* is returned in case the *all* parameter was used, but the request\nwas made in a different database than _system, or by an non-privileged user.\n"}, "404": {"description": "The server will respond with *HTTP 404* when no query with the specified\nid was found.\n"}}, "tags": ["AQL"]}}, "/_api/control_pregel": {"post": {"description": "To start an execution you need to specify the algorithm name and a named graph\n(SmartGraph in cluster). Alternatively you can specify the vertex and edge\ncollections. Additionally you can specify custom parameters which vary for each\nalgorithm, see [Pregel - Available Algorithms](https://www.arangodb.com/docs/stable/graphs-pregel.html#available-algorithms).\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"algorithm": {"type": "string", "description": "Name of the algorithm. One of:\n- `\"pagerank\"` - Page Rank\n- `\"sssp\"` - Single-Source Shortest Path\n- `\"connectedcomponents\"` - Connected Components\n- `\"wcc\"` - Weakly Connected Components\n- `\"scc\"` - Strongly Connected Components\n- `\"hits\"` - Hyperlink-Induced Topic Search\n- `\"effectivecloseness\"` - Effective Closeness\n- `\"linerank\"` - LineRank\n- `\"labelpropagation\"` - Label Propagation\n- `\"slpa\"` - Speaker-Listener Label Propagation\n"}, "graphName": {"type": "string", "description": "Name of a graph. Either this or the parameters `vertexCollections` and\n`edgeCollections` are required.\nPlease note that there are special sharding requirements for graphs in order\nto be used with Pregel.\n"}, "vertexCollections": {"type": "array", "items": {"type": "string"}, "description": "List of vertex collection names.\nPlease note that there are special sharding requirements for collections in order\nto be used with Pregel.\n"}, "edgeCollections": {"type": "array", "items": {"type": "string"}, "description": "List of edge collection names.\nPlease note that there are special sharding requirements for collections in order\nto be used with Pregel.\n"}, "params": {"type": "object", "description": "General as well as algorithm-specific options.\nThe most important general option is \"store\", which controls whether the results\ncomputed by the Pregel job are written back into the source collections or not.\nAnother important general option is \"parallelism\", which controls the number of\nparallel threads that work on the Pregel job at most. If \"parallelism\" is not\nspecified, a default value may be used. In addition, the value of \"parallelism\"\nmay be effectively capped at some server-specific value.\nThe option \"useMemoryMaps\" controls whether to use disk based files to store\ntemporary results. This might make the computation disk-bound, but allows you to\nrun computations which would not fit into main memory. It is recommended to set\nthis flag for larger datasets.\nThe attribute \"shardKeyAttribute\" specifies the shard key that edge collections are\nsharded after (default: `\"vertex\"`).\n"}}, "required": ["algorithm"]}}}}, "responses": {"200": {"description": "HTTP 200 is returned in case the Pregel was successfully created and the reply\nbody is a string with the `id` to query for the status or to cancel the\nexecution.\n"}, "400": {"description": "An HTTP 400 error is returned if the set of collections for the Pregel job includes\na system collection, or if the collections to not conform to the sharding requirements\nfor Pregel jobs.\n"}, "403": {"description": "An HTTP 403 error is returned if there are not sufficient privileges to access\nthe collections specified for the Pregel job.\n"}, "404": {"description": "\nAn HTTP 404 error is returned if the specified \"algorithm\" is not found, or the\ngraph specified in \"graphName\" is not found, or at least one the collections \nspecified in \"vertexCollections\" or \"edgeCollections\" is not found.\n"}}, "tags": ["Pregel"]}, "get": {"description": "Returns a list of currently running and recently finished Pregel jobs without\nretrieving their results.\n", "responses": {"200": {"description": "Is returned when the list of jobs can be retrieved successfully.\n"}}, "tags": ["Pregel"]}}, "/_api/control_pregel/{id}": {"get": {"description": "Returns the current state of the execution, the current global superstep, the\nruntime, the global aggregator values as well as the number of sent and\nreceived messages.\n", "parameters": [{"name": "id", "schema": {"type": "number"}, "required": true, "description": "Pregel execution identifier.\n", "in": "path"}], "responses": {"200": {"description": "HTTP 200 is returned in case the job execution ID was valid and the state is\nreturned along with the response.\n"}, "404": {"description": "An HTTP 404 error is returned if no Pregel job with the specified execution number\nis found or the execution number is invalid.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"": {"$ref": "#/components/schemas/get_api_control_pregel", "description": ""}}, "required": [""]}}}}}, "tags": ["Pregel"]}, "delete": {"description": "Cancel an execution which is still running, and discard any intermediate\nresults. This immediately frees all memory taken up by the execution, and\nmakes you lose all intermediary data.\nYou might get inconsistent results if you requested to store the results and\nthen cancel an execution when it is already in its `\"storing\"` state (or\n`\"done\"` state in versions prior to 3.7.1). The data is written multi-threaded\ninto all collection shards at once. This means there are multiple transactions\nsimultaneously. A transaction might already be committed when you cancel the\nexecution job. Therefore, you might see some updated documents, while other\ndocuments have no or stale results from a previous execution.\n", "parameters": [{"name": "id", "schema": {"type": "number"}, "required": true, "description": "Pregel execution identifier.\n", "in": "path"}], "responses": {"200": {"description": "HTTP 200 is returned if the job execution ID was valid.\n"}, "404": {"description": "An HTTP 404 error is returned if no Pregel job with the specified execution number\nis found or the execution number is invalid.\n"}}, "tags": ["Pregel"]}}, "/_admin/server/jwt": {"get": {"description": "Get information about the currently loaded secrets.\nTo utilize the API a superuser JWT token is necessary, otherwise the response\nwill be _HTTP 403 Forbidden_.\n", "operationId": " handleJWT:get", "responses": {"200": {"description": ""}, "403": {"description": "if the request was not authenticated as a user with sufficient rights\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*false* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code - 200 in this case\n"}, "result": {"$ref": "#/components/schemas/jwt_secret_struct", "description": "The result object.\n"}}, "required": ["error", "code", "result"]}}}}}, "tags": ["Administration"]}, "post": {"description": "Sending a request without payload to this endpoint reloads the JWT secret(s)\nfrom disk. Only the files specified via the arangod startup option\n`--server.jwt-secret-keyfile` or `--server.jwt-secret-folder` are used.\nIt is not possible to change the locations where files are loaded from\nwithout restarting the process.\nTo utilize the API a superuser JWT token is necessary, otherwise the response\nwill be _HTTP 403 Forbidden_.\n", "operationId": " handleJWT:post", "responses": {"200": {"description": ""}, "403": {"description": "if the request was not authenticated as a user with sufficient rights\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*false* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code - 200 in this case\n"}, "result": {"$ref": "#/components/schemas/jwt_secret_struct", "description": "The result object.\n"}}, "required": ["error", "code", "result"]}}}}}, "tags": ["Administration"]}}, "/_api/cluster/endpoints": {"get": {"description": "Returns an object with an attribute `endpoints`, which contains an\narray of objects, which each have the attribute `endpoint`, whose value\nis a string with the endpoint description. There is an entry for each\nCoordinator in the cluster. This method only works on Coordinators in\ncluster mode. In case of an error the `error` attribute is set to\n`true`.\n", "operationId": " handleCommandEndpoints:listClusterEndpoints", "responses": {"200": {"description": "is returned when everything went well.\n"}, "501": {"description": "server is not a Coordinator or method was not GET.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*true* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code - 200\n"}, "endpoints": {"$ref": "#/components/schemas/cluster_endpoints_struct", "items": {"type": "cluster_endpoints_struct"}, "description": "A list of active cluster endpoints.\n"}}, "required": ["error", "code", "endpoints"]}}}}}, "tags": ["Administration"]}}, "/_api/endpoint": {"get": {"description": "Returns an array of all configured endpoints the server is listening on.\nThe result is a JSON array of JSON objects, each with `\"entrypoint\"` as\nthe only attribute, and with the value being a string describing the\nendpoint.\n**Note**: retrieving the array of all endpoints is allowed in the system database\nonly. Calling this action in any other database will make the server return\nan error.\n", "operationId": " retrieveEndpoints", "responses": {"200": {"description": "is returned when the array of endpoints can be determined successfully.\n"}, "400": {"description": "is returned if the action is not carried out in the system database.\n"}, "405": {"description": "The server will respond with *HTTP 405* if an unsupported HTTP method is used.\n"}}, "tags": ["Administration"]}}, "/_admin/backup/create": {"post": {"description": "Creates a consistent backup \"as soon as possible\", very much\nlike a snapshot in time, with a given label. The ambiguity in the\nphrase \"as soon as possible\" refers to the next window during which a\nglobal write lock across all databases can be obtained in order to\nguarantee consistency. Note that the backup at first resides on the\nsame machine and hard drive as the original data. Make sure to upload\nit to a remote site for an actual backup.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"label": {"type": "string", "description": "The label for this backup. The label is used together with a\ntimestamp string create a unique backup identifier, `<timestamp>_<label>`.\nIf no label is specified, the empty string is assumed and a default\nUUID is created for this part of the ID.\n"}, "timeout": {"type": "number", "format": "double", "description": "The time in seconds that the operation tries to get a consistent\nsnapshot. The default is 120 seconds.\n"}, "allowInconsistent": {"type": "boolean", "description": "If this flag is set to `true` and no global transaction lock can be\nacquired within the given timeout, a possibly inconsistent backup\nis taken. The default for this flag is `false` and in this case\na timeout results in an HTTP 408 error.\n"}, "force": {"type": "boolean", "description": "If this flag is set to `true` and no global transaction lock can be acquired\nwithin the given timeout, all running transactions are forcefully aborted to\nensure that a consistent backup can be created. This does not include \nJavaScript transactions. It waits for the transactions to be aborted at most \n`timeout` seconds. Thus using `force` the request timeout is doubled.\nTo abort transactions is almost certainly not what you want for your application. \nIn the presence of intermediate commits it can even destroy the atomicity of your\ntransactions. Use at your own risk, and only if you need a consistent backup at \nall costs. The default and recommended value is `false`. If both \n`allowInconsistent` and `force` are set to `true`, then the latter takes \nprecedence and transactions are aborted. This is only available in the cluster.\n\n"}}, "required": []}}}}, "responses": {"201": {"description": "If all is well, code 201 is returned.\n"}, "400": {"description": "If the create command is invoked with bad parameters or any HTTP\nmethod other than `POST`, then an *HTTP 400* is returned. The specifics\nare detailed in the returned error document.\n"}, "408": {"description": "If the operation cannot obtain a global transaction lock\nwithin the timeout, then an *HTTP 408* is returned.\n"}}, "tags": ["BackupRestore"]}}, "/_admin/backup/restore": {"post": {"description": "Restores a consistent backup from a\nsnapshot in time, with a given id. The backup snapshot must reside on\nthe ArangoDB service locally.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "The id of the backup to restore from.\n"}}, "required": ["id"]}}}}, "responses": {"200": {"description": "Is returned if the backup could be restored. Note that there is an\ninevitable discrepancy between the single server and the cluster. In a\nsingle server, the request returns successfully, but the restore is\nonly executed afterwards. In the cluster, the request only returns when\nthe restore operation has been completed successfully. The cluster\nbehaviour is obviously the desired one, but in a single instance, one\ncannot keep a connection open across a restart.\n"}, "400": {"description": "If the restore command is invoked with bad parameters or any HTTP\nmethod other than `POST`, then an *HTTP 400* is returned. The specifics\nare detailed in the returned error document.\n"}}, "tags": ["BackupRestore"]}}, "/_admin/backup/delete": {"post": {"description": "Delete a specific local backup identified by the given `id`.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "The identifier for this backup.\n"}}, "required": ["id"]}}}}, "responses": {"200": {"description": "If all is well, this code 200 is returned.\n"}, "400": {"description": "If the delete command is invoked with bad parameters or any HTTP\nmethod other than `POST`, then an *HTTP 400* is returned.\n"}, "404": {"description": "If a backup corresponding to the identifier `id` cannot be found.\n"}}, "tags": ["BackupRestore"]}}, "/_admin/backup/list": {"post": {"description": "Lists all locally found backups.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "The body can either be empty (in which case all available backups are\nlisted), or it can be an object with an attribute `id`, which\nis a string. In the latter case the returned list\nis restricted to the backup with the given id.\n"}}, "required": []}}}}, "responses": {"200": {"description": "If all is well, code 200 is returned.\n"}, "400": {"description": "If the list command is invoked with bad parameters, then an *HTTP 400*\nis returned.\n"}, "404": {"description": "If an `id` or a list of ids was given and the given ids were not found\nas identifiers of a backup, an *HTTP 404 NOT FOUND* is returned.\n"}, "405": {"description": "If the list command is invoked with any HTTP\nmethod other than `POST`, then an *HTTP 405 METHOD NOT ALLOWED* is returned.\n"}}, "tags": ["BackupRestore"]}}, "/_admin/backup/upload": {"post": {"description": "Upload a specific local backup to a remote repository, or query\nprogress on a previously scheduled upload operation, or abort\na running upload operation.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "The identifier for this backup. This is required when an upload\noperation is scheduled. In this case leave out the `uploadId`\nattribute.\n"}, "remoteRepository": {"type": "string", "description": "URL of remote repository. This is required when an upload operation is\nscheduled. In this case leave out the `uploadId` attribute. Provided repository\nURLs are normalized and validated as follows: One single colon must appear\nseparating the configuration section name and the path. The URL prefix up to\nthe colon must exist as a key in the config object below. No slashes must\nappear before the colon. Multiple back to back slashes are collapsed to one, as\n`..` and `.` are applied accordingly. Local repositories must be absolute\npaths and must begin with a `/`. Trailing `/` are removed.\n"}, "config": {"type": "object", "format": "object", "description": "Configuration of remote repository. This is required when an upload\noperation is scheduled. In this case leave out the `uploadId`\nattribute. See the description of the _arangobackup_ program in the manual\nfor a description of the `config` object.\n"}, "uploadId": {"type": "string", "description": "Upload ID to specify for which upload operation progress is queried or\nthe upload operation to abort.\nIf you specify this, leave out all the above body parameters.\n"}, "abort": {"type": "boolean", "description": "Set this to `true` if a running upload operation should be aborted. In\nthis case, the only other body parameter which is needed is `uploadId`.\n"}}, "required": []}}}}, "responses": {"200": {"description": "If all is well, code 200 is returned if progress is inquired or the\noperation is aborted.\n"}, "202": {"description": "If all is well, code 202 is returned if a new operation is scheduled.\n"}, "400": {"description": "If the upload command is invoced with bad parameters or any HTTP\nmethod other than `POST`, then an *HTTP 400* is returned.\n"}, "401": {"description": "If the authentication to the rempote repository fails, then an *HTTP\n400* is returned.\n"}, "404": {"description": "If a backup corresponding to the identifier `id`  cannot be found, or if\nthere is no known upload operation with the given `uploadId`.\n"}}, "tags": ["BackupRestore"]}}, "/_admin/backup/download": {"post": {"description": "Download a specific local backup from a remote repository, or query\nprogress on a previously scheduled download operation, or abort\na running download operation.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "The identifier for this backup. This is required when a download\noperation is scheduled. In this case leave out the `downloadId`\nattribute.\n"}, "remoteRepository": {"type": "string", "description": "URL of remote repository. This is required when a download operation is\nscheduled. In this case leave out the `downloadId` attribute. Provided\nrepository URLs are normalized and validated as follows: One single colon must\nappear separating the configuration section name and the path. The URL prefix\nup to the colon must exist as a key in the config object below. No slashes must\nappear before the colon. Multiple back to back slashes are collapsed to one, as\n`..` and `.` are applied accordingly. Local repositories must be absolute paths\nand must begin with a `/`. Trailing `/` are removed.\n"}, "config": {"type": "object", "format": "object", "description": "Configuration of remote repository. This is required when a download\noperation is scheduled. In this case leave out the `downloadId`\nattribute. See the description of the _arangobackup_ program in the manual\nfor a description of the `config` object.\n"}, "downloadId": {"type": "string", "description": "Download ID to specify for which download operation progress is queried, or\nthe download operation to abort.\nIf you specify this, leave out all the above body parameters.\n"}, "abort": {"type": "boolean", "description": "Set this to `true` if a running download operation should be aborted. In\nthis case, the only other body parameter which is needed is `downloadId`.\n"}}, "required": ["remoteRepository", "config"]}}}}, "responses": {"200": {"description": "If all is well, code 200 is returned if progress is inquired or the\noperation is aborted.\n"}, "202": {"description": "If all is well, code 202 is returned if a new operation is scheduled.\n"}, "400": {"description": "If the download command is invoked with bad parameters or any HTTP\nmethod other than `POST`, then an *HTTP 400* is returned.\n"}, "401": {"description": "If the authentication to the rempote repository fails, then an *HTTP\n401* is returned.\n"}, "404": {"description": "If a backup corresponding to the identifier `id`  cannot be found, or if\nthere is no known download operation with the given `downloadId`.\n"}}, "tags": ["BackupRestore"]}}, "/_api/version": {"get": {"description": "Returns the server name and version number. The response is a JSON object\nwith the following attributes:\n", "operationId": " RestVersionHandler", "parameters": [{"name": "details", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, the response will contain a *details* attribute with\nadditional information about included components and their versions. The\nattribute names and internals of the *details* object may vary depending on\nplatform and ArangoDB version.\n", "in": "query"}], "responses": {"200": {"description": "is returned in all cases.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"server": {"type": "string", "description": "will always contain *arango*\n"}, "version": {"type": "string", "description": "the server version string. The string has the format\n\"*major*.*minor*.*sub*\". *major* and *minor* will be numeric, and *sub*\nmay contain a number or a textual version.\n"}, "details": {"$ref": "#/components/schemas/version_details_struct", "description": "an optional JSON object with additional details. This is\nreturned only if the *details* query parameter is set to *true* in the\nrequest.\n"}}, "required": ["server", "version"]}}}}}, "tags": ["Administration"]}}, "/_api/engine": {"get": {"description": "Returns the storage engine the server is configured to use.\nThe response is a JSON object with the following attributes:\n", "operationId": " RestEngineHandler", "responses": {"200": {"description": "is returned in all cases.\n"}}, "tags": ["Administration"]}}, "/_admin/time": {"get": {"description": "The call returns an object with the attribute *time*. This contains the\ncurrent system time as a Unix timestamp with microsecond precision.\n", "operationId": " RestTimeHandler", "responses": {"200": {"description": "Time was returned successfully.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*false* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code\n"}}, "required": ["error", "code"]}}}}}, "tags": ["Administration"]}}, "/_admin/echo": {"post": {"description": "The call returns an object with the servers request information\n", "operationId": " adminEchoJs", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"body": {"type": "object", "description": "The body can be any type and is simply forwarded.\n"}}, "required": ["body"]}}}}, "responses": {"200": {"description": "Echo was returned successfully.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"authorized": {"type": "boolean", "description": "Whether the session is authorized\n"}, "user": {"type": "string", "description": "The name of the current user that sent this request\n"}, "isAdminUser": {"type": "boolean", "description": "Whether the current user is an administrator\n"}, "database": {"type": "string", "description": "The name of the database this request was executed on\n"}, "url": {"type": "string", "description": "The raw request URL\n"}, "protocol": {"type": "string", "description": "The transport protocol, one of `\"http\"`, `\"https\"`, `\"velocystream\"`\n"}, "portType": {"type": "string", "description": "The type of the socket, one of `\"tcp/ip\"`, `\"unix\"`, `\"unknown\"`\n"}, "server": {"$ref": "#/components/schemas/admin_echo_server_struct", "description": "Attributes of the server connection\n"}, "client": {"$ref": "#/components/schemas/admin_echo_client_struct", "description": "Attributes of the client connection\n"}, "internals": {"type": "object", "description": "Contents of the server internals struct\n"}, "prefix": {"type": "object", "description": "The prefix of the database\n"}, "headers": {"type": "object", "description": "The list of the HTTP headers you sent\n"}, "requestType": {"type": "string", "description": "The HTTP method that was used for the request (`\"POST\"`). The endpoint can be\nqueried using other verbs, too (`\"GET\"`, `\"PUT\"`, `\"PATCH\"`, `\"DELETE\"`).\n"}, "requestBody": {"type": "string", "description": "Stringified version of the request body you sent\n"}, "rawRequestBody": {"type": "object", "description": "The sent payload as a JSON-encoded Buffer object\n"}, "parameters": {"type": "object", "description": "An object containing the query parameters\n"}, "cookies": {"type": "object", "description": "A list of the cookies you sent\n"}, "suffix": {"type": "array", "items": {"type": "string"}, "description": "A list of the decoded URL path suffixes. You can query the endpoint with\narbitrary suffixes, e.g. `/_admin/echo/foo/123`\n"}, "rawSuffix": {"type": "array", "items": {"type": "string"}, "description": "A list of the percent-encoded URL path suffixes\n"}}, "required": ["authorized", "user", "isAdminUser", "database", "url", "protocol", "portType", "server", "client", "internals", "prefix", "headers", "requestType", "requestBody", "rawRequestBody", "parameters", "cookies", "suffix", "rawSuffix"]}}}}}, "tags": ["Administration"]}}, "/_admin/database/target-version": {"get": {"description": "Returns the database version that this server requires.\nThe version is returned in the *version* attribute of the result.\n", "operationId": " RestAdminDatabaseHandler", "responses": {"200": {"description": "Is returned in all cases.\n"}}, "tags": ["Administration"]}}, "/_admin/shutdown": {"delete": {"description": "This call initiates a clean shutdown sequence. Requires administrative privileges.\n", "operationId": " RestShutdownHandler", "parameters": [{"name": "soft", "schema": {"type": "boolean"}, "required": false, "description": "<small>Introduced in v3.7.12, v3.8.1, v3.9.0</small>\nIf set to `true`, this initiates a soft shutdown. This is only available\non Coordinators. When issued, the Coordinator tracks a number of ongoing\noperations, waits until all have finished, and then shuts itself down\nnormally. It will still accept new operations.\nThis feature can be used to make restart operations of Coordinators less\nintrusive for clients. It is designed for setups with a load balancer in front\nof Coordinators. Remove the designated Coordinator from the load balancer before\nissuing the soft-shutdown. The remaining Coordinators will internally forward\nrequests that need to be handled by the designated Coordinator. All other\nrequests will be handled by the remaining Coordinators, reducing the designated\nCoordinator's load.\nThe following types of operations are tracked\n - AQL cursors (in particular streaming cursors)\n - Transactions (in particular stream transactions)\n - Pregel runs (conducted by this Coordinator)\n - Ongoing asynchronous requests (using the `x-arango-async store` HTTP header\n - Finished asynchronous requests, whose result has not yet been\n   collected\n - Queued low priority requests (most normal requests)\n - Ongoing low priority requests\n", "in": "query"}], "responses": {"200": {"description": "is returned in all cases, `OK` will be returned in the result buffer on success.\n"}}, "tags": ["Administration"]}, "get": {"description": "<small>Introduced in: v3.7.12, v3.8.1, v3.9.0</small>\nThis call reports progress about a soft Coordinator shutdown (see\ndocumentation of `DELETE /_admin/shutdown?soft=true`).\nIn this case, the following types of operations are tracked:\n - AQL cursors (in particular streaming cursors)\n - Transactions (in particular stream transactions)\n - Pregel runs (conducted by this Coordinator)\n - Ongoing asynchronous requests (using the `x-arango-async: store` HTTP header\n - Finished asynchronous requests, whose result has not yet been\n   collected\n - Queued low priority requests (most normal requests)\n - Ongoing low priority requests\nThis API is only available on Coordinators.\n", "operationId": " RestGetShutdownHandler", "responses": {"200": {"description": "The response indicates the fact that a soft shutdown is ongoing and the\nnumber of active operations of the various types. Once all numbers have gone\nto 0, the flag `allClear` is set and the Coordinator shuts down automatically.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"softShutdownOngoing": {"type": "boolean", "description": "Whether a soft shutdown of the Coordinator is in progress.\n"}, "AQLcursors": {"type": "number", "description": "Number of AQL cursors that are still active.\n"}, "transactions": {"type": "number", "description": "Number of ongoing transactions.\n"}, "pendingJobs": {"type": "number", "description": "Number of ongoing asynchronous requests.\n"}, "doneJobs": {"type": "number", "description": "Number of finished asynchronous requests, whose result has not yet been collected.\n"}, "pregelConductors": {"type": "number", "description": "Number of ongoing Pregel jobs.\n"}, "lowPrioOngoingRequests": {"type": "number", "description": "Number of queued low priority requests.\n"}, "lowPrioQueuedRequests": {"type": "number", "description": "Number of ongoing low priority requests.\n"}}, "required": ["softShutdownOngoing", "AQLcursors", "transactions", "pendingJobs", "doneJobs", "pregelConductors", "lowPrioOngoingRequests", "lowPrioQueuedRequests"]}}}}}, "tags": ["Administration"]}}, "/_admin/execute": {"post": {"description": "Executes the javascript code in the body on the server as the body\nof a function with no arguments. If you have a *return* statement\nthen the return value you produce will be returned as content type\n*application/json*. If the parameter *returnAsJSON* is set to\n*true*, the result will be a JSON object describing the return value\ndirectly, otherwise a string produced by JSON.stringify will be\nreturned.\nNote that this API endpoint will only be present if the server was\nstarted with the option `--javascript.allow-admin-execute true`.\nThe default value of this option is `false`, which disables the execution of\nuser-defined code and disables this API endpoint entirely.\nThis is also the recommended setting for production.\n", "operationId": " RestAdminExecuteHandler", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"body": {"type": "string", "description": "The body to be executed.\n"}}, "required": ["body"]}}}}, "responses": {"200": {"description": "is returned when everything went well, or if a timeout occurred. In the\nlatter case a body of type application/json indicating the timeout\nis returned. depending on *returnAsJSON* this is a json object or a plain string.\n"}, "403": {"description": "is returned if ArangoDB is not running in cluster mode.\n"}, "404": {"description": "is returned if ArangoDB was not compiled for cluster operation.\n"}}, "tags": ["Administration"]}}, "/_admin/status": {"get": {"description": "Returns status information about the server.\n", "operationId": " RestStatusHandler", "responses": {"200": {"description": "Status information was returned successfully.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"server": {"type": "string", "description": "Always `\"arango\"`.\n"}, "license": {"type": "string", "description": "ArangoDB Edition, either `\"community\"` or `\"enterprise\"`.\n"}, "version": {"type": "string", "description": "The server version as a string.\n"}, "mode": {"type": "string", "description": "Either `\"server\"` or `\"console\"`. **Deprecated**, use `operationMode` instead.\n"}, "operationMode": {"type": "string", "description": "Either `\"server\"` or `\"console\"`.\n"}, "foxxApi": {"type": "boolean", "description": "Whether the Foxx API is enabled.\n"}, "host": {"type": "string", "description": "A host identifier defined by the `HOST` or `NODE_NAME` environment variable,\nor a fallback value using a machine identifier or the cluster/Agency address.\n"}, "hostname": {"type": "string", "description": "A hostname defined by the `HOSTNAME` environment variable.\n"}, "pid": {"type": "number", "description": "The process ID of _arangod_.\n"}, "serverInfo": {"$ref": "#/components/schemas/get_admin_status_server_info", "description": "Information about the server status.\n"}, "agency": {"$ref": "#/components/schemas/get_admin_status_agency", "description": "Information about the Agency.\n*Cluster only* (Coordinators and DB-Servers).\n"}, "coordinator": {"$ref": "#/components/schemas/get_admin_status_coordinator", "description": "Information about the Coordinators.\n*Cluster only* (Coordinators)\n"}, "agent": {"$ref": "#/components/schemas/get_admin_status_agent", "description": "Information about the Agents.\n*Cluster only* (Agents)\n"}}, "required": ["server", "license", "version", "mode", "operationMode", "foxxApi", "host", "pid", "serverInfo"]}}}}}, "tags": ["Administration"]}}, "/_admin/license": {"get": {"description": "View the license information and status of an Enterprise Edition instance.\nCan be called on single servers, Coordinators, and DB-Servers.\n", "operationId": " getLicense", "responses": {"200": {"description": "", "content": {"application/json": {"schema": {"type": "object", "properties": {"features": {"$ref": "#/components/schemas/license_features", "description": ""}, "license": {"type": "string", "description": "The encrypted license key in Base64 encoding.\n"}, "version": {"type": "number", "description": "The license version number.\n"}}, "required": ["features", "license", "version"]}}}}}, "tags": ["Administration"]}, "put": {"description": "Set a new license for an Enterprise Edition instance.\nCan be called on single servers, Coordinators, and DB-Servers.\n", "operationId": " putLicense", "parameters": [{"name": "force", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to change the license even if it expires sooner than the current one.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"license": {"type": "string", "description": "The body has to contain the Base64 encoded string wrapped in double quotes.\n"}}, "required": ["license"]}}}}, "responses": {"400": {"description": "If the license expires earlier than the previously installed one.\n"}, "201": {"description": "License successfully deployed.\n"}}, "tags": ["Administration"]}}, "/_api/job/{job-id}": {"put": {"description": "Returns the result of an async job identified by job-id. If the async job\nresult is present on the server, the result will be removed from the list of\nresult. That means this method can be called for each job-id once.\nThe method will return the original job result's headers and body, plus the\nadditional HTTP header x-arango-async-job-id. If this header is present,\nthen\nthe job was found and the response contains the original job's result. If\nthe header is not present, the job was not found and the response contains\nstatus information from the job manager.\n", "operationId": " getJobResult", "parameters": [{"name": "job-id", "schema": {"type": "string"}, "required": true, "description": "The async job id.\n", "in": "path"}], "responses": {"204": {"description": "is returned if the job requested via job-id is still in the queue of pending\n(or not yet finished) jobs. In this case, no x-arango-async-id HTTP header\nwill be returned.\n"}, "400": {"description": "is returned if no job-id was specified in the request. In this case,\nno x-arango-async-id HTTP header will be returned.\n"}, "404": {"description": "is returned if the job was not found or already deleted or fetched from\nthe job result list. In this case, no x-arango-async-id HTTP header will\nbe returned.\n"}}, "tags": ["job"]}, "get": {"description": "Returns the processing status of the specified job. The processing status\ncan be\ndetermined by peeking into the HTTP response code of the response.\n", "operationId": " getJobById", "parameters": [{"name": "job-id", "schema": {"type": "string"}, "required": true, "description": "The async job id.\n", "in": "path"}], "responses": {"200": {"description": "is returned if the job requested via job-id has been executed\nand its result is ready to fetch.\n"}, "204": {"description": "is returned if the job requested via job-id is still in the queue of pending\n(or not yet finished) jobs.\n"}, "404": {"description": "is returned if the job was not found or already deleted or fetched from the\njob result list.\n"}}, "tags": ["job"]}}, "/_api/job/{job-id}/cancel": {"put": {"description": "Cancels the currently running job identified by job-id. Note that it still\nmight take some time to actually cancel the running async job.\n", "operationId": " putJobMethod:cancel", "parameters": [{"name": "job-id", "schema": {"type": "string"}, "required": true, "description": "The async job id.\n", "in": "path"}], "responses": {"200": {"description": "cancel has been initiated.\n"}, "400": {"description": "is returned if no job-id was specified in the request. In this case,\nno x-arango-async-id HTTP header will be returned.\n"}, "404": {"description": "is returned if the job was not found or already deleted or fetched from\nthe job result list. In this case, no x-arango-async-id HTTP header will\nbe returned.\n"}}, "tags": ["job"]}}, "/_api/job/{type}#by-type": {"delete": {"description": "Deletes either all job results, expired job results, or the result of a\nspecific job.\nClients can use this method to perform an eventual garbage collection of job\nresults.\n", "operationId": " deleteJob:byType", "parameters": [{"name": "type", "schema": {"type": "string"}, "required": true, "description": "The type of jobs to delete. type can be\n* *all* Deletes all jobs results. Currently executing or queued async\n  jobs will not be stopped by this call.\n* *expired* Deletes expired results. To determine the expiration status of a\n  result, pass the stamp query parameter. stamp needs to be a UNIX timestamp,\n  and all async job results created at a lower timestamp will be deleted.\n* *an actual job-id* In this case, the call will remove the result of the\n  specified async job. If the job is currently executing or queued, it will\n  not be aborted.\n", "in": "path"}, {"name": "stamp", "schema": {"type": "number"}, "required": false, "description": "A UNIX timestamp specifying the expiration threshold when type is expired.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the deletion operation was carried out successfully.\nThis code will also be returned if no results were deleted.\n"}, "400": {"description": "is returned if type is not specified or has an invalid value.\n"}, "404": {"description": "is returned if type is a job-id but no async job with the specified id was\nfound.\n"}}, "tags": ["job"]}, "get": {"description": "Returns the list of ids of async jobs with a specific status (either done or\npending).\nThe list can be used by the client to get an overview of the job system\nstatus and\nto retrieve completed job results later.\n", "operationId": " getJob", "parameters": [{"name": "type", "schema": {"type": "string"}, "required": true, "description": "The type of jobs to return. The type can be either done or pending. Setting\nthe type to done will make the method return the ids of already completed\nasync\njobs for which results can be fetched. Setting the type to pending will\nreturn\nthe ids of not yet finished async jobs.\n", "in": "path"}, {"name": "count", "schema": {"type": "number"}, "required": false, "description": "The maximum number of ids to return per call. If not specified, a\nserver-defined maximum value will be used.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the list can be compiled successfully. Note the list might\nbe empty.\n"}, "400": {"description": "is returned if type is not specified or has an invalid value.\n"}}, "tags": ["job"]}}, "/_api/query-cache/entries": {"get": {"description": "Returns an array containing the AQL query results currently stored in the query results\ncache of the selected database. Each result is a JSON object with the following attributes:\n- *hash*: the query result's hash\n- *query*: the query string\n- *bindVars*: the query's bind parameters. this attribute is only shown if tracking for\n  bind variables was enabled at server start\n- *size*: the size of the query result and bind parameters, in bytes\n- *results*: number of documents/rows in the query result\n- *started*: the date and time when the query was stored in the cache\n- *hits*: number of times the result was served from the cache (can be\n  *0* for queries that were only stored in the cache but were never accessed\n  again afterwards)\n- *runTime*: the query's run time\n- *dataSources*: an array of collections/Views the query was using\n", "operationId": " readQueries", "responses": {"200": {"description": "Is returned when the list of results can be retrieved successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\n"}}, "tags": ["AQL"]}}, "/_api/query-cache": {"delete": {"description": "clears the query results cache for the current database\n", "operationId": " clearCache", "responses": {"200": {"description": "The server will respond with *HTTP 200* when the cache was cleared\nsuccessfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request.\n"}}, "tags": ["AQL"]}}, "/_api/query-cache/properties": {"get": {"description": "Returns the global AQL query results cache configuration. The configuration is a\nJSON object with the following properties:\n- *mode*: the mode the AQL query results cache operates in. The mode is one of the following\n  values: *off*, *on* or *demand*.\n- *maxResults*: the maximum number of query results that will be stored per database-specific\n  cache.\n- *maxResultsSize*: the maximum cumulated size of query results that will be stored per\n  database-specific cache.\n- *maxEntrySize*: the maximum individual result size of queries that will be stored per\n  database-specific cache.\n- *includeSystem*: whether or not results of queries that involve system collections will be\n  stored in the query results cache.\n", "operationId": " readProperties", "responses": {"200": {"description": "Is returned if the properties can be retrieved successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\n"}}, "tags": ["AQL"]}, "put": {"description": "After the properties have been changed, the current set of properties will\nbe returned in the HTTP response.\nNote: changing the properties may invalidate all results in the cache.\nThe global properties for AQL query cache.\nThe properties need to be passed in the attribute *properties* in the body\nof the HTTP request. *properties* needs to be a JSON object with the following\nproperties:\n", "operationId": " replaceProperties:QueryCache", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"mode": {"type": "string", "description": " the mode the AQL query cache should operate in. Possible values are *off*, *on* or *demand*.\n"}, "maxResults": {"type": "integer", "format": "int64", "description": "the maximum number of query results that will be stored per database-specific cache.\n"}, "maxResultsSize": {"type": "integer", "format": "int64", "description": "the maximum cumulated size of query results that will be stored per database-specific cache.\n"}, "maxEntrySize": {"type": "integer", "format": "int64", "description": "the maximum individual size of query results that will be stored per database-specific cache.\n"}, "includeSystem": {"type": "boolean", "description": "whether or not to store results of queries that involve system collections.\n"}}, "required": []}}}}, "responses": {"200": {"description": "Is returned if the properties were changed successfully.\n"}, "400": {"description": "The server will respond with *HTTP 400* in case of a malformed request,\n"}}, "tags": ["AQL"]}}, "/_api/tasks/": {"get": {"description": "fetches all existing tasks on the server\n", "operationId": " getTasks", "responses": {"200": {"description": "The list of tasks\n"}}, "tags": ["Administration"]}}, "/_api/tasks/{id}": {"get": {"description": "fetches one existing task on the server specified by *id*\n", "operationId": " getTask", "parameters": [{"name": "id", "schema": {"type": "string"}, "required": true, "description": "The id of the task to fetch.\n", "in": "path"}], "responses": {"200": {"description": "The requested task\n"}}, "tags": ["Administration"]}, "put": {"description": "registers a new task with the specified id\n", "operationId": " registerTask:byId", "parameters": [{"name": "id", "schema": {"type": "string"}, "required": true, "description": "The id of the task to create\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the task\n"}, "command": {"type": "string", "description": "The JavaScript code to be executed\n"}, "params": {"type": "string", "description": "The parameters to be passed into command\n"}, "period": {"type": "integer", "format": "int64", "description": "number of seconds between the executions\n"}, "offset": {"type": "integer", "format": "int64", "description": "Number of seconds initial delay\n"}}, "required": ["name", "command", "params"]}}}}, "responses": {"400": {"description": "If the task *id* already exists or the rest body is not accurate, *HTTP 400* is returned.\n"}}, "tags": ["Administration"]}, "delete": {"description": "Deletes the task identified by *id* on the server.\n", "operationId": " deleteTask", "parameters": [{"name": "id", "schema": {"type": "string"}, "required": true, "description": "The id of the task to delete.\n", "in": "path"}], "responses": {"200": {"description": "If the task was deleted, *HTTP 200* is returned.\n"}, "404": {"description": "If the task *id* is unknown, then an *HTTP 404* is returned.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"code": {"type": "number", "description": "The status code, 404 in this case.\n"}, "error": {"type": "boolean", "description": "*true* in this case\n"}}, "required": ["code", "error"]}}}}}, "tags": ["Administration"]}}, "/_api/tasks": {"post": {"description": "creates a new task with a generated id\n", "operationId": " registerTask", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the task\n"}, "command": {"type": "string", "description": "The JavaScript code to be executed\n"}, "params": {"type": "string", "description": "The parameters to be passed into command\n"}, "period": {"type": "integer", "format": "int64", "description": "number of seconds between the executions\n"}, "offset": {"type": "integer", "format": "int64", "description": "Number of seconds initial delay\n"}}, "required": ["name", "command", "params"]}}}}, "responses": {"200": {"description": "The task was registered\n"}, "400": {"description": "If the post body is not accurate, a *HTTP 400* is returned.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "A string identifying the task\n"}, "created": {"type": "number", "format": "float", "description": "The timestamp when this task was created\n"}, "type": {"type": "string", "description": "What type of task is this [ `periodic`, `timed`]\n  - periodic are tasks that repeat periodically\n  - timed are tasks that execute once at a specific time\n"}, "period": {"type": "number", "description": "this task should run each `period` seconds\n"}, "offset": {"type": "number", "format": "float", "description": "time offset in seconds from the created timestamp\n"}, "command": {"type": "string", "description": "the javascript function for this task\n"}, "database": {"type": "string", "description": "the database this task belongs to\n"}, "code": {"type": "number", "description": "The status code, 200 in this case.\n"}, "error": {"type": "boolean", "description": "*false* in this case\n"}}, "required": ["id", "created", "type", "period", "offset", "command", "database", "code", "error"]}}}}}, "tags": ["Administration"]}}, "/_api/aqlfunction": {"post": {"description": "In case of success, HTTP 200 is returned.\nIf the function isn't valid etc. HTTP 400 including a detailed error message will be returned.\n", "operationId": " RestAqlUserFunctionsHandler:create", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "the fully qualified name of the user functions.\n"}, "code": {"type": "string", "description": "a string representation of the function body.\n"}, "isDeterministic": {"type": "boolean", "description": "an optional boolean value to indicate whether the function\nresults are fully deterministic (function return value solely depends on\nthe input value and return value is the same for repeated calls with same\ninput). The *isDeterministic* attribute is currently not used but may be\nused later for optimizations.\n"}}, "required": ["name", "code"]}}}}, "responses": {"200": {"description": "If the function already existed and was replaced by the\ncall, the server will respond with *HTTP 200*.\n"}, "201": {"description": "If the function can be registered by the server, the server will respond with\n*HTTP 201*.\n"}, "400": {"description": "If the JSON representation is malformed or mandatory data is missing from the\nrequest, the server will respond with *HTTP 400*.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*true* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code\n"}, "isNewlyCreated": {"type": "boolean", "description": "boolean flag to indicate whether the function was newly created (*true* in this case)\n"}, "errorNum": {"type": "integer", "format": "int64", "description": "the server error number\n"}}, "required": ["error", "code", "isNewlyCreated", "errorNum"]}}}}}, "tags": ["AQL"]}, "get": {"description": "Returns all registered AQL user functions.\nThe call will return a JSON array with status codes and all user functions found under *result*.\n", "operationId": " RestAqlUserFunctionsHandler:List", "parameters": [{"name": "namespace", "schema": {"type": "string"}, "required": false, "description": "Returns all registered AQL user functions from namespace *namespace* under *result*.\n", "in": "query"}], "responses": {"200": {"description": "on success *HTTP 200* is returned.\n"}, "400": {"description": "If the user function name is malformed, the server will respond with *HTTP 400*.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*true* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code\n"}, "result": {"$ref": "#/components/schemas/aql_userfunction_struct", "items": {"type": "aql_userfunction_struct"}, "description": "All functions, or the ones matching the *namespace* parameter\n"}, "errorNum": {"type": "integer", "format": "int64", "description": "the server error number\n"}}, "required": ["error", "code", "result", "errorNum"]}}}}}, "tags": ["AQL"]}}, "/_api/aqlfunction/{name}": {"delete": {"description": "Removes an existing AQL user function or function group, identified by *name*.\n", "operationId": " RestAqlUserFunctionsHandler:Remove", "parameters": [{"name": "name", "schema": {"type": "string"}, "required": true, "description": "the name of the AQL user function.\n", "in": "path"}, {"name": "group", "schema": {"type": "string"}, "required": false, "description": "- *true* The function name provided in *name* is treated as\n  a namespace prefix, and all functions in the specified namespace will be deleted.\n  The returned number of deleted functions may become 0 if none matches the string.\n- *false* The function name provided in *name* must be fully\n  qualified, including any namespaces. If none matches the *name*, HTTP 404 is returned.\n", "in": "query"}], "responses": {"200": {"description": "If the function can be removed by the server, the server will respond with\n*HTTP 200*.\n"}, "400": {"description": "If the user function name is malformed, the server will respond with *HTTP 400*.\n"}, "404": {"description": "If the specified user user function does not exist, the server will respond with *HTTP 404*.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*true* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code\n"}, "deletedCount": {"type": "integer", "format": "int64", "description": "The number of deleted user functions, always `1` when `group` is set to *false*.\nAny number `>= 0` when `group` is set to *true*\n"}, "errorNum": {"type": "integer", "format": "int64", "description": "the server error number\n"}, "errorMessage": {"type": "string", "description": "a descriptive error message\n"}}, "required": ["error", "code", "deletedCount", "errorNum", "errorMessage"]}}}}}, "tags": ["AQL"]}}, "/_admin/metrics/v2": {"get": {"description": "Returns the instance's current metrics in Prometheus format. The\nreturned document collects all instance metrics, which are measured\nat any given time and exposes them for collection by Prometheus.\nThe document contains different metrics and metrics groups dependent\non the role of the queried instance. All exported metrics are\npublished with the prefix `arangodb_` or `rocksdb_` to distinguish them from\nother collected data.\nThe API then needs to be added to the Prometheus configuration file\nfor collection.\n", "operationId": " getMetricsV2", "parameters": [{"name": "serverId", "schema": {"type": "string"}, "required": false, "description": "Returns metrics of the specified server. If no serverId is given, the asked\nserver will reply. This parameter is only meaningful on Coordinators.\n", "in": "query"}], "responses": {"200": {"description": "Metrics were returned successfully.\n"}, "404": {"description": "The metrics API may be disabled using `--server.export-metrics-api false`\nsetting in the server. In this case, the result of the call indicates the API\nto be not found.\n"}}, "tags": ["Administration"]}}, "/_admin/metrics": {"get": {"description": "\nReturns the instance's current metrics in Prometheus format. The\nreturned document collects all instance metrics, which are measured\nat any given time and exposes them for collection by Prometheus.\n\nThe document contains different metrics and metrics groups dependent\non the role of the queried instance. All exported metrics are\npublished with the `arangodb_` or `rocksdb_` string to distinguish\nthem from other collected data. \n\nThe API then needs to be added to the Prometheus configuration file\nfor collection.\n\n", "operationId": " getMetrics", "parameters": [{"name": "serverId", "schema": {"type": "string"}, "required": false, "description": "Returns metrics of the specified server. If no serverId is given, the asked \nserver will reply. This parameter is only meaningful on Coordinators.\n\n", "in": "query"}], "responses": {"200": {"description": "Metrics were returned successfully.\n"}, "404": {"description": "The metrics API may be disabled using `--server.export-metrics-api false`\nsetting in the server. In this case, the result of the call indicates the API\nto be not found.\n"}}, "tags": ["Administration"]}}, "/_admin/server/tls": {"get": {"description": "Return a summary of the TLS data. The JSON response will contain a field\n`result` with the following components:\n  - `keyfile`: Information about the key file.\n  - `clientCA`: Information about the CA for client certificate\n    verification.\nIf server name indication (SNI) is used and multiple key files are\nconfigured for different server names, then there is an additional\nattribute `SNI`, which contains for each configured server name\nthe corresponding information about the key file for that server name.\nIn all cases the value of the attribute will be a JSON object, which\nhas a subset of the following attributes (whatever is appropriate):\n  - `sha256`: The value is a string with the SHA256 of the whole input\n    file.\n  - `certificates`: The value is a JSON array with the public\n    certificates in the chain in the file.\n  - `privateKeySha256`: In cases where there is a private key (`keyfile`\n    but not `clientCA`), this field is present and contains a\n    JSON string with the SHA256 of the private key.\nThis API requires authentication.\n", "operationId": " handleTLS:get", "responses": {"200": {"description": "This API will return HTTP 200 if everything is ok\n"}}, "tags": ["Administration"]}, "post": {"description": "This API call triggers a reload of all the TLS data and then\nreturns a summary. The JSON response is exactly as in the corresponding\nGET request (see there).\nThis is a protected API and can only be executed with superuser rights.\n", "operationId": " handleTLS:post", "responses": {"200": {"description": "This API will return HTTP 200 if everything is ok\n"}, "403": {"description": "This API will return HTTP 403 FORBIDDEN if it is not called with\nsuperuser rights.\n"}}, "tags": ["Administration"]}}, "/_admin/server/encryption": {"post": {"description": "Change the user supplied encryption at rest key by sending a request without\npayload to this endpoint. The file supplied via `--rocksdb.encryption-keyfolder`\nwill be reloaded and the internal encryption key will be re-encrypted with the\nnew user key.\nThis is a protected API and can only be executed with superuser rights.\nThis API is not available on coordinator nodes.\nThe API returns HTTP 404 in case encryption key rotation is disabled.\n", "operationId": " handleEncryption:post", "responses": {"200": {"description": "This API will return HTTP 200 if everything is ok\n"}, "403": {"description": "This API will return HTTP 403 FORBIDDEN if it is not called with\nsuperuser rights.\n"}, "404": {"description": "This API will return HTTP 404 in case encryption key rotation is disabled.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate whether an error occurred (*false* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code - 200 in this case\n"}, "result": {"$ref": "#/components/schemas/jwt_keys_struct", "description": "The result object.\n"}}, "required": ["error", "code", "result"]}}}}}, "tags": ["Administration"]}}, "/_admin/server/mode": {"get": {"description": "Return mode information about a server. The json response will contain\na field `mode` with the value `readonly` or `default`. In a read-only server\nall write operations will fail with an error code of `1004` (_ERROR_READ_ONLY_).\nCreating or dropping of databases and collections will also fail with error code `11` (_ERROR_FORBIDDEN_).\nThis API requires authentication.\n", "operationId": " handleMode:get", "responses": {"200": {"description": "This API will return HTTP 200 if everything is ok\n"}}, "tags": ["Administration"]}, "put": {"description": "Update mode information about a server. The json response will contain\na field `mode` with the value `readonly` or `default`. In a read-only server\nall write operations will fail with an error code of `1004` (_ERROR_READ_ONLY_).\nCreating or dropping of databases and collections will also fail with error\ncode `11` (_ERROR_FORBIDDEN_).\nThis is a protected API. It requires authentication and administrative\nserver rights.\n", "operationId": " handleMode:set", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"mode": {"type": "string", "description": "The mode of the server `readonly` or `default`.\n"}}, "required": ["mode"]}}}}, "responses": {"200": {"description": "This API will return HTTP 200 if everything is ok\n"}, "401": {"description": "if the request was not authenticated as a user with sufficient rights\n"}}, "tags": ["Administration"]}}, "/_admin/server/id": {"get": {"description": "Returns the id of a server in a cluster. The request will fail if the\nserver is not running in cluster mode.\n", "operationId": " handleId", "responses": {"200": {"description": "Is returned when the server is running in cluster mode.\n"}, "500": {"description": "Is returned when the server is not running in cluster mode.\n"}}, "tags": ["Administration"]}}, "/_admin/server/role": {"get": {"description": "Returns the role of a server in a cluster.\nThe role is returned in the *role* attribute of the result.\nPossible return values for *role* are:\n- *SINGLE*: the server is a standalone server without clustering\n- *COORDINATOR*: the server is a Coordinator in a cluster\n- *PRIMARY*: the server is a DB-Server in a cluster\n- *SECONDARY*: this role is not used anymore\n- *AGENT*: the server is an Agency node in a cluster\n- *UNDEFINED*: in a cluster, *UNDEFINED* is returned if the server role cannot be\n   determined.\n", "operationId": " handleRole", "responses": {"200": {"description": "Is returned in all cases.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "always *false*\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code, always 200\n"}, "errorNum": {"type": "integer", "format": "int64", "description": "the server error number\n"}}, "required": ["error", "code", "errorNum"]}}}}}, "tags": ["Administration"]}}, "/_admin/server/availability": {"get": {"description": "Return availability information about a server.\nThis is a public API so it does *not* require authentication. It is meant to be\nused only in the context of server monitoring.\n", "operationId": " handleAvailability", "responses": {"200": {"description": "This API will return HTTP 200 in case the server is up and running and usable for\narbitrary operations, is not set to read-only mode and is currently not a follower\nin case of an active failover setup.\n"}, "503": {"description": "HTTP 503 will be returned in case the server is during startup or during shutdown,\nis set to read-only mode or is currently a follower in an active failover setup.\n"}}, "tags": ["Administration"]}}, "/_admin/cluster/statistics": {"get": {"description": "Queries the statistics of the given DB-Server\n", "parameters": [{"name": "DBserver", "schema": {"type": "string"}, "required": true, "description": "", "in": "query"}], "responses": {"200": {"description": "is returned when everything went well.\n"}, "400": {"description": "the parameter DBserver was not given or is not the ID of a DB-Server\n"}, "403": {"description": "server is not a DB-Server.\n"}}, "tags": ["Cluster"]}}, "/_admin/cluster/health": {"get": {"description": "Queries the health of the cluster for monitoring purposes. The response is a JSON object, containing the standard `code`, `error`, `errorNum`, and `errorMessage` fields as appropriate. The endpoint-specific fields are as follows:\n- `ClusterId`: A UUID string identifying the cluster\n- `Health`: An object containing a descriptive sub-object for each node in the cluster.\n  - `<nodeID>`: Each entry in `Health` will be keyed by the node ID and contain the following attributes:\n    - `Endpoint`: A string representing the network endpoint of the server.\n    - `Role`: The role the server plays. Possible values are `\"AGENT\"`, `\"COORDINATOR\"`, and `\"DBSERVER\"`.\n    - `CanBeDeleted`: Boolean representing whether the node can safely be removed from the cluster.\n    - `Version`: Version String of ArangoDB used by that node.\n    - `Engine`: Storage Engine used by that node.\n    - `Status`: A string indicating the health of the node as assessed by the supervision (Agency). This should be considered primary source of truth for Coordinator and DB-Servers node health. If the node is responding normally to requests, it is `\"GOOD\"`. If it has missed one heartbeat, it is `\"BAD\"`. If it has been declared failed by the supervision, which occurs after missing heartbeats for about 15 seconds, it will be marked `\"FAILED\"`.\n    Additionally it will also have the following attributes for:\n    **Coordinators** and **DB-Servers**\n    - `SyncStatus`: The last sync status reported by the node. This value is primarily used to determine the value of `Status`. Possible values include `\"UNKNOWN\"`, `\"UNDEFINED\"`, `\"STARTUP\"`, `\"STOPPING\"`, `\"STOPPED\"`, `\"SERVING\"`, `\"SHUTDOWN\"`.\n    - `LastAckedTime`: ISO 8601 timestamp specifying the last heartbeat received.\n    - `ShortName`: A string representing the shortname of the server, e.g. `\"Coordinator0001\"`.\n    - `Timestamp`: ISO 8601 timestamp specifying the last heartbeat received. (deprecated)\n    - `Host`: An optional string, specifying the host machine if known.\n    **Coordinators** only\n    - `AdvertisedEndpoint`: A string representing the advertised endpoint, if set. (e.g. external IP address or load balancer, optional)\n    **Agents**\n    - `Leader`: ID of the Agent this node regards as leader.\n    - `Leading`: Whether this Agent is the leader (true) or not (false).\n    - `LastAckedTime`: Time since last `acked` in seconds.\n", "responses": {"200": {"description": "is returned when everything went well.\n"}}, "tags": ["Cluster"]}}, "/_admin/cluster/rebalance": {"get": {"description": "\nComputes the current cluster imbalance and returns the result. \nIt additionally shows the amount of ongoing and pending move shard operations.\n\n", "responses": {"200": {"description": "This API returns HTTP 200.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"code": {"type": "number", "description": "The status code.\n"}, "error": {"type": "boolean", "description": "Whether an error occurred. `false` in this case.\n"}, "result": {"$ref": "#/components/schemas/get_admin_cluster_rebalance_result", "description": "The result object.\n"}, "pendingMoveShards": {"type": "number", "description": "The number of pending move shard operations.\n"}}, "required": ["code", "error", "result", "pendingMoveShards"]}}}}}, "tags": ["Administration"]}, "post": {"description": "Compute a set of move shard operations to improve balance.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"": {"$ref": "#/components/schemas/rebalance_compute", "description": ""}}, "required": [""]}}}}, "responses": {"200": {"description": "This API returns HTTP 200.\n"}}, "tags": ["Administration"]}, "put": {"description": "Compute a set of move shard operations to improve balance.\nThese moves are then immediately executed.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"": {"$ref": "#/components/schemas/rebalance_compute", "description": ""}}, "required": [""]}}}}, "responses": {"200": {"description": "This API returns HTTP 200.\n"}}, "tags": ["Administration"]}}, "/_admin/cluster/rebalance/execute": {"post": {"description": "Execute the given set of move shard operations. You can use the\n`POST /_admin/cluster/rebalance` endpoint to calculate these operations to improve\nthe balance of shards, leader shards, and follower shards.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"version": {"type": "number", "description": "Must be set to `1`.\n"}, "moves": {"$ref": "#/components/schemas/move_shard_operation", "items": {"type": "move_shard_operation"}, "description": "A set of move shard operations to execute.\n"}}, "required": ["version", "moves"]}}}}, "responses": {"200": {"description": "This API returns HTTP 200 if no operations are provided.\n"}, "202": {"description": "This API returns HTTP 202 if the operations have been accepted and scheduled for execution.\n"}}, "tags": ["Administration"]}}, "/_admin/compact": {"put": {"description": "This endpoint can be used to reclaim disk space after substantial data\ndeletions have taken place. It requires superuser access.\n", "operationId": " RestCompactHandler", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"changeLevel": {"type": "boolean", "description": "whether or not compacted data should be moved to the minimum possible level.\nThe default value is *false*.\n"}, "compactBottomMostLevel": {"type": "boolean", "description": "Whether or not to compact the bottommost level of data.\nThe default value is *false*.\n"}}, "required": []}}}}, "responses": {"200": {"description": "Compaction started successfully\n"}, "401": {"description": "if the request was not authenticated as a user with sufficient rights\n"}}, "tags": ["Administration"]}}, "/_admin/routing/reload": {"post": {"description": "Reloads the routing information from the collection *routing*.\n", "operationId": " RestAdminRoutingHandler", "responses": {"200": {"description": "Routing information was reloaded successfully.\n"}}, "tags": ["Administration"]}}, "/_api/index#inverted": {"post": {"description": "Creates an inverted index for the collection `collection-name`, if\nit does not already exist. The call expects an object containing the index\ndetails.\n", "operationId": " createIndex:inverted", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"type": {"type": "string", "description": "Must be equal to `\"inverted\"`.\n"}, "name": {"type": "string", "description": "An easy-to-remember name for the index to look it up or refer to it in index hints.\nIndex names are subject to the same character restrictions as collection names.\nIf omitted, a name is auto-generated so that it is unique with respect to the\ncollection, e.g. `idx_832910498`.\n"}, "fields": {"$ref": "#/components/schemas/post_api_index_inverted_fields", "items": {"type": "post_api_index_inverted_fields"}, "description": "An array of attribute paths. You can use strings to index the fields with the\ndefault options, or objects to specify options for the fields (with the\nattribute path in the `name` property), or a mix of both.\n"}, "searchField": {"type": "boolean", "description": "This option only applies if you use the inverted index in a `search-alias` Views.\nYou can set the option to `true` to get the same behavior as with `arangosearch`\nViews regarding the indexing of array values as the default. If enabled, both,\narray and primitive values (strings, numbers, etc.) are accepted. Every element\nof an array is indexed according to the `trackListPositions` option.\nIf set to `false`, it depends on the attribute path. If it explicitly expands an\narray (`[*]`), then the elements are indexed separately. Otherwise, the array is\nindexed as a whole, but only `geopoint` and `aql` Analyzers accept array inputs.\nYou cannot use an array expansion if `searchField` is enabled.\nDefault: `false`\n"}, "storedValues": {"$ref": "#/components/schemas/post_api_index_inverted_storedvalues", "items": {"type": "post_api_index_inverted_storedvalues"}, "description": "The optional `storedValues` attribute can contain an array of paths to additional \nattributes to store in the index. These additional attributes cannot be used for\nindex lookups or for sorting, but they can be used for projections. This allows an\nindex to fully cover more queries and avoid extra document lookups.\n\n"}, "primarySort": {"$ref": "#/components/schemas/post_api_index_inverted_primarysort", "description": "You can define a primary sort order to enable an AQL optimization. If a query\niterates over all documents of a collection, wants to sort them by attribute values,\nand the (left-most) fields to sort by, as well as their sorting direction, match\nwith the `primarySort` definition, then the `SORT` operation is optimized away.\n"}, "analyzer": {"type": "string", "description": "The name of an Analyzer to use by default. This Analyzer is applied to the\nvalues of the indexed fields for which you don't define Analyzers explicitly.\nDefault: `identity`\n"}, "features": {"type": "array", "items": {"type": "string"}, "description": "A list of Analyzer features. You can set this option to overwrite what features\nare enabled for the default `analyzer`. Possible features:\n- `\"frequency\"`\n- `\"norm\"`\n- `\"position\"`\n- `\"offset\"`\nDefault: the features as defined by the Analyzer itself.\n"}, "includeAllFields": {"type": "boolean", "description": "This option only applies if you use the inverted index in a `search-alias` Views.\nIf set to `true`, then all document attributes are indexed, excluding any\nsub-attributes that are configured in the `fields` array (and their sub-attributes).\nThe `analyzer` and `features` properties apply to the sub-attributes.\nDefault: `false`\n**Warning**: Using `includeAllFields` for a lot of attributes in combination\nwith complex Analyzers may significantly slow down the indexing process.\n"}, "trackListPositions": {"type": "boolean", "description": "This option only applies if you use the inverted index in a `search-alias` Views.\nIf set to `true`, then track the value position in arrays for array values.\nFor example, when querying a document like `{ attr: [ \"valueX\", \"valueY\", \"valueZ\" ] }`,\nyou need to specify the array element, e.g. `doc.attr[1] == \"valueY\"`.\nIf set to `false`, all values in an array are treated as equal alternatives.\nYou don't specify an array element in queries, e.g. `doc.attr == \"valueY\"`, and\nall elements are searched for a match.\n"}, "parallelism": {"type": "integer", "description": "The number of threads to use for indexing the fields. Default: `2`\n"}, "inBackground": {"type": "boolean", "description": "This attribute can be set to `true` to create the index\nin the background, not write-locking the underlying collection for\nas long as if the index is built in the foreground. The default value is `false`.\n"}, "cleanupIntervalStep": {"type": "integer", "format": "int64", "description": "Wait at least this many commits between removing unused files in the\nArangoSearch data directory (default: 2, to disable use: 0).\nFor the case where the consolidation policies merge segments often (i.e. a lot\nof commit+consolidate), a lower value will cause a lot of disk space to be\nwasted.\nFor the case where the consolidation policies rarely merge segments (i.e. few\ninserts/deletes), a higher value will impact performance without any added\nbenefits.\n_Background:_\n  With every \"commit\" or \"consolidate\" operation a new state of the View\n  internal data-structures is created on disk.\n  Old states/snapshots are released once there are no longer any users\n  remaining.\n  However, the files for the released states/snapshots are left on disk, and\n  only removed by \"cleanup\" operation.\n"}, "commitIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between committing View data store\nchanges and making documents visible to queries (default: 1000, to disable\nuse: 0).\nFor the case where there are a lot of inserts/updates, a lower value, until\ncommit, will cause the index not to account for them and memory usage would\ncontinue to grow.\nFor the case where there are a few inserts/updates, a higher value will impact\nperformance and waste disk space for each commit call without any added\nbenefits.\n_Background:_\n  For data retrieval ArangoSearch Views follow the concept of\n  \"eventually-consistent\", i.e. eventually all the data in ArangoDB will be\n  matched by corresponding query expressions.\n  The concept of ArangoSearch View \"commit\" operation is introduced to\n  control the upper-bound on the time until document addition/removals are\n  actually reflected by corresponding query expressions.\n  Once a \"commit\" operation is complete all documents added/removed prior to\n  the start of the \"commit\" operation will be reflected by queries invoked in\n  subsequent ArangoDB transactions, in-progress ArangoDB transactions will\n  still continue to return a repeatable-read state.\n"}, "consolidationIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between applying 'consolidationPolicy' to\nconsolidate View data store and possibly release space on the filesystem\n(default: 1000, to disable use: 0).\nFor the case where there are a lot of data modification operations, a higher\nvalue could potentially have the data store consume more space and file handles.\nFor the case where there are a few data modification operations, a lower value\nwill impact performance due to no segment candidates available for\nconsolidation.\n_Background:_\n  For data modification ArangoSearch Views follow the concept of a\n  \"versioned data store\". Thus old versions of data may be removed once there\n  are no longer any users of the old data. The frequency of the cleanup and\n  compaction operations are governed by 'consolidationIntervalMsec' and the\n  candidates for compaction are selected via 'consolidationPolicy'.\n"}, "consolidationPolicy": {"$ref": "#/components/schemas/post_api_index_inverted_policy", "description": "The consolidation policy to apply for selecting which segments should be merged\n(default: {}).\n_Background:_\n  With each ArangoDB transaction that inserts documents one or more\n  ArangoSearch internal segments gets created.\n  Similarly for removed documents the segments that contain such documents\n  will have these documents marked as 'deleted'.\n  Over time this approach causes a lot of small and sparse segments to be\n  created.\n  A \"consolidation\" operation selects one or more segments and copies all of\n  their valid documents into a single new segment, thereby allowing the\n  search algorithm to perform more optimally and for extra file handles to be\n  released once old segments are no longer used.\n"}, "writebufferIdle": {"type": "integer", "format": "int64", "description": "Maximum number of writers (segments) cached in the pool\n(default: 64, use 0 to disable)\n"}, "writebufferActive": {"type": "integer", "format": "int64", "description": "Maximum number of concurrent active writers (segments) that perform a\ntransaction. Other writers (segments) wait till current active writers\n(segments) finish (default: 0, use 0 to disable)\n"}, "writebufferSizeMax": {"type": "integer", "format": "int64", "description": "Maximum memory byte size per writer (segment) before a writer (segment) flush\nis triggered. `0` value turns off this limit for any writer (buffer) and data\nwill be flushed periodically based on the value defined for the flush thread\n(ArangoDB server startup option). `0` value should be used carefully due to\nhigh potential memory consumption\n(default: 33554432, use 0 to disable)\n"}}, "required": ["type", "fields"]}}}}, "responses": {"200": {"description": "If the index already exists, then a *HTTP 200* is returned.\n"}, "201": {"description": "If the index does not already exist and can be created, then a *HTTP 201*\nis returned.\n"}, "404": {"description": "If the `collection-name` is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/index#ttl": {"post": {"description": "Creates a TTL index for the collection *collection-name* if it\ndoes not already exist. The call expects an object containing the index\ndetails.\n", "operationId": " createIndex:ttl", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"type": {"type": "string", "description": "must be equal to *\"ttl\"*.\n"}, "name": {"type": "string", "description": "An easy-to-remember name for the index to look it up or refer to it in index hints.\nIndex names are subject to the same character restrictions as collection names.\nIf omitted, a name is auto-generated so that it is unique with respect to the\ncollection, e.g. `idx_832910498`.\n"}, "fields": {"type": "array", "items": {"type": "string"}, "description": "an array with exactly one attribute path.\n"}, "expireAfter": {"type": "number", "description": "The time interval (in seconds) from the point in time stored in the `fields`\nattribute after which the documents count as expired. Can be set to `0` to let\ndocuments expire as soon as the server time passes the point in time stored in\nthe document attribute, or to a higher number to delay the expiration.\n"}, "inBackground": {"type": "boolean", "description": "The optional attribute **inBackground** can be set to *true* to create the index\nin the background, which will not write-lock the underlying collection for\nas long as if the index is built in the foreground. The default value is *false*.\n"}}, "required": ["type", "fields", "expireAfter"]}}}}, "responses": {"200": {"description": "If the index already exists, then a *HTTP 200* is returned.\n"}, "201": {"description": "If the index does not already exist and could be created, then a *HTTP 201*\nis returned.\n"}, "400": {"description": "If the collection already contains another TTL index, then an *HTTP 400* is\nreturned, as there can be at most one TTL index per collection.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/index/{index-id}": {"get": {"description": "The result is an object describing the index. It has at least the following\nattributes:\n- *id*: the identifier of the index\n- *type*: the index type\nAll other attributes are type-dependent. For example, some indexes provide\n*unique* or *sparse* flags, whereas others don't. Some indexes also provide\na selectivity estimate in the *selectivityEstimate* attribute of the result.\n", "operationId": " getIndexes:handle", "parameters": [{"name": "index-id", "schema": {"type": "string"}, "required": true, "description": "The index identifier.\n", "in": "path"}], "responses": {"200": {"description": "If the index exists, then a *HTTP 200* is returned.\n"}, "404": {"description": "If the index does not exist, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Indexes"]}, "delete": {"description": "Deletes an index with *index-id*.\n", "operationId": " dropIndex", "parameters": [{"name": "index-id", "schema": {"type": "string"}, "required": true, "description": "The index id.\n", "in": "path"}], "responses": {"200": {"description": "If the index could be deleted, then an *HTTP 200* is\nreturned.\n"}, "404": {"description": "If the *index-id* is unknown, then an *HTTP 404* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/index#general": {"post": {"description": "Creates a new index in the collection `collection`. Expects\nan object containing the index details.\nThe type of the index to be created must specified in the **type**\nattribute of the index details. Depending on the index type, additional\nother attributes may need to specified in the request in order to create\nthe index.\nIndexes require the to be indexed attribute(s) in the **fields** attribute\nof the index details. Depending on the index type, a single attribute or\nmultiple attributes can be indexed. In the latter case, an array of\nstrings is expected.\nThe `.` character denotes sub-attributes in attribute paths. Attributes with\nliteral `.` in their name cannot be indexed. Attributes with the name `_id`\ncannot be indexed either, neither as a top-level attribute nor as a sub-attribute.\nOptionally, an index name may be specified as a string in the **name** attribute.\nIndex names have the same restrictions as collection names. If no value is\nspecified, one will be auto-generated.\nPersistent indexes (including vertex-centric indexes) can be created as unique\nor non-unique variants. Uniqueness can be controlled by specifying the\n**unique** option for the index definition. Setting it to `true` creates a\nunique index. Setting it to `false` or omitting the `unique` attribute creates a\nnon-unique index.\n**Note**: Unique indexes on non-shard keys are not supported in a cluster.\nPersistent indexes can optionally be created in a sparse\nvariant. A sparse index will be created if the **sparse** attribute in\nthe index details is set to `true`. Sparse indexes do not index documents\nfor which any of the index attributes is either not set or is `null`.\nThe optional **deduplicate** attribute is supported by persistent array indexes.\nIt controls whether inserting duplicate index values\nfrom the same document into a unique array index will lead to a unique constraint\nerror or not. The default value is `true`, so only a single instance of each\nnon-unique index value will be inserted into the index per document. Trying to\ninsert a value into the index that already exists in the index always fails,\nregardless of the value of this attribute.\nThe optional **estimates** attribute is supported by persistent indexes.\nThis attribute controls whether index selectivity estimates are\nmaintained for the index. Not maintaining index selectivity estimates can have\na slightly positive impact on write performance.\nThe downside of turning off index selectivity estimates will be that\nthe query optimizer will not be able to determine the usefulness of different\ncompeting indexes in AQL queries when there are multiple candidate indexes to\nchoose from.\nThe `estimates` attribute is optional and defaults to `true` if not set. It will\nhave no effect on indexes other than persistent indexes.\nThe optional attribute **cacheEnabled** is supported by indexes of type\n*persistent*. This attribute controls whether an extra in-memory hash cache is\ncreated for the index. The hash cache can be used to speed up index lookups.\nThe cache can only be used for queries that look up all index attributes via\nan equality lookup (`==`). The hash cache cannot be used for range scans,\npartial lookups or sorting.\nThe cache will be populated lazily upon reading data from the index. Writing data\ninto the collection or updating existing data will invalidate entries in the\ncache. The cache may have a negative effect on performance in case index values\nare updated more often than they are read.\nThe maximum size of cache entries that can be stored is currently 4 MB, i.e.\nthe cumulated size of all index entries for any index lookup value must be\nless than 4 MB. This limitation is there to avoid storing the index entries\nof \"super nodes\" in the cache.\n`cacheEnabled` defaults to `false` and should only be used for indexes that\nare known to benefit from an extra layer of caching.\nThe optional attribute **inBackground** can be set to `true` to create the index\nin the background, which will not write-lock the underlying collection for\nas long as if the index is built in the foreground.\n", "operationId": " createIndex:general", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"index-details": {"type": "object", "description": ""}}, "required": ["index-details"]}}}}, "responses": {"200": {"description": "If the index already exists, then an *HTTP 200* is returned.\n"}, "201": {"description": "If the index does not already exist and could be created, then an *HTTP 201*\nis returned.\n"}, "400": {"description": "If an invalid index description is posted or attributes are used that the\ntarget index will not support, then an *HTTP 400* is returned.\n"}, "404": {"description": "If *collection* is unknown, then an *HTTP 404* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/index": {"get": {"description": "Returns an object with an attribute *indexes* containing an array of all\nindex descriptions for the given collection. The same information is also\navailable in the *identifiers* as an object with the index handles as\nkeys.\n", "operationId": " getIndexes", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}, {"name": "withStats", "schema": {"type": "boolean"}, "required": false, "description": "Whether to include figures and estimates in the result.\n", "in": "query"}, {"name": "withHidden", "schema": {"type": "boolean"}, "required": false, "description": "Whether to include hidden indexes in the result.\n", "in": "query"}], "responses": {"200": {"description": "returns a JSON object containing a list of indexes on that collection.\n"}}, "tags": ["Indexes"]}}, "/_api/index#geo": {"post": {"description": "Creates a geo-spatial index in the collection `collection`, if\nit does not already exist. Expects an object containing the index details.\nGeo indexes are always sparse, meaning that documents that do not contain\nthe index attributes or have non-numeric values in the index attributes\nwill not be indexed.\n", "operationId": " createIndex#geo", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"type": {"type": "string", "description": "must be equal to `\"geo\"`.\n"}, "name": {"type": "string", "description": "An easy-to-remember name for the index to look it up or refer to it in index hints.\nIndex names are subject to the same character restrictions as collection names.\nIf omitted, a name is auto-generated so that it is unique with respect to the\ncollection, e.g. `idx_832910498`.\n"}, "fields": {"type": "array", "items": {"type": "string"}, "description": "An array with one or two attribute paths.\nIf it is an array with one attribute path `location`, then a geo-spatial\nindex on all documents is created using `location` as path to the\ncoordinates. The value of the attribute must be an array with at least two\ndouble values. The array must contain the latitude (first value) and the\nlongitude (second value). All documents, which do not have the attribute\npath or with value that are not suitable, are ignored.\nIf it is an array with two attribute paths `latitude` and `longitude`,\nthen a geo-spatial index on all documents is created using `latitude`\nand `longitude` as paths the latitude and the longitude. The values of\nthe `latitude` and `longitude` attributes must each be a number (double).\nAll documents which do not have the attribute paths or which have\nvalues that are not suitable are ignored.\n"}, "geoJson": {"type": "boolean", "description": "If a geo-spatial index on a `location` is constructed\nand `geoJson` is `true`, then the order within the array is longitude\nfollowed by latitude. This corresponds to the format described in\nhttp://geojson.org/geojson-spec.html#positions\n"}, "inBackground": {"type": "boolean", "description": "The optional attribute **inBackground** can be set to `true` to create the index\nin the background, which will not write-lock the underlying collection for\nas long as if the index is built in the foreground. The default value is `false`.\n"}}, "required": ["type", "fields"]}}}}, "responses": {"200": {"description": "If the index already exists, then a *HTTP 200* is returned.\n"}, "201": {"description": "If the index does not already exist and could be created, then a *HTTP 201*\nis returned.\n"}, "404": {"description": "If the `collection` is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/index#persistent": {"post": {"description": "Creates a persistent index for the collection `collection-name`, if\nit does not already exist. The call expects an object containing the index\ndetails.\nIn a sparse index all documents will be excluded from the index that do not\ncontain at least one of the specified index attributes (i.e. `fields`) or that\nhave a value of `null` in any of the specified index attributes. Such documents\nwill not be indexed, and not be taken into account for uniqueness checks if\nthe `unique` flag is set.\nIn a non-sparse index, these documents will be indexed (for non-present\nindexed attributes, a value of `null` will be used) and will be taken into\naccount for uniqueness checks if the `unique` flag is set.\n**Note**: Unique indexes on non-shard keys are not supported in a cluster.\n", "operationId": " createIndex:persistent", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"type": {"type": "string", "description": "Must be equal to `\"persistent\"`.\n"}, "name": {"type": "string", "description": "An easy-to-remember name for the index to look it up or refer to it in index hints.\nIndex names are subject to the same character restrictions as collection names.\nIf omitted, a name is auto-generated so that it is unique with respect to the\ncollection, e.g. `idx_832910498`.\n"}, "fields": {"type": "array", "items": {"type": "string"}, "description": "An array of attribute paths.\nThe `.` character denotes sub-attributes in attribute paths. Attributes with\nliteral `.` in their name cannot be indexed. Attributes with the name `_id`\ncannot be indexed either, neither as a top-level attribute nor as a sub-attribute.\nYou can expand one array attribute with `[*]`.\n"}, "storedValues": {"type": "array", "items": {"type": "string"}, "description": "The optional `storedValues` attribute can contain an array of paths to additional \nattributes to store in the index. These additional attributes cannot be used for\nindex lookups or for sorting, but they can be used for projections. This allows an\nindex to fully cover more queries and avoid extra document lookups.\nThe maximum number of attributes in `storedValues` is 32.\n\nIt is not possible to create multiple indexes with the same `fields` attributes\nand uniqueness but different `storedValues` attributes. That means the value of\n`storedValues` is not considered by index creation calls when checking if an\nindex is already present or needs to be created.\n\nIn unique indexes, only the attributes in `fields` are checked for uniqueness,\nbut the attributes in `storedValues` are not checked for their uniqueness. \nNon-existing attributes are stored as `null` values inside `storedValues`.\n\n"}, "unique": {"type": "boolean", "description": "If `true`, then create a unique index. Defaults to `false`.\nIn unique indexes, only the attributes in `fields` are checked for uniqueness,\nbut the attributes in `storedValues` are not checked for their uniqueness.\n"}, "sparse": {"type": "boolean", "description": "If `true`, then create a sparse index. Defaults to `false`.\n"}, "deduplicate": {"type": "boolean", "description": "The attribute controls whether inserting duplicate index values\nfrom the same document into a unique array index will lead to a unique constraint\nerror or not. The default value is `true`, so only a single instance of each\nnon-unique index value will be inserted into the index per document. Trying to\ninsert a value into the index that already exists in the index will always fail,\nregardless of the value of this attribute.\n"}, "estimates": {"type": "boolean", "description": "This attribute controls whether index selectivity estimates are maintained for the\nindex. Not maintaining index selectivity estimates can have a slightly positive\nimpact on write performance.\nThe downside of turning off index selectivity estimates will be that\nthe query optimizer will not be able to determine the usefulness of different\ncompeting indexes in AQL queries when there are multiple candidate indexes to\nchoose from.\nThe `estimates` attribute is optional and defaults to `true` if not set. It will\nhave no effect on indexes other than `persistent`.\n"}, "cacheEnabled": {"type": "boolean", "description": "This attribute controls whether an extra in-memory hash cache is\ncreated for the index. The hash cache can be used to speed up index lookups.\nThe cache can only be used for queries that look up all index attributes via\nan equality lookup (`==`). The hash cache cannot be used for range scans,\npartial lookups or sorting.\nThe cache will be populated lazily upon reading data from the index. Writing data\ninto the collection or updating existing data will invalidate entries in the\ncache. The cache may have a negative effect on performance in case index values\nare updated more often than they are read.\nThe maximum size of cache entries that can be stored is currently 4 MB, i.e.\nthe cumulated size of all index entries for any index lookup value must be\nless than 4 MB. This limitation is there to avoid storing the index entries\nof \"super nodes\" in the cache.\n`cacheEnabled` defaults to `false` and should only be used for indexes that\nare known to benefit from an extra layer of caching.\n"}, "inBackground": {"type": "boolean", "description": "This attribute can be set to `true` to create the index\nin the background, which will not write-lock the underlying collection for\nas long as if the index is built in the foreground. The default value is `false`.\n"}}, "required": ["type", "fields"]}}}}, "responses": {"200": {"description": "If the index already exists, then a *HTTP 200* is\nreturned.\n"}, "201": {"description": "If the index does not already exist and could be created, then a *HTTP 201*\nis returned.\n"}, "400": {"description": "If the collection already contains documents and you try to create a unique\npersistent index in such a way that there are documents violating the\nuniqueness, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the `collection-name` is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/index#multi-dim": {"post": {"description": "Creates a multi-dimensional index for the collection *collection-name*, if\nit does not already exist. The call expects an object containing the index\ndetails.\n", "operationId": " createIndex#multi-dim", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"type": {"type": "string", "description": "must be equal to *\"zkd\"*.\n"}, "name": {"type": "string", "description": "An easy-to-remember name for the index to look it up or refer to it in index hints.\nIndex names are subject to the same character restrictions as collection names.\nIf omitted, a name is auto-generated so that it is unique with respect to the\ncollection, e.g. `idx_832910498`.\n"}, "fields": {"type": "array", "items": {"type": "string"}, "description": "an array of attribute names used for each dimension. Array expansions are not allowed.\n"}, "unique": {"type": "boolean", "description": "if *true*, then create a unique index.\n"}, "inBackground": {"type": "boolean", "description": "The optional attribute **inBackground** can be set to *true* to create the index\nin the background, which will not write-lock the underlying collection for\nas long as if the index is built in the foreground. The default value is *false*.\n"}, "fieldValueTypes": {"type": "string", "description": "must be equal to *\"double\"*. Currently only doubles are supported as values.\n"}}, "required": ["type", "fields", "fieldValueTypes"]}}}}, "responses": {"200": {"description": "If the index already exists, then a *HTTP 200* is\nreturned.\n"}, "201": {"description": "If the index does not already exist and could be created, then a *HTTP 201*\nis returned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404* is returned.\n"}, "400": {"description": "If the index definition is invalid, then a *HTTP 400* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/index#fulltext": {"post": {"description": "Creates a fulltext index for the collection *collection-name*, if\nit does not already exist. The call expects an object containing the index\ndetails.\n", "operationId": " createIndex#fulltext", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"type": {"type": "string", "description": "must be equal to *\"fulltext\"*.\n"}, "name": {"type": "string", "description": "An easy-to-remember name for the index to look it up or refer to it in index hints.\nIndex names are subject to the same character restrictions as collection names.\nIf omitted, a name is auto-generated so that it is unique with respect to the\ncollection, e.g. `idx_832910498`.\n"}, "fields": {"type": "array", "items": {"type": "string"}, "description": "an array of attribute names. Currently, the array is limited\nto exactly one attribute.\n"}, "minLength": {"type": "integer", "format": "int64", "description": "Minimum character length of words to index. Will default\nto a server-defined value if unspecified. It is thus recommended to set\nthis value explicitly when creating the index.\n"}, "inBackground": {"type": "boolean", "description": "The optional attribute **inBackground** can be set to *true* to create the index\nin the background, which will not write-lock the underlying collection for\nas long as if the index is built in the foreground. The default value is *false*.\n"}}, "required": ["type", "fields", "minLength"]}}}}, "responses": {"200": {"description": "If the index already exists, then a *HTTP 200* is\nreturned.\n"}, "201": {"description": "If the index does not already exist and could be created, then a *HTTP 201*\nis returned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Indexes"]}}, "/_api/document/{collection}/{key}": {"get": {"description": "Returns the document identified by *document-id*. The returned\ndocument contains three special attributes: *_id* containing the document\nidentifier, *_key* containing key which uniquely identifies a document\nin a given collection and *_rev* containing the revision.\n", "operationId": "readDocument", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the *collection* from which the document is to be read.\n", "in": "path"}, {"name": "key", "schema": {"type": "string"}, "required": true, "description": "The document key.\n", "in": "path"}, {"name": "If-None-Match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-None-Match\" header is given, then it must contain exactly one\nEtag. The document is returned, if it has a different revision than the\ngiven Etag. Otherwise an *HTTP 304* is returned.\n", "in": "header"}, {"name": "If-Match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one\nEtag. The document is returned, if it has the same revision as the\ngiven Etag. Otherwise a *HTTP 412* is returned.\n", "in": "header"}, {"name": "x-arango-allow-dirty-read", "schema": {"type": "boolean"}, "required": false, "description": "Set this header to `true` to allow the Coordinator to ask any shard replica for\nthe data, not only the shard leader. This may result in \"dirty reads\".\nThe header is ignored if this operation is part of a Stream Transaction\n(`x-arango-trx-id` header). The header set when creating the transaction decides\nabout dirty reads for the entire transaction, not the individual read operations.\n", "in": "header"}, {"name": "x-arango-trx-id", "schema": {"type": "string"}, "required": false, "description": "To make this operation a part of a Stream Transaction, set this header to the\ntransaction ID returned by the `POST /_api/transaction/begin` call.\n", "in": "header"}], "responses": {"200": {"description": "is returned if the document was found\n"}, "304": {"description": "is returned if the \"If-None-Match\" header is given and the document has\nthe same version\n"}, "404": {"description": "is returned if the document or collection was not found\n"}, "412": {"description": "is returned if an \"If-Match\" header is given and the found\ndocument has a different version. The response will also contain the found\ndocument's current revision in the *_rev* attribute. Additionally, the\nattributes *_id* and *_key* will be returned.\n"}}, "tags": ["Documents"]}, "head": {"description": "Like *GET*, but only returns the header fields and not the body. You\ncan use this call to get the current revision of a document or check if\nthe document was deleted.\n", "operationId": "checkDocument", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the *collection* from which the document is to be read.\n", "in": "path"}, {"name": "key", "schema": {"type": "string"}, "required": true, "description": "The document key.\n", "in": "path"}, {"name": "If-None-Match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-None-Match\" header is given, then it must contain exactly one\nEtag. If the current document revision is not equal to the specified Etag,\nan *HTTP 200* response is returned. If the current document revision is\nidentical to the specified Etag, then an *HTTP 304* is returned.\n", "in": "header"}, {"name": "If-Match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one\nEtag. The document is returned, if it has the same revision as the\ngiven Etag. Otherwise a *HTTP 412* is returned.\n", "in": "header"}, {"name": "x-arango-allow-dirty-read", "schema": {"type": "boolean"}, "required": false, "description": "Set this header to `true` to allow the Coordinator to ask any shard replica for\nthe data, not only the shard leader. This may result in \"dirty reads\".\nThe header is ignored if this operation is part of a Stream Transaction\n(`x-arango-trx-id` header). The header set when creating the transaction decides\nabout dirty reads for the entire transaction, not the individual read operations.\n", "in": "header"}, {"name": "x-arango-trx-id", "schema": {"type": "string"}, "required": false, "description": "To make this operation a part of a Stream Transaction, set this header to the\ntransaction ID returned by the `POST /_api/transaction/begin` call.\n", "in": "header"}], "responses": {"200": {"description": "is returned if the document was found\n"}, "304": {"description": "is returned if the \"If-None-Match\" header is given and the document has\nthe same version\n"}, "404": {"description": "is returned if the document or collection was not found\n"}, "412": {"description": "is returned if an \"If-Match\" header is given and the found\ndocument has a different version. The response will also contain the found\ndocument's current revision in the *Etag* header.\n"}}, "tags": ["Documents"]}, "put": {"description": "Replaces the specified document with the one in the body, provided there is\nsuch a document and no precondition is violated.\nThe value of the `_key` attribute as well as attributes\nused as sharding keys may not be changed.\nIf the `If-Match` header is specified and the revision of the\ndocument in the database is unequal to the given revision, the\nprecondition is violated.\nIf `If-Match` is not given and `ignoreRevs` is `false` and there\nis a `_rev` attribute in the body and its value does not match\nthe revision of the document in the database, the precondition is\nviolated.\nIf a precondition is violated, an *HTTP 412* is returned.\nIf the document exists and can be updated, then an *HTTP 201* or\nan *HTTP 202* is returned (depending on `waitForSync`, see below),\nthe `Etag` header field contains the new revision of the document\nand the `Location` header contains a complete URL under which the\ndocument can be queried.\nCluster only: The replace documents _may_ contain\nvalues for the collection's pre-defined shard keys. Values for the shard keys\nare treated as hints to improve performance. Should the shard keys\nvalues be incorrect ArangoDB may answer with a *not found* error.\nOptionally, the query parameter `waitForSync` can be used to force\nsynchronization of the document replacement operation to disk even in case\nthat the `waitForSync` flag had been disabled for the entire collection.\nThus, the `waitForSync` query parameter can be used to force synchronization\nof just specific operations. To use this, set the `waitForSync` parameter\nto `true`. If the `waitForSync` parameter is not specified or set to\n`false`, then the collection's default `waitForSync` behavior is\napplied. The `waitForSync` query parameter cannot be used to disable\nsynchronization for collections that have a default `waitForSync` value\nof `true`.\nIf `silent` is not set to `true`, the body of the response contains a JSON\nobject with the information about the identifier and the revision. The attribute\n`_id` contains the known *document ID* of the updated document, `_key`\ncontains the key which uniquely identifies a document in a given collection,\nand the attribute `_rev` contains the new document revision.\nIf the query parameter `returnOld` is `true`, then\nthe complete previous revision of the document\nis returned under the `old` attribute in the result.\nIf the query parameter `returnNew` is `true`, then\nthe complete new document is returned under\nthe `new` attribute in the result.\nIf the document does not exist, then a *HTTP 404* is returned and the\nbody of the response contains an error document.\n", "operationId": "replaceDocument", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"document": {"type": "object", "description": "A JSON representation of a single document.\n"}}, "required": ["document"]}}}}, "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the `collection` in which the document is to be replaced.\n", "in": "path"}, {"name": "key", "schema": {"type": "string"}, "required": true, "description": "The document key.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until document has been synced to disk.\n", "in": "query"}, {"name": "ignoreRevs", "schema": {"type": "boolean"}, "required": false, "description": "By default, or if this is set to `true`, the `_rev` attributes in\nthe given document is ignored. If this is set to `false`, then\nthe `_rev` attribute given in the body document is taken as a\nprecondition. The document is only replaced if the current revision\nis the one specified.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete previous revision of the changed\ndocument under the attribute `old` in the result.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete new document under the attribute `new`\nin the result.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if the document operation\nsucceeds. No meta-data is returned for the replaced document. If the\noperation raises an error, an error object is returned.\nYou can use this option to save network traffic.\n", "in": "query"}, {"name": "If-Match", "schema": {"type": "string"}, "required": false, "description": "You can conditionally replace a document based on a target revision id by\nusing the `if-match` HTTP header.\n", "in": "header"}], "responses": {"201": {"description": "is returned if the document was replaced successfully and\n`waitForSync` was `true`.\n"}, "202": {"description": "is returned if the document was replaced successfully and\n`waitForSync` was `false`.\n"}, "400": {"description": "is returned if the body does not contain a valid JSON representation\nof a document. The response body contains\nan error document in this case.\n"}, "404": {"description": "is returned if the collection or the document was not found.\n"}, "409": {"description": "\nis returned if the replace causes a unique constraint violation in \na secondary index.\n"}, "412": {"description": "is returned if the precondition is violated. The response also contains\nthe found documents' current revisions in the `_rev` attributes.\nAdditionally, the attributes `_id` and `_key` are returned.\n"}}, "tags": ["Documents"]}, "patch": {"description": "Partially updates the document identified by the *document ID*.\nThe body of the request must contain a JSON document with the\nattributes to patch (the patch document). All attributes from the\npatch document are added to the existing document if they do not\nyet exist, and overwritten in the existing document if they do exist\nthere.\nThe value of the `_key` attribute as well as attributes\nused as sharding keys may not be changed.\nSetting an attribute value to `null` in the patch document causes a\nvalue of `null` to be saved for the attribute by default.\nIf the `If-Match` header is specified and the revision of the\ndocument in the database is unequal to the given revision, the\nprecondition is violated.\nIf `If-Match` is not given and `ignoreRevs` is `false` and there\nis a `_rev` attribute in the body and its value does not match\nthe revision of the document in the database, the precondition is\nviolated.\nIf a precondition is violated, an *HTTP 412* is returned.\nIf the document exists and can be updated, then an *HTTP 201* or\nan *HTTP 202* is returned (depending on `waitForSync`, see below),\nthe `Etag` header field contains the new revision of the document\n(in double quotes) and the `Location` header contains a complete URL\nunder which the document can be queried.\nCluster only: The patch document _may_ contain\nvalues for the collection's pre-defined shard keys. Values for the shard keys\nare treated as hints to improve performance. Should the shard keys\nvalues be incorrect ArangoDB may answer with a `not found` error\nOptionally, the query parameter `waitForSync` can be used to force\nsynchronization of the updated document operation to disk even in case\nthat the `waitForSync` flag had been disabled for the entire collection.\nThus, the `waitForSync` query parameter can be used to force synchronization\nof just specific operations. To use this, set the `waitForSync` parameter\nto `true`. If the `waitForSync` parameter is not specified or set to\n`false`, then the collection's default `waitForSync` behavior is\napplied. The `waitForSync` query parameter cannot be used to disable\nsynchronization for collections that have a default `waitForSync` value\nof `true`.\nIf `silent` is not set to `true`, the body of the response contains a JSON\nobject with the information about the identifier and the revision. The attribute\n`_id` contains the known *document ID* of the updated document, `_key`\ncontains the key which uniquely identifies a document in a given collection,\nand the attribute `_rev` contains the new document revision.\nIf the query parameter `returnOld` is `true`, then\nthe complete previous revision of the document\nis returned under the `old` attribute in the result.\nIf the query parameter `returnNew` is `true`, then\nthe complete new document is returned under\nthe `new` attribute in the result.\nIf the document does not exist, then a *HTTP 404* is returned and the\nbody of the response contains an error document.\n", "operationId": "updateDocument", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"document": {"type": "object", "description": "A JSON representation of a document update as an object.\n"}}, "required": ["document"]}}}}, "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the `collection` in which the document is to be updated.\n", "in": "path"}, {"name": "key", "schema": {"type": "string"}, "required": true, "description": "The document key.\n", "in": "path"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "If the intention is to delete existing attributes with the patch\ncommand, the URL query parameter `keepNull` can be used with a value\nof `false`. This modifies the behavior of the patch command to\nremove any attributes from the existing document that are contained\nin the patch document with an attribute value of `null`.\n", "in": "query"}, {"name": "mergeObjects", "schema": {"type": "boolean"}, "required": false, "description": "Controls whether objects (not arrays) are merged if present in\nboth the existing and the patch document. If set to `false`, the\nvalue in the patch document overwrites the existing document's\nvalue. If set to `true`, objects are merged. The default is\n`true`.\n", "in": "query"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until document has been synced to disk.\n", "in": "query"}, {"name": "ignoreRevs", "schema": {"type": "boolean"}, "required": false, "description": "By default, or if this is set to `true`, the `_rev` attributes in\nthe given document is ignored. If this is set to `false`, then\nthe `_rev` attribute given in the body document is taken as a\nprecondition. The document is only updated if the current revision\nis the one specified.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete previous revision of the changed\ndocument under the attribute `old` in the result.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete new document under the attribute `new`\nin the result.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if the document operation\nsucceeds. No meta-data is returned for the updated document. If the\noperation raises an error, an error object is returned.\nYou can use this option to save network traffic.\n", "in": "query"}, {"name": "If-Match", "schema": {"type": "string"}, "required": false, "description": "You can conditionally update a document based on a target revision id by\nusing the `if-match` HTTP header.\n", "in": "header"}], "responses": {"201": {"description": "is returned if the document was updated successfully and\n`waitForSync` was `true`.\n"}, "202": {"description": "is returned if the document was updated successfully and\n`waitForSync` was `false`.\n"}, "400": {"description": "is returned if the body does not contain a valid JSON representation\nof a document. The response body contains\nan error document in this case.\n"}, "404": {"description": "is returned if the collection or the document was not found.\n"}, "409": {"description": "\nis returned if the update causes a unique constraint violation in \na secondary index.\n"}, "412": {"description": "is returned if the precondition was violated. The response also contains\nthe found documents' current revisions in the `_rev` attributes.\nAdditionally, the attributes `_id` and `_key` are returned.\n"}}, "tags": ["Documents"]}, "delete": {"description": "If `silent` is not set to `true`, the body of the response contains a JSON\nobject with the information about the identifier and the revision. The attribute\n`_id` contains the known *document ID* of the removed document, `_key`\ncontains the key which uniquely identifies a document in a given collection,\nand the attribute `_rev` contains the document revision.\nIf the `waitForSync` parameter is not specified or set to `false`,\nthen the collection's default `waitForSync` behavior is applied.\nThe `waitForSync` query parameter cannot be used to disable\nsynchronization for collections that have a default `waitForSync`\nvalue of `true`.\nIf the query parameter `returnOld` is `true`, then\nthe complete previous revision of the document\nis returned under the `old` attribute in the result.\n", "operationId": "removeDocument", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the `collection` in which the document is to be deleted.\n", "in": "path"}, {"name": "key", "schema": {"type": "string"}, "required": true, "description": "The document key.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until deletion operation has been synced to disk.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete previous revision of the changed\ndocument under the attribute `old` in the result.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if the document operation\nsucceeds. No meta-data is returned for the deleted document. If the\noperation raises an error, an error object is returned.\nYou can use this option to save network traffic.\n", "in": "query"}, {"name": "If-Match", "schema": {"type": "string"}, "required": false, "description": "You can conditionally remove a document based on a target revision id by\nusing the `if-match` HTTP header.\n", "in": "header"}], "responses": {"200": {"description": "is returned if the document was removed successfully and\n`waitForSync` was `true`.\n"}, "202": {"description": "is returned if the document was removed successfully and\n`waitForSync` was `false`.\n"}, "404": {"description": "is returned if the collection or the document was not found.\nThe response body contains an error document in this case.\n"}, "412": {"description": "is returned if a \"If-Match\" header or `rev` is given and the found\ndocument has a different version. The response also contain the found\ndocument's current revision in the `_rev` attribute. Additionally, the\nattributes `_id` and `_key` are returned.\n"}}, "tags": ["Documents"]}}, "/_api/document/{collection}": {"post": {"description": "Creates a new document from the document given in the body, unless there\nis already a document with the `_key` given. If no `_key` is given, a new\nunique `_key` is generated automatically.\nPossibly given `_id` and `_rev` attributes in the body are always ignored,\nthe URL part or the query parameter collection respectively counts.\nIf the document was created successfully, then the `Location` header\ncontains the path to the newly created document. The `Etag` header field\ncontains the revision of the document. Both are only set in the single\ndocument case.\nIf `silent` is not set to `true`, the body of the response contains a\nJSON object with the following attributes:\n  - `_id` contains the document identifier of the newly created document\n  - `_key` contains the document key\n  - `_rev` contains the document revision\nIf the collection parameter `waitForSync` is `false`, then the call\nreturns as soon as the document has been accepted. It does not wait\nuntil the documents have been synced to disk.\nOptionally, the query parameter `waitForSync` can be used to force\nsynchronization of the document creation operation to disk even in\ncase that the `waitForSync` flag had been disabled for the entire\ncollection. Thus, the `waitForSync` query parameter can be used to\nforce synchronization of just this specific operations. To use this,\nset the `waitForSync` parameter to `true`. If the `waitForSync`\nparameter is not specified or set to `false`, then the collection's\ndefault `waitForSync` behavior is applied. The `waitForSync` query\nparameter cannot be used to disable synchronization for collections\nthat have a default `waitForSync` value of `true`.\nIf the query parameter `returnNew` is `true`, then, for each\ngenerated document, the complete new document is returned under\nthe `new` attribute in the result.\n", "operationId": "insertDocument", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the `collection` in which the document is to be created.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": false, "description": "The name of the collection. This query parameter is only for backward compatibility.\nIn ArangoDB versions < 3.0, the URL path was `/_api/document` and\nthis query parameter was required. This combination still works, but\nthe recommended way is to specify the collection in the URL path.\n", "in": "query"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until document has been synced to disk.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Additionally return the complete new document under the attribute `new`\nin the result.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Additionally return the complete old document under the attribute `old`\nin the result. Only available if the overwrite option is used.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if the document operation\nsucceeds. No meta-data is returned for the created document. If the\noperation raises an error, an error object is returned.\nYou can use this option to save network traffic.\n", "in": "query"}, {"name": "overwrite", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, the insert becomes a replace-insert. If a document with the\nsame `_key` already exists, the new document is not rejected with unique\nconstraint violation error but replaces the old document. Note that operations\nwith `overwrite` parameter require a `_key` attribute in the request payload,\ntherefore they can only be performed on collections sharded by `_key`.\n", "in": "query"}, {"name": "overwriteMode", "schema": {"type": "string"}, "required": false, "description": "This option supersedes `overwrite` and offers the following modes\n- `\"ignore\"` if a document with the specified `_key` value exists already,\n  nothing is done and no write operation is carried out. The\n  insert operation returns success in this case. This mode does not\n  support returning the old document version using `RETURN OLD`. When using\n  `RETURN NEW`, `null` is returned in case the document already existed.\n- `\"replace\"` if a document with the specified `_key` value exists already,\n  it is overwritten with the specified document value. This mode is\n  also used when no overwrite mode is specified but the `overwrite`\n  flag is set to `true`.\n- `\"update\"` if a document with the specified `_key` value exists already,\n  it is patched (partially updated) with the specified document value.\n  The overwrite mode can be further controlled via the `keepNull` and\n  `mergeObjects` parameters.\n- `\"conflict\"` if a document with the specified `_key` value exists already,\n  return a unique constraint violation error so that the insert operation\n  fails. This is also the default behavior in case the overwrite mode is\n  not set, and the `overwrite` flag is `false` or not set either.\n", "in": "query"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "If the intention is to delete existing attributes with the update-insert\ncommand, the URL query parameter `keepNull` can be used with a value of\n`false`. This modifies the behavior of the patch command to remove any\nattributes from the existing document that are contained in the patch document\nwith an attribute value of `null`.\nThis option controls the update-insert behavior only.\n", "in": "query"}, {"name": "mergeObjects", "schema": {"type": "boolean"}, "required": false, "description": "Controls whether objects (not arrays) are merged if present in both, the\nexisting and the update-insert document. If set to `false`, the value in the\npatch document overwrites the existing document's value. If set to `true`,\nobjects are merged. The default is `true`.\nThis option controls the update-insert behavior only.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "object", "description": "A JSON representation of a single document.\n"}}, "required": ["data"]}}}}, "responses": {"201": {"description": "is returned if the documents were created successfully and\n`waitForSync` was `true`.\n"}, "202": {"description": "is returned if the documents were created successfully and\n`waitForSync` was `false`.\n"}, "400": {"description": "is returned if the body does not contain a valid JSON representation\nof one document. The response body contains\nan error document in this case.\n"}, "404": {"description": "is returned if the collection specified by `collection` is unknown.\nThe response body contains an error document in this case.\n"}, "409": {"description": "is returned in the single document case if a document with the\nsame qualifiers in an indexed attribute conflicts with an already\nexisting document and thus violates that unique constraint. The\nresponse body contains an error document in this case.\n"}}, "tags": ["Documents"]}, "put": {"description": "Replaces multiple documents in the specified collection with the\nones in the body, the replaced documents are specified by the `_key`\nattributes in the body documents.\nThe value of the `_key` attribute as well as attributes\nused as sharding keys may not be changed.\nIf `ignoreRevs` is `false` and there is a `_rev` attribute in a\ndocument in the body and its value does not match the revision of\nthe corresponding document in the database, the precondition is\nviolated.\nCluster only: The replace documents _may_ contain\nvalues for the collection's pre-defined shard keys. Values for the shard keys\nare treated as hints to improve performance. Should the shard keys\nvalues be incorrect ArangoDB may answer with a `not found` error.\nOptionally, the query parameter `waitForSync` can be used to force\nsynchronization of the document replacement operation to disk even in case\nthat the `waitForSync` flag had been disabled for the entire collection.\nThus, the `waitForSync` query parameter can be used to force synchronization\nof just specific operations. To use this, set the `waitForSync` parameter\nto `true`. If the `waitForSync` parameter is not specified or set to\n`false`, then the collection's default `waitForSync` behavior is\napplied. The `waitForSync` query parameter cannot be used to disable\nsynchronization for collections that have a default `waitForSync` value\nof `true`.\nThe body of the response contains a JSON array of the same length\nas the input array with the information about the identifier and the\nrevision of the replaced documents. In each entry, the attribute\n`_id` contains the known `document-id` of each updated document,\n`_key` contains the key which uniquely identifies a document in a\ngiven collection, and the attribute `_rev` contains the new document\nrevision. In case of an error or violated precondition, an error\nobject with the attribute `error` set to `true` and the attribute\n`errorCode` set to the error code is built.\nIf the query parameter `returnOld` is `true`, then, for each\ngenerated document, the complete previous revision of the document\nis returned under the `old` attribute in the result.\nIf the query parameter `returnNew` is `true`, then, for each\ngenerated document, the complete new document is returned under\nthe `new` attribute in the result.\nNote that if any precondition is violated or an error occurred with\nsome of the documents, the return code is still 201 or 202, but\nthe additional HTTP header `X-Arango-Error-Codes` is set, which\ncontains a map of the error codes that occurred together with their\nmultiplicities, as in: `1200:17,1205:10` which means that in 17\ncases the error 1200 \"revision conflict\" and in 10 cases the error\n1205 \"illegal document handle\" has happened.\n", "operationId": "replaceDocuments", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"documents": {"type": "object", "description": "A JSON representation of an array of documents.\n"}}, "required": ["documents"]}}}}, "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "This URL parameter is the name of the collection in which the\ndocuments are replaced.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until the new documents have been synced to disk.\n", "in": "query"}, {"name": "ignoreRevs", "schema": {"type": "boolean"}, "required": false, "description": "By default, or if this is set to `true`, the `_rev` attributes in\nthe given documents are ignored. If this is set to `false`, then\nany `_rev` attribute given in a body document is taken as a\nprecondition. The document is only replaced if the current revision\nis the one specified.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete previous revision of the changed\ndocuments under the attribute `old` in the result.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete new documents under the attribute `new`\nin the result.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if all document operations\nsucceed. No meta-data is returned for the replaced documents. If at least one\noperation raises an error, an array with the error object(s) is returned.\nYou can use this option to save network traffic but you cannot map any errors\nto the inputs of your request.\n", "in": "query"}], "responses": {"201": {"description": "is returned if `waitForSync` was `true` and operations were processed.\n"}, "202": {"description": "is returned if `waitForSync` was `false` and operations were processed.\n"}, "400": {"description": "is returned if the body does not contain a valid JSON representation\nof an array of documents. The response body contains\nan error document in this case.\n"}, "404": {"description": "is returned if the collection was not found.\n"}}, "tags": ["Documents"]}, "patch": {"description": "Partially updates documents, the documents to update are specified\nby the `_key` attributes in the body objects. The body of the\nrequest must contain a JSON array of document updates with the\nattributes to patch (the patch documents). All attributes from the\npatch documents are added to the existing documents if they do\nnot yet exist, and overwritten in the existing documents if they do\nexist there.\nThe value of the `_key` attribute as well as attributes\nused as sharding keys may not be changed.\nSetting an attribute value to `null` in the patch documents causes a\nvalue of `null` to be saved for the attribute by default.\nIf `ignoreRevs` is `false` and there is a `_rev` attribute in a\ndocument in the body and its value does not match the revision of\nthe corresponding document in the database, the precondition is\nviolated.\nCluster only: The patch document _may_ contain\nvalues for the collection's pre-defined shard keys. Values for the shard keys\nare treated as hints to improve performance. Should the shard keys\nvalues be incorrect ArangoDB may answer with a *not found* error\nOptionally, the query parameter `waitForSync` can be used to force\nsynchronization of the document replacement operation to disk even in case\nthat the `waitForSync` flag had been disabled for the entire collection.\nThus, the `waitForSync` query parameter can be used to force synchronization\nof just specific operations. To use this, set the `waitForSync` parameter\nto `true`. If the `waitForSync` parameter is not specified or set to\n`false`, then the collection's default `waitForSync` behavior is\napplied. The `waitForSync` query parameter cannot be used to disable\nsynchronization for collections that have a default `waitForSync` value\nof `true`.\nThe body of the response contains a JSON array of the same length\nas the input array with the information about the identifier and the\nrevision of the updated documents. In each entry, the attribute\n`_id` contains the known *document ID* of each updated document,\n`_key` contains the key which uniquely identifies a document in a\ngiven collection, and the attribute `_rev` contains the new document\nrevision. In case of an error or violated precondition, an error\nobject with the attribute `error` set to `true` and the attribute\n`errorCode` set to the error code is built.\nIf the query parameter `returnOld` is `true`, then, for each\ngenerated document, the complete previous revision of the document\nis returned under the `old` attribute in the result.\nIf the query parameter `returnNew` is `true`, then, for each\ngenerated document, the complete new document is returned under\nthe `new` attribute in the result.\nNote that if any precondition is violated or an error occurred with\nsome of the documents, the return code is still 201 or 202, but\nthe additional HTTP header `X-Arango-Error-Codes` is set, which\ncontains a map of the error codes that occurred together with their\nmultiplicities, as in: `1200:17,1205:10` which means that in 17\ncases the error 1200 \"revision conflict\" and in 10 cases the error\n1205 \"illegal document handle\" has happened.\n", "operationId": "updateDocuments", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"documents": {"type": "object", "description": "A JSON representation of an array of document updates as objects.\n"}}, "required": ["documents"]}}}}, "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the `collection` in which the documents are to be updated.\n", "in": "path"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "If the intention is to delete existing attributes with the patch\ncommand, the URL query parameter `keepNull` can be used with a value\nof `false`. This modifies the behavior of the patch command to\nremove any attributes from the existing document that are contained\nin the patch document with an attribute value of `null`.\n", "in": "query"}, {"name": "mergeObjects", "schema": {"type": "boolean"}, "required": false, "description": "Controls whether objects (not arrays) are merged if present in\nboth the existing and the patch document. If set to `false`, the\nvalue in the patch document overwrites the existing document's\nvalue. If set to `true`, objects are merged. The default is\n`true`.\n", "in": "query"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until the new documents have been synced to disk.\n", "in": "query"}, {"name": "ignoreRevs", "schema": {"type": "boolean"}, "required": false, "description": "By default, or if this is set to `true`, the `_rev` attributes in\nthe given documents are ignored. If this is set to `false`, then\nany `_rev` attribute given in a body document is taken as a\nprecondition. The document is only updated if the current revision\nis the one specified.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete previous revision of the changed\ndocuments under the attribute `old` in the result.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete new documents under the attribute `new`\nin the result.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if all document operations\nsucceed. No meta-data is returned for the updated documents. If at least one\noperation raises an error, an array with the error object(s) is returned.\nYou can use this option to save network traffic but you cannot map any errors\nto the inputs of your request.\n", "in": "query"}], "responses": {"201": {"description": "is returned if `waitForSync` was `true` and operations were processed.\n"}, "202": {"description": "is returned if `waitForSync` was `false` and operations were processed.\n"}, "400": {"description": "is returned if the body does not contain a valid JSON representation\nof an array of documents. The response body contains\nan error document in this case.\n"}, "404": {"description": "is returned if the collection was not found.\n"}}, "tags": ["Documents"]}, "delete": {"description": "The body of the request is an array consisting of selectors for\ndocuments. A selector can either be a string with a key or a string\nwith a document identifier or an object with a `_key` attribute. This\nAPI call removes all specified documents from `collection`.\nIf the `ignoreRevs` query parameter is `false` and the\nselector is an object and has a `_rev` attribute, it is a\nprecondition that the actual revision of the removed document in the\ncollection is the specified one.\nThe body of the response is an array of the same length as the input\narray. For each input selector, the output contains a JSON object\nwith the information about the outcome of the operation. If no error\noccurred, an object is built in which the attribute `_id` contains\nthe known *document ID* of the removed document, `_key` contains\nthe key which uniquely identifies a document in a given collection,\nand the attribute `_rev` contains the document revision. In case of\nan error, an object with the attribute `error` set to `true` and\n`errorCode` set to the error code is built.\nIf the `waitForSync` parameter is not specified or set to `false`,\nthen the collection's default `waitForSync` behavior is applied.\nThe `waitForSync` query parameter cannot be used to disable\nsynchronization for collections that have a default `waitForSync`\nvalue of `true`.\nIf the query parameter `returnOld` is `true`, then\nthe complete previous revision of the document\nis returned under the `old` attribute in the result.\nNote that if any precondition is violated or an error occurred with\nsome of the documents, the return code is still 200 or 202, but\nthe additional HTTP header `X-Arango-Error-Codes` is set, which\ncontains a map of the error codes that occurred together with their\nmultiplicities, as in: `1200:17,1205:10` which means that in 17\ncases the error 1200 \"revision conflict\" and in 10 cases the error\n1205 \"illegal document handle\" has happened.\n", "operationId": "removeDocuments", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"array": {"type": "object", "description": "A JSON array of strings or documents.\n"}}, "required": ["array"]}}}}, "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Collection from which documents are removed.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until deletion operation has been synced to disk.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Return additionally the complete previous revision of the changed\ndocument under the attribute `old` in the result.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if all document operations\nsucceed. No meta-data is returned for the deleted documents. If at least one of\nthe operations raises an error, an array with the error object(s) is returned.\nYou can use this option to save network traffic but you cannot map any errors\nto the inputs of your request.\n", "in": "query"}, {"name": "ignoreRevs", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, ignore any `_rev` attribute in the selectors. No\nrevision check is performed. If set to `false` then revisions are checked.\nThe default is `true`.\n", "in": "query"}], "responses": {"200": {"description": "is returned if `waitForSync` was `true`.\n"}, "202": {"description": "is returned if `waitForSync` was `false`.\n"}, "404": {"description": "is returned if the collection was not found.\nThe response body contains an error document in this case.\n"}}, "tags": ["Documents"]}}, "/_api/document/{collection}#get": {"put": {"description": "Returns the documents identified by their *_key* in the body objects.\nThe body of the request _must_ contain a JSON array of either\nstrings (the *_key* values to lookup) or search documents.\nA search document _must_ contain at least a value for the *_key* field.\nA value for `_rev` _may_ be specified to verify whether the document\nhas the same revision value, unless _ignoreRevs_ is set to false.\nCluster only: The search document _may_ contain\nvalues for the collection's pre-defined shard keys. Values for the shard keys\nare treated as hints to improve performance. Should the shard keys\nvalues be incorrect ArangoDB may answer with a *not found* error.\nThe returned array of documents contain three special attributes: *_id* containing the document\nidentifier, *_key* containing key which uniquely identifies a document\nin a given collection and *_rev* containing the revision.\n", "operationId": "readDocuments", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the *collection* from which the documents are to be read.\n", "in": "path"}, {"name": "onlyget", "schema": {"type": "boolean"}, "required": true, "description": "This parameter is required to be **true**, otherwise a replace\noperation is executed!\n", "in": "query"}, {"name": "ignoreRevs", "schema": {"type": "string"}, "required": false, "description": "Should the value be *true* (the default)\nIf a search document contains a value for the *_rev* field,\nthen the document is only returned if it has the same revision value.\nOtherwise a precondition failed error is returned.\n", "in": "query"}, {"name": "x-arango-allow-dirty-read", "schema": {"type": "boolean"}, "required": false, "description": "Set this header to `true` to allow the Coordinator to ask any shard replica for\nthe data, not only the shard leader. This may result in \"dirty reads\".\nThe header is ignored if this operation is part of a Stream Transaction\n(`x-arango-trx-id` header). The header set when creating the transaction decides\nabout dirty reads for the entire transaction, not the individual read operations.\n", "in": "header"}, {"name": "x-arango-trx-id", "schema": {"type": "string"}, "required": false, "description": "To make this operation a part of a Stream Transaction, set this header to the\ntransaction ID returned by the `POST /_api/transaction/begin` call.\n", "in": "header"}], "responses": {"200": {"description": "is returned if no error happened\n"}, "400": {"description": "is returned if the body does not contain a valid JSON representation\nof an array of documents. The response body contains\nan error document in this case.\n"}, "404": {"description": "is returned if the collection was not found.\n"}}, "tags": ["Documents"]}}, "/_api/document/{collection}#multiple": {"post": {"description": "Creates new documents from the documents given in the body, unless there\nis already a document with the `_key` given. If no `_key` is given, a new\nunique `_key` is generated automatically.\nThe result body contains a JSON array of the\nsame length as the input array, and each entry contains the result\nof the operation for the corresponding input. In case of an error\nthe entry is a document with attributes `error` set to `true` and\nerrorCode set to the error code that has happened.\nPossibly given `_id` and `_rev` attributes in the body are always ignored,\nthe URL part or the query parameter collection respectively counts.\nIf `silent` is not set to `true`, the body of the response contains an\narray of JSON objects with the following attributes:\n  - `_id` contains the document identifier of the newly created document\n  - `_key` contains the document key\n  - `_rev` contains the document revision\nIf the collection parameter `waitForSync` is `false`, then the call\nreturns as soon as the documents have been accepted. It does not wait\nuntil the documents have been synced to disk.\nOptionally, the query parameter `waitForSync` can be used to force\nsynchronization of the document creation operation to disk even in\ncase that the `waitForSync` flag had been disabled for the entire\ncollection. Thus, the `waitForSync` query parameter can be used to\nforce synchronization of just this specific operations. To use this,\nset the `waitForSync` parameter to `true`. If the `waitForSync`\nparameter is not specified or set to `false`, then the collection's\ndefault `waitForSync` behavior is applied. The `waitForSync` query\nparameter cannot be used to disable synchronization for collections\nthat have a default `waitForSync` value of `true`.\nIf the query parameter `returnNew` is `true`, then, for each\ngenerated document, the complete new document is returned under\nthe `new` attribute in the result.\nShould an error have occurred with some of the documents\nthe additional HTTP header `X-Arango-Error-Codes` is set, which\ncontains a map of the error codes that occurred together with their\nmultiplicities, as in: `1205:10,1210:17` which means that in 10\ncases the error 1205 \"illegal document handle\" and in 17 cases the\nerror 1210 \"unique constraint violated\" has happened.\n", "operationId": "insertDocuments", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "Name of the `collection` in which the documents are to be created.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": false, "description": "The name of the collection. This is only for backward compatibility.\nIn ArangoDB versions < 3.0, the URL path was `/_api/document` and\nthis query parameter was required. This combination still works, but\nthe recommended way is to specify the collection in the URL path.\n", "in": "query"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until document has been synced to disk.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Additionally return the complete new document under the attribute `new`\nin the result.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Additionally return the complete old document under the attribute `old`\nin the result. Only available if the overwrite option is used.\n", "in": "query"}, {"name": "silent", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, an empty object is returned as response if all document operations\nsucceed. No meta-data is returned for the created documents. If any of the\noperations raises an error, an array with the error object(s) is returned.\nYou can use this option to save network traffic but you cannot map any errors\nto the inputs of your request.\n", "in": "query"}, {"name": "overwrite", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true`, the insert becomes a replace-insert. If a document with the\nsame `_key` already exists, the new document is not rejected with a unique\nconstraint violation error but replaces the old document. Note that operations\nwith `overwrite` parameter require a `_key` attribute in the request payload,\ntherefore they can only be performed on collections sharded by `_key`.\n", "in": "query"}, {"name": "overwriteMode", "schema": {"type": "string"}, "required": false, "description": "This option supersedes `overwrite` and offers the following modes\n- `\"ignore\"` if a document with the specified `_key` value exists already,\n  nothing is done and no write operation is carried out. The\n  insert operation returns success in this case. This mode does not\n  support returning the old document version using `RETURN OLD`. When using\n  `RETURN NEW`, `null` is returned in case the document already existed.\n- `\"replace\"` if a document with the specified `_key` value exists already,\n  it is overwritten with the specified document value. This mode is\n  also used when no overwrite mode is specified but the `overwrite`\n  flag is set to `true`.\n- `\"update\"` if a document with the specified `_key` value exists already,\n  it is patched (partially updated) with the specified document value.\n  The overwrite mode can be further controlled via the `keepNull` and\n  `mergeObjects` parameters.\n- `\"conflict\"` if a document with the specified `_key` value exists already,\n  return a unique constraint violation error so that the insert operation\n  fails. This is also the default behavior in case the overwrite mode is\n  not set, and the `overwrite` flag is `false` or not set either.\n", "in": "query"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "If the intention is to delete existing attributes with the update-insert\ncommand, the URL query parameter `keepNull` can be used with a value of\n`false`. This modifies the behavior of the patch command to remove any\nattributes from the existing document that are contained in the patch document\nwith an attribute value of `null`.\nThis option controls the update-insert behavior only.\n", "in": "query"}, {"name": "mergeObjects", "schema": {"type": "boolean"}, "required": false, "description": "Controls whether objects (not arrays) are merged if present in both, the\nexisting and the update-insert document. If set to `false`, the value in the\npatch document overwrites the existing document's value. If set to `true`,\nobjects are merged. The default is `true`.\nThis option controls the update-insert behavior only.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "object", "description": "An array of documents to create.\n"}}, "required": ["data"]}}}}, "responses": {"201": {"description": "is returned if `waitForSync` was `true` and operations were processed.\n"}, "202": {"description": "is returned if `waitForSync` was `false` and operations were processed.\n"}, "400": {"description": "is returned if the body does not contain a valid JSON representation\nof an array of documents. The response body contains\nan error document in this case.\n"}, "404": {"description": "is returned if the collection specified by `collection` is unknown.\nThe response body contains an error document in this case.\n"}}, "tags": ["Documents"]}}, "/_api/edges/{collection-id}": {"get": {"description": "Returns an array of edges starting or ending in the vertex identified by\n*vertex*.\n", "parameters": [{"name": "collection-id", "schema": {"type": "string"}, "required": true, "description": "The id of the collection.\n", "in": "path"}, {"name": "vertex", "schema": {"type": "string"}, "required": true, "description": "The id of the start vertex.\n", "in": "query"}, {"name": "direction", "schema": {"type": "string"}, "required": false, "description": "Selects *in* or *out* direction for edges. If not set, any edges are\nreturned.\n", "in": "query"}, {"name": "x-arango-allow-dirty-read", "schema": {"type": "boolean"}, "required": false, "description": "Set this header to `true` to allow the Coordinator to ask any shard replica for\nthe data, not only the shard leader. This may result in \"dirty reads\".\n", "in": "header"}], "responses": {"200": {"description": "is returned if the edge collection was found and edges were retrieved.\n"}, "400": {"description": "is returned if the request contains invalid parameters.\n"}, "404": {"description": "is returned if the edge collection was not found.\n"}}, "tags": ["Graph Edges"]}}, "/_api/batch": {"post": {"description": "Executes a batch request. A batch request can contain any number of\nother requests that can be sent to ArangoDB in isolation. The benefit of\nusing batch requests is that batching requests requires less client/server\nroundtrips than when sending isolated requests.\nAll parts of a batch request are executed serially on the server. The\nserver will return the results of all parts in a single response when all\nparts are finished.\nTechnically, a batch request is a multipart HTTP request, with\ncontent-type `multipart/form-data`. A batch request consists of an\nenvelope and the individual batch part actions. Batch part actions\nare \"regular\" HTTP requests, including full header and an optional body.\nMultiple batch parts are separated by a boundary identifier. The\nboundary identifier is declared in the batch envelope. The MIME content-type\nfor each individual batch part must be `application/x-arango-batchpart`.\nPlease note that when constructing the individual batch parts, you must\nuse CRLF (`\\r\\n`) as the line terminator as in regular HTTP messages.\nThe response sent by the server will be an `HTTP 200` response, with an\noptional error summary header `x-arango-errors`. This header contains the\nnumber of batch part operations that failed with an HTTP error code of at\nleast 400. This header is only present in the response if the number of\nerrors is greater than zero.\nThe response sent by the server is a multipart response, too. It contains\nthe individual HTTP responses for all batch parts, including the full HTTP\nresult header (with status code and other potential headers) and an\noptional result body. The individual batch parts in the result are\nseperated using the same boundary value as specified in the request.\nThe order of batch parts in the response will be the same as in the\noriginal client request. Client can additionally use the `Content-Id`\nMIME header in a batch part to define an individual id for each batch part.\nThe server will return this id is the batch part responses, too.\n", "operationId": " RestBatchHandler", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"body": {"type": "string", "description": "The multipart batch request, consisting of the envelope and the individual\nbatch parts.\n"}}, "required": ["body"]}}}}, "responses": {"200": {"description": "is returned if the batch was received successfully. HTTP 200 is returned\neven if one or multiple batch part actions failed.\n"}, "400": {"description": "is returned if the batch envelope is malformed or incorrectly formatted.\nThis code will also be returned if the content-type of the overall batch\nrequest or the individual MIME parts is not as expected.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}}, "tags": ["Bulk"]}}, "/_api/import#document": {"post": {"description": "Creates documents in the collection identified by `collection-name`.\nThe first line of the request body must contain a JSON-encoded array of\nattribute names. All following lines in the request body must contain\nJSON-encoded arrays of attribute values. Each line is interpreted as a\nseparate document, and the values specified will be mapped to the array\nof attribute names specified in the first header line.\nThe response is a JSON object with the following attributes:\n- `created`: number of documents imported.\n- `errors`: number of documents that were not imported due to an error.\n- `empty`: number of empty lines found in the input (will only contain a\n  value greater zero for types `documents` or `auto`).\n- `updated`: number of updated/replaced documents (in case `onDuplicate`\n  was set to either `update` or `replace`).\n- `ignored`: number of failed but ignored insert operations (in case\n  `onDuplicate` was set to `ignore`).\n- `details`: if query parameter `details` is set to true, the result will\n  contain a `details` attribute which is an array with more detailed\n  information about which documents could not be inserted.\n", "operationId": " RestImportHandler#document", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"documents": {"type": "string", "description": "The body must consist of JSON-encoded arrays of attribute values, with one\nline per document. The first row of the request must be a JSON-encoded\narray of attribute names. These attribute names are used for the data in the\nsubsequent lines.\n"}}, "required": ["documents"]}}}}, "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}, {"name": "fromPrefix", "schema": {"type": "string"}, "required": false, "description": "An optional prefix for the values in `_from` attributes. If specified, the\nvalue is automatically prepended to each `_from` input value. This allows\nspecifying just the keys for `_from`.\n", "in": "query"}, {"name": "toPrefix", "schema": {"type": "string"}, "required": false, "description": "An optional prefix for the values in `_to` attributes. If specified, the\nvalue is automatically prepended to each `_to` input value. This allows\nspecifying just the keys for `_to`.\n", "in": "query"}, {"name": "overwrite", "schema": {"type": "boolean"}, "required": false, "description": "If this parameter has a value of `true` or `yes`, then all data in the\ncollection will be removed prior to the import. Note that any existing\nindex definitions will be preserved.\n", "in": "query"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until documents have been synced to disk before returning.\n", "in": "query"}, {"name": "onDuplicate", "schema": {"type": "string"}, "required": false, "description": "Controls what action is carried out in case of a unique key constraint\nviolation. Possible values are\n- `error` this will not import the current document because of the unique\n  key constraint violation. This is the default setting.\n- `update` this will update an existing document in the database with the\n  data specified in the request. Attributes of the existing document that\n  are not present in the request will be preserved.\n- `replace` this will replace an existing document in the database with the\n  data specified in the request.\n- `ignore` this will not update an existing document and simply ignore the\n  error caused by the unique key constraint violation.\nNote that `update`, `replace` and `ignore` will only work when the\nimport document in the request contains the `_key` attribute. `update` and\n`replace` may also fail because of secondary unique key constraint\nviolations.\n", "in": "query"}, {"name": "complete", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true` or `yes`, it will make the whole import fail if any error\noccurs. Otherwise the import will continue even if some documents cannot\nbe imported.\n", "in": "query"}, {"name": "details", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true` or `yes`, the result will include an attribute `details`\nwith details about documents that could not be imported.\n", "in": "query"}], "responses": {"201": {"description": "is returned if all documents could be imported successfully.\n"}, "400": {"description": "is returned if `type` contains an invalid value, no `collection` is\nspecified, the documents are incorrectly encoded, or the request\nis malformed.\n"}, "404": {"description": "is returned if `collection` or the `_from` or `_to` attributes of an\nimported edge refer to an unknown collection.\n"}, "409": {"description": "is returned if the import would trigger a unique key violation and\n`complete` is set to `true`.\n"}, "500": {"description": "is returned if the server cannot auto-generate a document key (out of keys\nerror) for a document with no user-defined key.\n"}}, "tags": ["Bulk"]}}, "/_api/import#json": {"post": {"description": "Creates documents in the collection identified by `collection-name`.\nThe JSON representations of the documents must be passed as the body of the\nPOST request. The request body can either consist of multiple lines, with\neach line being a single stand-alone JSON object, or a singe JSON array with\nsub-objects.\nThe response is a JSON object with the following attributes:\n- `created`: number of documents imported.\n- `errors`: number of documents that were not imported due to an error.\n- `empty`: number of empty lines found in the input (will only contain a\n  value greater zero for types `documents` or `auto`).\n- `updated`: number of updated/replaced documents (in case `onDuplicate`\n  was set to either `update` or `replace`).\n- `ignored`: number of failed but ignored insert operations (in case\n  `onDuplicate` was set to `ignore`).\n- `details`: if query parameter `details` is set to true, the result will\n  contain a `details` attribute which is an array with more detailed\n  information about which documents could not be inserted.\n", "operationId": " RestImportHandler", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"documents": {"type": "string", "description": "The body must either be a JSON-encoded array of objects or a string with\nmultiple JSON objects separated by newlines.\n"}}, "required": ["documents"]}}}}, "parameters": [{"name": "type", "schema": {"type": "string"}, "required": true, "description": "Determines how the body of the request will be interpreted. `type` can have\nthe following values\n- `documents` when this type is used, each line in the request body is\n  expected to be an individual JSON-encoded document. Multiple JSON objects\n  in the request body need to be separated by newlines.\n- `list` when this type is used, the request body must contain a single\n  JSON-encoded array of individual objects to import.\n- `auto` if set, this will automatically determine the body type (either\n  `documents` or `list`).\n", "in": "query"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The collection name.\n", "in": "query"}, {"name": "fromPrefix", "schema": {"type": "string"}, "required": false, "description": "An optional prefix for the values in `_from` attributes. If specified, the\nvalue is automatically prepended to each `_from` input value. This allows\nspecifying just the keys for `_from`.\n", "in": "query"}, {"name": "toPrefix", "schema": {"type": "string"}, "required": false, "description": "An optional prefix for the values in `_to` attributes. If specified, the\nvalue is automatically prepended to each `_to` input value. This allows\nspecifying just the keys for `_to`.\n", "in": "query"}, {"name": "overwrite", "schema": {"type": "boolean"}, "required": false, "description": "If this parameter has a value of `true` or `yes`, then all data in the\ncollection will be removed prior to the import. Note that any existing\nindex definitions will be preserved.\n", "in": "query"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Wait until documents have been synced to disk before returning.\n", "in": "query"}, {"name": "onDuplicate", "schema": {"type": "string"}, "required": false, "description": "Controls what action is carried out in case of a unique key constraint\nviolation. Possible values are\n- `error` this will not import the current document because of the unique\n  key constraint violation. This is the default setting.\n- `update` this will update an existing document in the database with the\n  data specified in the request. Attributes of the existing document that\n  are not present in the request will be preserved.\n- `replace` this will replace an existing document in the database with the\n  data specified in the request.\n- `ignore` this will not update an existing document and simply ignore the\n  error caused by a unique key constraint violation.\nNote that that `update`, `replace` and `ignore` will only work when the\nimport document in the request contains the `_key` attribute. `update` and\n`replace` may also fail because of secondary unique key constraint violations.\n", "in": "query"}, {"name": "complete", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true` or `yes`, it will make the whole import fail if any error\noccurs. Otherwise the import will continue even if some documents cannot\nbe imported.\n", "in": "query"}, {"name": "details", "schema": {"type": "boolean"}, "required": false, "description": "If set to `true` or `yes`, the result will include an attribute `details`\nwith details about documents that could not be imported.\n", "in": "query"}], "responses": {"201": {"description": "is returned if all documents could be imported successfully.\n"}, "400": {"description": "is returned if `type` contains an invalid value, no `collection` is\nspecified, the documents are incorrectly encoded, or the request\nis malformed.\n"}, "404": {"description": "is returned if `collection` or the `_from` or `_to` attributes of an\nimported edge refer to an unknown collection.\n"}, "409": {"description": "is returned if the import would trigger a unique key violation and\n`complete` is set to `true`.\n"}, "500": {"description": "is returned if the server cannot auto-generate a document key (out of keys\nerror) for a document with no user-defined key.\n"}}, "tags": ["Bulk"]}}, "/_api/foxx": {"get": {"description": "Fetches a list of services installed in the current database.\nReturns a list of objects with the following attributes:\n- *mount*: the mount path of the service\n- *development*: *true* if the service is running in development mode\n- *legacy*: *true* if the service is running in 2.8 legacy compatibility mode\n- *provides*: the service manifest's *provides* value or an empty object\nAdditionally the object may contain the following attributes if they have been set on the manifest:\n- *name*: a string identifying the service type\n- *version*: a semver-compatible version string\n", "parameters": [{"name": "excludeSystem", "schema": {"type": "boolean"}, "required": false, "description": "Whether or not system services should be excluded from the result.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "post": {"description": "Installs the given new service at the given mount path.\nThe request body can be any of the following formats:\n- `application/zip`: a raw zip bundle containing a service\n- `application/javascript`: a standalone JavaScript file\n- `application/json`: a service definition as JSON\n- `multipart/form-data`: a service definition as a multipart form\nA service definition is an object or form with the following properties or fields:\n- *configuration*: a JSON object describing configuration values\n- *dependencies*: a JSON object describing dependency settings\n- *source*: a fully qualified URL or an absolute path on the server's file system\nWhen using multipart data, the *source* field can also alternatively be a file field\ncontaining either a zip bundle or a standalone JavaScript file.\nWhen using a standalone JavaScript file the given file will be executed\nto define our service's HTTP endpoints. It is the same which would be defined\nin the field `main` of the service manifest.\nIf *source* is a URL, the URL must be reachable from the server.\nIf *source* is a file system path, the path will be resolved on the server.\nIn either case the path or URL is expected to resolve to a zip bundle,\nJavaScript file or (in case of a file system path) directory.\nNote that when using file system paths in a cluster with multiple Coordinators\nthe file system path must resolve to equivalent files on every Coordinator.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path the service should be installed at.\n", "in": "query"}, {"name": "development", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to enable development mode.\n", "in": "query"}, {"name": "setup", "schema": {"type": "boolean"}, "required": false, "description": "Set to `false` to not run the service's setup script.\n", "in": "query"}, {"name": "legacy", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to install the service in 2.8 legacy compatibility mode.\n", "in": "query"}], "responses": {"201": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/service": {"get": {"description": "Fetches detailed information for the service at the given mount path.\nReturns an object with the following attributes:\n- *mount*: the mount path of the service\n- *path*: the local file system path of the service\n- *development*: *true* if the service is running in development mode\n- *legacy*: *true* if the service is running in 2.8 legacy compatibility mode\n- *manifest*: the normalized JSON manifest of the service\nAdditionally the object may contain the following attributes if they have been set on the manifest:\n- *name*: a string identifying the service type\n- *version*: a semver-compatible version string\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}, "400": {"description": "Returned if the mount path is unknown.\n"}}, "tags": ["Foxx"]}, "delete": {"description": "Removes the service at the given mount path from the database and file system.\nReturns an empty response on success.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}, {"name": "teardown", "schema": {"type": "boolean"}, "required": false, "description": "Set to `false` to not run the service's teardown script.\n", "in": "query"}], "responses": {"204": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "put": {"description": "Removes the service at the given mount path from the database and file system.\nThen installs the given new service at the same mount path.\nThis is a slightly safer equivalent to performing an uninstall of the old service\nfollowed by installing the new service. The new service's main and script files\n(if any) will be checked for basic syntax errors before the old service is removed.\nThe request body can be any of the following formats:\n- `application/zip`: a raw zip bundle containing a service\n- `application/javascript`: a standalone JavaScript file\n- `application/json`: a service definition as JSON\n- `multipart/form-data`: a service definition as a multipart form\nA service definition is an object or form with the following properties or fields:\n- *configuration*: a JSON object describing configuration values\n- *dependencies*: a JSON object describing dependency settings\n- *source*: a fully qualified URL or an absolute path on the server's file system\nWhen using multipart data, the *source* field can also alternatively be a file field\ncontaining either a zip bundle or a standalone JavaScript file.\nWhen using a standalone JavaScript file the given file will be executed\nto define our service's HTTP endpoints. It is the same which would be defined\nin the field `main` of the service manifest.\nIf *source* is a URL, the URL must be reachable from the server.\nIf *source* is a file system path, the path will be resolved on the server.\nIn either case the path or URL is expected to resolve to a zip bundle,\nJavaScript file or (in case of a file system path) directory.\nNote that when using file system paths in a cluster with multiple Coordinators\nthe file system path must resolve to equivalent files on every Coordinator.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}, {"name": "teardown", "schema": {"type": "boolean"}, "required": false, "description": "Set to `false` to not run the old service's teardown script.\n", "in": "query"}, {"name": "setup", "schema": {"type": "boolean"}, "required": false, "description": "Set to `false` to not run the new service's setup script.\n", "in": "query"}, {"name": "legacy", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to install the new service in 2.8 legacy compatibility mode.\n", "in": "query"}, {"name": "force", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to force service install even if no service is installed under given mount.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "patch": {"description": "Installs the given new service on top of the service currently installed at the given mount path.\nThis is only recommended for switching between different versions of the same service.\nUnlike replacing a service, upgrading a service retains the old service's configuration\nand dependencies (if any) and should therefore only be used to migrate an existing service\nto a newer or equivalent service.\nThe request body can be any of the following formats:\n- `application/zip`: a raw zip bundle containing a service\n- `application/javascript`: a standalone JavaScript file\n- `application/json`: a service definition as JSON\n- `multipart/form-data`: a service definition as a multipart form\nA service definition is an object or form with the following properties or fields:\n- *configuration*: a JSON object describing configuration values\n- *dependencies*: a JSON object describing dependency settings\n- *source*: a fully qualified URL or an absolute path on the server's file system\nWhen using multipart data, the *source* field can also alternatively be a file field\ncontaining either a zip bundle or a standalone JavaScript file.\nWhen using a standalone JavaScript file the given file will be executed\nto define our service's HTTP endpoints. It is the same which would be defined\nin the field `main` of the service manifest.\nIf *source* is a URL, the URL must be reachable from the server.\nIf *source* is a file system path, the path will be resolved on the server.\nIn either case the path or URL is expected to resolve to a zip bundle,\nJavaScript file or (in case of a file system path) directory.\nNote that when using file system paths in a cluster with multiple Coordinators\nthe file system path must resolve to equivalent files on every Coordinator.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}, {"name": "teardown", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to run the old service's teardown script.\n", "in": "query"}, {"name": "setup", "schema": {"type": "boolean"}, "required": false, "description": "Set to `false` to not run the new service's setup script.\n", "in": "query"}, {"name": "legacy", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to install the new service in 2.8 legacy compatibility mode.\n", "in": "query"}, {"name": "force", "schema": {"type": "boolean"}, "required": false, "description": "Set to `true` to force service install even if no service is installed under given mount.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/configuration": {"get": {"description": "Fetches the current configuration for the service at the given mount path.\nReturns an object mapping the configuration option names to their definitions\nincluding a human-friendly *title* and the *current* value (if any).\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "patch": {"description": "Replaces the given service's configuration.\nReturns an object mapping all configuration option names to their new values.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "object", "description": "A JSON object mapping configuration option names to their new values.\nAny omitted options will be ignored.\n"}}, "required": ["data"]}}}}, "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "put": {"description": "Replaces the given service's configuration completely.\nReturns an object mapping all configuration option names to their new values.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "object", "description": "A JSON object mapping configuration option names to their new values.\nAny omitted options will be reset to their default values or marked as unconfigured.\n"}}, "required": ["data"]}}}}, "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/dependencies": {"get": {"description": "Fetches the current dependencies for service at the given mount path.\nReturns an object mapping the dependency names to their definitions\nincluding a human-friendly *title* and the *current* mount path (if any).\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "patch": {"description": "Replaces the given service's dependencies.\nReturns an object mapping all dependency names to their new mount paths.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "object", "description": "A JSON object mapping dependency names to their new mount paths.\nAny omitted dependencies will be ignored.\n"}}, "required": ["data"]}}}}, "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "put": {"description": "Replaces the given service's dependencies completely.\nReturns an object mapping all dependency names to their new mount paths.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "object", "description": "A JSON object mapping dependency names to their new mount paths.\nAny omitted dependencies will be disabled.\n"}}, "required": ["data"]}}}}, "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/scripts": {"get": {"description": "Fetches a list of the scripts defined by the service.\nReturns an object mapping the raw script names to human-friendly names.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/scripts/{name}": {"post": {"description": "Runs the given script for the service at the given mount path.\nReturns the exports of the script, if any.\n", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"data": {"type": "object", "description": "An arbitrary JSON value that will be parsed and passed to the\nscript as its first argument.\n"}}, "required": []}}}}, "parameters": [{"name": "name", "schema": {"type": "string"}, "required": true, "description": "Name of the script to run.\n", "in": "path"}, {"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/tests": {"post": {"description": "Runs the tests for the service at the given mount path and returns the results.\nSupported test reporters are:\n- *default*: a simple list of test cases\n- *suite*: an object of test cases nested in suites\n- *stream*: a raw stream of test results\n- *xunit*: an XUnit/JUnit compatible structure\n- *tap*: a raw TAP compatible stream\nThe *Accept* request header can be used to further control the response format:\nWhen using the *stream* reporter `application/x-ldjson` will result\nin the response body being formatted as a newline-delimited JSON stream.\nWhen using the *tap* reporter `text/plain` or `text/*` will result\nin the response body being formatted as a plain text TAP report.\nWhen using the *xunit* reporter `application/xml` or `text/xml` will result\nin the response body being formatted as XML instead of JSONML.\nOtherwise the response body will be formatted as non-prettyprinted JSON.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}, {"name": "reporter", "schema": {"type": "string"}, "required": false, "description": "Test reporter to use.\n", "in": "query"}, {"name": "idiomatic", "schema": {"type": "boolean"}, "required": false, "description": "Use the matching format for the reporter, regardless of the *Accept* header.\n", "in": "query"}, {"name": "filter", "schema": {"type": "string"}, "required": false, "description": "Only run tests where the full name (including full test suites and test case)\nmatches this string.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/development": {"post": {"description": "Puts the service into development mode.\nWhile the service is running in development mode the service will be reloaded\nfrom the filesystem and its setup script (if any) will be re-executed every\ntime the service handles a request.\nWhen running ArangoDB in a cluster with multiple Coordinators note that changes\nto the filesystem on one Coordinator will not be reflected across the other\nCoordinators. This means you should treat your Coordinators as inconsistent\nas long as any service is running in development mode.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}, "delete": {"description": "Puts the service at the given mount path into production mode.\nWhen running ArangoDB in a cluster with multiple Coordinators this will\nreplace the service on all other Coordinators with the version on this\nCoordinator.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/readme": {"get": {"description": "Fetches the service's README or README.md file's contents if any.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}, "204": {"description": "Returned if no README file was found.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/swagger": {"get": {"description": "Fetches the Swagger API description for the service at the given mount path.\nThe response body will be an OpenAPI 2.0 compatible JSON description of the service API.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/download": {"post": {"description": "Downloads a zip bundle of the service directory.\nWhen development mode is enabled, this always creates a new bundle.\nOtherwise the bundle will represent the version of a service that\nis installed on that ArangoDB instance.\n", "parameters": [{"name": "mount", "schema": {"type": "string"}, "required": true, "description": "Mount path of the installed service.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the request was successful.\n"}, "400": {"description": "Returned if the mount path is unknown.\n"}}, "tags": ["Foxx"]}}, "/_api/foxx/commit": {"post": {"description": "Commits the local service state of the Coordinator to the database.\nThis can be used to resolve service conflicts between Coordinators that can not be fixed automatically due to missing data.\n", "parameters": [{"name": "replace", "schema": {"type": "boolean"}, "required": false, "description": "Overwrite existing service files in database even if they already exist.\n", "in": "query"}], "responses": {"204": {"description": "Returned if the request was successful.\n"}}, "tags": ["Foxx"]}}, "/_api/collection/{collection-name}/load": {"put": {"description": "\nSince ArangoDB version 3.9.0 this API does nothing. Previously it used to\nload a collection into memory. \n\nThe request body object might optionally contain the following attribute:\n\n- *count*: If set, this controls whether the return value should include\n  the number of documents in the collection. Setting *count* to\n  *false* may speed up loading a collection. The default value for\n  *count* is *true*.\n\nA call to this API returns an object with the following attributes for\ncompatibility reasons:\n\n- *id*: The identifier of the collection.\n\n- *name*: The name of the collection.\n\n- *count*: The number of documents inside the collection. This is only\n  returned if the *count* input parameters is set to *true* or has\n  not been specified.\n\n- *status*: The status of the collection as number.\n\n- *type*: The collection type. Valid types are:\n  - 2: document collection\n  - 3: edge collection\n\n- *isSystem*: If *true* then the collection is a system collection.\n\n", "operationId": " handleCommandPut:loadCollection", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/unload": {"put": {"description": "Since ArangoDB version 3.9.0 this API does nothing. Previously it used to\nunload a collection from memory, while preserving all documents.\nWhen calling the API an object with the following attributes is\nreturned for compatibility reasons:\n- *id*: The identifier of the collection.\n- *name*: The name of the collection.\n- *status*: The status of the collection as number.\n- *type*: The collection type. Valid types are:\n  - 2: document collection\n  - 3: edges collection\n- *isSystem*: If *true* then the collection is a system collection.\n", "operationId": " handleCommandPut:collectionUnload", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "", "in": "path"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/loadIndexesIntoMemory": {"put": {"description": "You can call this endpoint to try to cache this collection's index entries in\nthe main memory. Index lookups served from the memory cache can be much faster\nthan lookups not stored in the cache, resulting in a performance boost.\nThe endpoint iterates over suitable indexes of the collection and stores the\nindexed values (not the entire document data) in memory. This is implemented for\nedge indexes only.\nThe endpoint returns as soon as the index warmup has been scheduled. The index\nwarmup may still be ongoing in the background, even after the return value has\nalready been sent. As all suitable indexes are scanned, it may cause significant\nI/O activity and background load.\nThis feature honors memory limits. If the indexes you want to load are smaller\nthan your memory limit, this feature guarantees that most index values are\ncached. If the index is larger than your memory limit, this feature fills\nup values up to this limit. You cannot control which indexes of the collection\nshould have priority over others.\nIt is guaranteed that the in-memory cache data is consistent with the stored\nindex data at all times.\nOn success, this endpoint returns an object with attribute `result` set to `true`.\n", "operationId": " handleCommandPut:loadIndexes", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "", "in": "path"}], "responses": {"200": {"description": "If the index loading has been scheduled for all suitable indexes.\n"}, "400": {"description": "If the `collection-name` is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the `collection-name` is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/properties": {"put": {"description": "Changes the properties of a collection. Only the provided attributes are\nupdated. Collection properties **cannot be changed** once a collection is\ncreated except for the listed properties, as well as the collection name via\nthe rename endpoint (but not in clusters).\n", "operationId": " handleCommandPut:modifyProperties", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"waitForSync": {"type": "boolean", "description": "If *true* then the data is synchronized to disk before returning from a\ndocument create, update, replace or removal operation. (default: false)\n"}, "cacheEnabled": {"type": "boolean", "description": "Whether the in-memory hash cache for documents should be enabled for this\ncollection (default: *false*). Can be controlled globally with the `--cache.size`\nstartup option. The cache can speed up repeated reads of the same documents via\ntheir document keys. If the same documents are not fetched often or are\nmodified frequently, then you may disable the cache to avoid the maintenance\ncosts.\n"}, "schema": {"type": "object", "description": "Optional object that specifies the collection level schema for\ndocuments. The attribute keys `rule`, `level` and `message` must follow the\nrules documented in [Document Schema Validation](https://www.arangodb.com/docs/stable/data-modeling-documents-schema-validation.html)\n"}, "computedValues": {"$ref": "#/components/schemas/put_api_collection_properties_computed_field", "items": {"type": "put_api_collection_properties_computed_field"}, "description": "An optional list of objects, each representing a computed value.\n"}, "replicationFactor": {"type": "integer", "format": "int64", "description": "(The default is *1*): in a cluster, this attribute determines how many copies\nof each shard are kept on different DB-Servers. The value 1 means that only one\ncopy (no synchronous replication) is kept. A value of k means that k-1 replicas\nare kept. It can also be the string `\"satellite\"` for a SatelliteCollection,\nwhere the replication factor is matched to the number of DB-Servers\n(Enterprise Edition only).\nAny two copies reside on different DB-Servers. Replication between them is\nsynchronous, that is, every write operation to the \"leader\" copy will be replicated\nto all \"follower\" replicas, before the write operation is reported successful.\nIf a server fails, this is detected automatically and one of the servers holding\ncopies take over, usually without an error being reported.\n"}, "writeConcern": {"type": "integer", "format": "int64", "description": "Write concern for this collection (default: 1).\nIt determines how many copies of each shard are required to be\nin sync on the different DB-Servers. If there are less then these many copies\nin the cluster a shard will refuse to write. Writes to shards with enough\nup-to-date copies will succeed at the same time however. The value of\n*writeConcern* can not be larger than *replicationFactor*. _(cluster only)_\n"}}, "required": []}}}}, "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Collections"]}, "get": {"description": " Read properties of a collection", "operationId": " handleCommandGet:collectionProperties", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}, "200": {"description": "", "content": {"application/json": {"schema": {"type": "object", "properties": {"": {"$ref": "#/components/schemas/collection_info", "description": ""}}, "required": [""]}}}}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/rename": {"put": {"description": "Renames a collection. Expects an object with the attribute(s)\n- *name*: The new name.\nIt returns an object with the attributes\n- *id*: The identifier of the collection.\n- *name*: The new name of the collection.\n- *status*: The status of the collection as number.\n- *type*: The collection type. Valid types are:\n  - 2: document collection\n  - 3: edges collection\n- *isSystem*: If *true* then the collection is a system collection.\nIf renaming the collection succeeds, then the collection is also renamed in\nall graph definitions inside the `_graphs` collection in the current database.\n**Note**: this method is not available in a cluster.\n", "operationId": " handleCommandPut:renameCollection", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection to rename.\n", "in": "path"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/recalculateCount": {"put": {"description": "Recalculates the document count of a collection, if it ever becomes inconsistent.\nIt returns an object with the attributes\n- *result*: will be *true* if recalculating the document count succeeded.\n", "operationId": " handleCommandPut:recalculateCount", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"200": {"description": "If the document count was recalculated successfully, *HTTP 200* is returned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/compact": {"put": {"description": "Compacts the data of a collection in order to reclaim disk space.\nThe operation will compact the document and index data by rewriting the\nunderlying .sst files and only keeping the relevant entries.\nUnder normal circumstances, running a compact operation is not necessary, as\nthe collection data will eventually get compacted anyway. However, in some\nsituations, e.g. after running lots of update/replace or remove operations,\nthe disk data for a collection may contain a lot of outdated data for which the\nspace shall be reclaimed. In this case the compaction operation can be used.\n", "operationId": " RestCompactCollectionHandler", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "Name of the collection to compact\n", "in": "path"}], "responses": {"200": {"description": "Compaction started successfully\n"}, "401": {"description": "if the request was not authenticated as a user with sufficient rights\n"}}, "tags": ["Collections"]}}, "/_api/collection": {"post": {"description": "Creates a new collection with a given name. The request must contain an\nobject with the following attributes.\n", "operationId": " handleCommandPost:CreateCollection", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the collection.\n"}, "waitForSync": {"type": "boolean", "description": "If `true` then the data is synchronized to disk before returning from a\ndocument create, update, replace or removal operation. (Default: `false`)\n"}, "isSystem": {"type": "boolean", "description": "If `true`, create a system collection. In this case, the `collection-name`\nshould start with an underscore. End-users should normally create non-system\ncollections only. API implementors may be required to create system\ncollections in very special occasions, but normally a regular collection will do.\n(The default is `false`)\n"}, "schema": {"type": "object", "description": "Optional object that specifies the collection level schema for\ndocuments. The attribute keys `rule`, `level` and `message` must follow the\nrules documented in [Document Schema Validation](https://www.arangodb.com/docs/stable/documents-schema-validation.html)\n"}, "computedValues": {"$ref": "#/components/schemas/post_api_collection_computed_field", "items": {"type": "post_api_collection_computed_field"}, "description": "An optional list of objects, each representing a computed value.\n"}, "keyOptions": {"$ref": "#/components/schemas/post_api_collection_opts", "description": "additional options for key generation. If specified, then `keyOptions`\nshould be a JSON object containing the following attributes:\n"}, "type": {"type": "integer", "format": "int64", "description": "(The default is `2`): the type of the collection to create.\nThe following values for `type` are valid:\n- `2`: document collection\n- `3`: edge collection\n"}, "cacheEnabled": {"type": "boolean", "description": "Whether the in-memory hash cache for documents should be enabled for this\ncollection (default: `false`). Can be controlled globally with the `--cache.size`\nstartup option. The cache can speed up repeated reads of the same documents via\ntheir document keys. If the same documents are not fetched often or are\nmodified frequently, then you may disable the cache to avoid the maintenance\ncosts.\n"}, "numberOfShards": {"type": "integer", "format": "int64", "description": "(The default is `1`): in a cluster, this value determines the\nnumber of shards to create for the collection. In a single\nserver setup, this option is meaningless.\n"}, "shardKeys": {"type": "string", "description": "(The default is `[ \"_key\" ]`): in a cluster, this attribute determines\nwhich document attributes are used to determine the target shard for documents.\nDocuments are sent to shards based on the values of their shard key attributes.\nThe values of all shard key attributes in a document are hashed,\nand the hash value is used to determine the target shard.\n**Note**: Values of shard key attributes cannot be changed once set.\n  This option is meaningless in a single server setup.\n"}, "replicationFactor": {"type": "integer", "format": "int64", "description": "(The default is `1`): in a cluster, this attribute determines how many copies\nof each shard are kept on different DB-Servers. The value 1 means that only one\ncopy (no synchronous replication) is kept. A value of k means that k-1 replicas\nare kept. It can also be the string `\"satellite\"` for a SatelliteCollection,\nwhere the replication factor is matched to the number of DB-Servers\n(Enterprise Edition only).\nAny two copies reside on different DB-Servers. Replication between them is\nsynchronous, that is, every write operation to the \"leader\" copy will be replicated\nto all \"follower\" replicas, before the write operation is reported successful.\nIf a server fails, this is detected automatically and one of the servers holding\ncopies take over, usually without an error being reported.\n"}, "writeConcern": {"type": "integer", "format": "int64", "description": "Write concern for this collection (default: 1).\nIt determines how many copies of each shard are required to be\nin sync on the different DB-Servers. If there are less then these many copies\nin the cluster a shard will refuse to write. Writes to shards with enough\nup-to-date copies will succeed at the same time however. The value of\n`writeConcern` cannot be larger than `replicationFactor`. _(cluster only)_\n"}, "shardingStrategy": {"type": "string", "description": "This attribute specifies the name of the sharding strategy to use for\nthe collection. Since ArangoDB 3.4 there are different sharding strategies\nto select from when creating a new collection. The selected `shardingStrategy`\nvalue remains fixed for the collection and cannot be changed afterwards.\nThis is important to make the collection keep its sharding settings and\nalways find documents already distributed to shards using the same\ninitial sharding algorithm.\nThe available sharding strategies are:\n- `community-compat`: default sharding used by ArangoDB\n  Community Edition before version 3.4\n- `enterprise-compat`: default sharding used by ArangoDB\n  Enterprise Edition before version 3.4\n- `enterprise-smart-edge-compat`: default sharding used by smart edge\n  collections in ArangoDB Enterprise Edition before version 3.4\n- `hash`: default sharding used for new collections starting from version 3.4\n  (excluding smart edge collections)\n- `enterprise-hash-smart-edge`: default sharding used for new\n  smart edge collections starting from version 3.4\n- `enterprise-hex-smart-vertex`: sharding used for vertex collections of\n  EnterpriseGraphs\nIf no sharding strategy is specified, the default is `hash` for\nall normal collections, `enterprise-hash-smart-edge` for all smart edge\ncollections, and `enterprise-hex-smart-vertex` for EnterpriseGraph\nvertex collections (the latter two require the *Enterprise Edition* of ArangoDB).\nManually overriding the sharding strategy does not yet provide a\nbenefit, but it may later in case other sharding strategies are added.\n"}, "distributeShardsLike": {"type": "string", "description": "The name of another collection. If this property is set in a cluster, the\ncollection copies the `replicationFactor`, `numberOfShards` and `shardingStrategy`\nproperties from the specified collection (referred to as the _prototype collection_)\nand distributes the shards of this collection in the same way as the shards of\nthe other collection. In an Enterprise Edition cluster, this data co-location is\nutilized to optimize queries.\nYou need to use the same number of `shardKeys` as the prototype collection, but\nyou can use different attributes.\nThe default is `\"\"`.\n**Note**: Using this parameter has consequences for the prototype\ncollection. It can no longer be dropped, before the sharding-imitating\ncollections are dropped. Equally, backups and restores of imitating\ncollections alone generate warnings (which can be overridden)\nabout a missing sharding prototype.\n"}, "isSmart": {"type": "boolean", "description": "Whether the collection is for a SmartGraph or EnterpriseGraph\n(Enterprise Edition only). This is an internal property.\n"}, "isDisjoint": {"type": "boolean", "description": "Whether the collection is for a Disjoint SmartGraph\n(Enterprise Edition only). This is an internal property.\n"}, "smartGraphAttribute": {"type": "string", "description": "The attribute that is used for sharding: vertices with the same value of\nthis attribute are placed in the same shard. All vertices are required to\nhave this attribute set and it has to be a string. Edges derive the\nattribute from their connected vertices.\nThis feature can only be used in the *Enterprise Edition*.\n"}, "smartJoinAttribute": {"type": "string", "description": "In an *Enterprise Edition* cluster, this attribute determines an attribute\nof the collection that must contain the shard key value of the referred-to\nSmartJoin collection. Additionally, the shard key for a document in this\ncollection must contain the value of this attribute, followed by a colon,\nfollowed by the actual primary key of the document.\nThis feature can only be used in the *Enterprise Edition* and requires the\n`distributeShardsLike` attribute of the collection to be set to the name\nof another collection. It also requires the `shardKeys` attribute of the\ncollection to be set to a single shard key attribute, with an additional ':'\nat the end.\nA further restriction is that whenever documents are stored or updated in the\ncollection, the value stored in the `smartJoinAttribute` must be a string.\n"}}, "required": ["name"]}}}}, "parameters": [{"name": "waitForSyncReplication", "schema": {"type": "boolean"}, "required": false, "description": "The default is `true`, which means the server only reports success back to the\nclient when all replicas have created the collection. Set it to `false` if you want\nfaster server responses and don't care about full replication.\n", "in": "query"}, {"name": "enforceReplicationFactor", "schema": {"type": "boolean"}, "required": false, "description": "The default is `true`, which means the server checks if there are enough replicas\navailable at creation time and bail out otherwise. Set it to `false` to disable\nthis extra check.\n", "in": "query"}], "responses": {"400": {"description": "If the `collection-name` is missing, then an *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the `collection-name` is unknown, then an *HTTP 404* is returned.\n"}, "200": {"description": ""}}, "tags": ["Collections"]}, "get": {"description": "Returns an object with an attribute *result* containing an\narray of all collection descriptions.\nBy providing the optional query parameter *excludeSystem* with a value of\n*true*, all system collections will be excluded from the response.\n", "operationId": " handleCommandGet", "parameters": [{"name": "excludeSystem", "schema": {"type": "boolean"}, "required": false, "description": "Whether or not system collections should be excluded from the result.\n", "in": "query"}], "responses": {"200": {"description": "The list of collections\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}": {"delete": {"description": "Drops the collection identified by *collection-name*.\nIf the collection was successfully dropped, an object is returned with\nthe following attributes:\n- *error*: *false*\n- *id*: The identifier of the dropped collection.\n", "operationId": " handleCommandDelete:collection", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection to drop.\n", "in": "path"}, {"name": "isSystem", "schema": {"type": "boolean"}, "required": false, "description": "Whether or not the collection to drop is a system collection. This parameter\nmust be set to *true* in order to drop a system collection.\n", "in": "query"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Collections"]}, "get": {"description": "The result is an object describing the collection with the following\nattributes:\n- *id*: The identifier of the collection.\n- *name*: The name of the collection.\n- *status*: The status of the collection as number.\n  - 3: loaded\n  - 5: deleted\nEvery other status indicates a corrupted collection.\n- *type*: The type of the collection as number.\n  - 2: document collection (normal case)\n  - 3: edge collection\n- *isSystem*: If *true* then the collection is a system collection.\n", "operationId": " handleCommandGet:collectionGetProperties", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"404": {"description": "If the *collection-name* is unknown, then a *HTTP 404* is\nreturned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/truncate": {"put": {"description": "Removes all documents from the collection, but leaves the indexes intact.\n", "operationId": " handleCommandPut:truncateCollection", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "If *true* then the data is synchronized to disk before returning from the\ntruncate operation (default *false*)\n", "in": "query"}, {"name": "compact", "schema": {"type": "boolean"}, "required": false, "description": "If *true* (default) then the storage engine is told to start a compaction\nin order to free up disk space. This can be resource intensive. If the only \nintention is to start over with an empty collection, specify *false*.\n\n", "in": "query"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/count": {"get": {"description": "In addition to the above, the result also contains the number of documents.\n**Note** that this will always load the collection into memory.\n- *count*: The number of documents inside the collection.\n", "operationId": " handleCommandGet:getCollectionCount", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/figures": {"get": {"description": "In addition to the above, the result also contains the number of documents\nand additional statistical information about the collection.\n", "operationId": " handleCommandGet:collectionFigures", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}, {"name": "details", "schema": {"type": "boolean"}, "required": false, "description": "Setting `details` to `true` will return extended storage engine-specific\ndetails to the figures. The details are intended for debugging ArangoDB itself\nand their format is subject to change. By default, `details` is set to `false`,\nso no details are returned and the behavior is identical to previous versions\nof ArangoDB.\nPlease note that requesting `details` may cause additional load and thus have\nan impact on performace.\n", "in": "query"}], "responses": {"200": {"description": "Returns information about the collection\n"}, "400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"count": {"type": "integer", "format": "int64", "description": "The number of documents currently present in the collection.\n"}, "figures": {"$ref": "#/components/schemas/collection_figures", "description": "metrics of the collection\n"}}, "required": ["count", "figures"]}}}}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/responsibleShard": {"put": {"description": "Returns the ID of the shard that is responsible for the given document\n(if the document exists) or that would be responsible if such document\nexisted.\nThe request must body must contain a JSON document with at least the\ncollection's shard key attributes set to some values.\nThe response is a JSON object with a *shardId* attribute, which will\ncontain the ID of the responsible shard.\n**Note** : This method is only available in a cluster Coordinator.\n", "operationId": " getResponsibleShard:Collection", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"document": {"type": "object", "description": "The body must consist of a JSON object with at least the shard key\nattributes set to some values.\n"}}, "required": ["document"]}}}}, "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"200": {"description": "Returns the ID of the responsible shard.\n"}, "400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\nAdditionally, if not all of the collection's shard key\nattributes are present in the input document, then a\n*HTTP 400* is returned as well.\n"}, "404": {"description": "If the *collection-name* is unknown, then an *HTTP 404*\nis returned.\n"}, "501": {"description": "*HTTP 501* is returned if the method is called on a single server.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/shards": {"get": {"description": "By default returns a JSON array with the shard IDs of the collection.\nIf the `details` parameter is set to `true`, it will return a JSON object with the\nshard IDs as object attribute keys, and the responsible servers for each shard mapped to them.\nIn the detailed response, the leader shards will be first in the arrays.\n**Note** : This method is only available in a cluster Coordinator.\n", "operationId": " shards:Collection", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}, {"name": "details", "schema": {"type": "boolean"}, "required": false, "description": "If set to true, the return value will also contain the responsible servers for the collections' shards.\n", "in": "query"}], "responses": {"200": {"description": "Returns the collection's shards.\n"}, "400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then an *HTTP 404*\nis returned.\n"}, "501": {"description": "*HTTP 501* is returned if the method is called on a single server.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/revision": {"get": {"description": "\nThe response will contain the collection's latest used revision id. \nThe revision id is a server-generated string that clients can use to \ncheck whether data in a collection has changed since the last revision check.\n\n- *revision*: The collection revision id as a string.\n\n", "operationId": " handleCommandGet:collectionRevision", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Collections"]}}, "/_api/collection/{collection-name}/checksum": {"get": {"description": "Will calculate a checksum of the meta-data (keys and optionally revision ids) and\noptionally the document data in the collection.\nThe checksum can be used to compare if two collections on different ArangoDB\ninstances contain the same contents. The current revision of the collection is\nreturned too so one can make sure the checksums are calculated for the same\nstate of data.\nBy default, the checksum will only be calculated on the *_key* system attribute\nof the documents contained in the collection. For edge collections, the system\nattributes *_from* and *_to* will also be included in the calculation.\nBy setting the optional query parameter *withRevisions* to *true*, then revision\nids (*_rev* system attributes) are included in the checksumming.\nBy providing the optional query parameter *withData* with a value of *true*,\nthe user-defined document attributes will be included in the calculation too.\n**Note**: Including user-defined attributes will make the checksumming slower.\nThe response is a JSON object with the following attributes:\n- *checksum*: The calculated checksum as a number.\n- *revision*: The collection revision id as a string.\n", "operationId": " handleCommandGet:collectionChecksum", "parameters": [{"name": "collection-name", "schema": {"type": "string"}, "required": true, "description": "The name of the collection.\n", "in": "path"}, {"name": "withRevisions", "schema": {"type": "boolean"}, "required": false, "description": "Whether or not to include document revision ids in the checksum calculation.\n", "in": "query"}, {"name": "withData", "schema": {"type": "boolean"}, "required": false, "description": "Whether or not to include document body data in the checksum calculation.\n", "in": "query"}], "responses": {"400": {"description": "If the *collection-name* is missing, then a *HTTP 400* is\nreturned.\n"}, "404": {"description": "If the *collection-name* is unknown, then a *HTTP 404*\nis returned.\n"}}, "tags": ["Collections"]}}, "/_api/database/current": {"get": {"description": "Retrieves the properties of the current database\nThe response is a JSON object with the following attributes:\n- *name*: the name of the current database\n- *id*: the id of the current database\n- *path*: the filesystem path of the current database\n- *isSystem*: whether or not the current database is the *_system* database\n- *sharding*: the default sharding method for collections created in this database\n- *replicationFactor*: the default replication factor for collections in this database\n- *writeConcern*: the default write concern for collections in this database\n", "operationId": " getDatabases:current", "responses": {"200": {"description": "is returned if the information was retrieved successfully.\n"}, "400": {"description": "is returned if the request is invalid.\n"}, "404": {"description": "is returned if the database could not be found.\n"}}, "tags": ["Database"]}}, "/_api/database/user": {"get": {"description": "Retrieves the list of all databases the current user can access without\nspecifying a different username or password.\n", "operationId": " getDatabases:user", "responses": {"200": {"description": "is returned if the list of database was compiled successfully.\n"}, "400": {"description": "is returned if the request is invalid.\n"}}, "tags": ["Database"]}}, "/_api/database": {"get": {"description": "Retrieves the list of all existing databases\n**Note**: retrieving the list of databases is only possible from within the *_system* database.\n**Note**: You should use the *GET user API* to fetch the list of the available databases now.\n", "operationId": " getDatabases:all", "responses": {"200": {"description": "is returned if the list of database was compiled successfully.\n"}, "400": {"description": "is returned if the request is invalid.\n"}, "403": {"description": "is returned if the request was not executed in the *_system* database.\n"}}, "tags": ["Database"]}, "post": {"description": "Creates a new database\nThe response is a JSON object with the attribute *result* set to *true*.\n**Note**: creating a new database is only possible from within the *_system* database.\n", "operationId": " createDatabase", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "Has to contain a valid database name. The name must conform to the selected\nnaming convention for databases. If the name contains Unicode characters, the\nname must be [NFC-normalized](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).\nNon-normalized names will be rejected by arangod.\n"}, "options": {"$ref": "#/components/schemas/get_api_database_new_OPTIONS", "description": "Optional object which can contain the following attributes:\n"}, "users": {"$ref": "#/components/schemas/get_api_database_new_USERS", "items": {"type": "get_api_database_new_USERS"}, "description": "An array of user objects. The users will be granted *Administrate* permissions\nfor the new database. Users that do not exist yet will be created.\nIf *users* is not specified or does not contain any users, the default user\n*root* will be used to ensure that the new database will be accessible after it\nis created. The *root* user is created with an empty password should it not\nexist. Each user object can contain the following attributes:\n"}}, "required": ["name"]}}}}, "responses": {"201": {"description": "is returned if the database was created successfully.\n"}, "400": {"description": "is returned if the request parameters are invalid or if a database with the\nspecified name already exists.\n"}, "403": {"description": "is returned if the request was not executed in the *_system* database.\n"}, "409": {"description": "is returned if a database with the specified name already exists.\n"}}, "tags": ["Database"]}}, "/_api/database/{database-name}": {"delete": {"description": "Drops the database along with all data stored in it.\n**Note**: dropping a database is only possible from within the *_system* database.\nThe *_system* database itself cannot be dropped.\n", "operationId": " deleteDatabase", "parameters": [{"name": "database-name", "schema": {"type": "string"}, "required": true, "description": "The name of the database\n", "in": "path"}], "responses": {"200": {"description": "is returned if the database was dropped successfully.\n"}, "400": {"description": "is returned if the request is malformed.\n"}, "403": {"description": "is returned if the request was not executed in the *_system* database.\n"}, "404": {"description": "is returned if the database could not be found.\n"}}, "tags": ["Database"]}}, "/_api/view#searchalias": {"post": {"description": "Creates a new View with a given name and properties if it does not\nalready exist.\n", "operationId": " createViewSearchAlias", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the View.\n"}, "type": {"type": "string", "description": "The type of the View. Must be equal to `\"search-alias\"`.\nThis option is immutable.\n"}, "indexes": {"$ref": "#/components/schemas/post_api_view_searchalias_indexes", "items": {"type": "post_api_view_searchalias_indexes"}, "description": "A list of inverted indexes to add to the View.\n"}}, "required": ["name", "type"]}}}}, "responses": {"400": {"description": "If the *name* or *type* attribute are missing or invalid, then an *HTTP 400*\nerror is returned.\n"}, "409": {"description": "If a View called *name* already exists, then an *HTTP 409* error is returned.\n"}}, "tags": ["Views"]}}, "/_api/view/{view-name}": {"get": {"description": "The result is an object briefly describing the View with the following attributes:\n- *id*: The identifier of the View\n- *name*: The name of the View\n- *type*: The type of the View as string\n", "operationId": " getViews:Properties", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View.\n", "in": "path"}], "responses": {"404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Views"]}, "delete": {"description": "Drops the View identified by *view-name*.\nIf the View was successfully dropped, an object is returned with\nthe following attributes:\n- *error*: *false*\n- *id*: The identifier of the dropped View\n", "operationId": " deleteView", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View to drop.\n", "in": "path"}], "responses": {"400": {"description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Views"]}}, "/_api/view/{view-name}/properties": {"get": {"description": "The result is an object with a full description of a specific View, including\nView type dependent properties.\n", "operationId": " getView", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View.\n", "in": "path"}], "responses": {"400": {"description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Views"]}}, "/_api/view": {"get": {"description": "Returns an object containing a listing of all Views in a database, regardless\nof their type. It is an array of objects with the following attributes:\n- *id*\n- *name*\n- *type*\n", "operationId": " getViews:AllViews", "responses": {"200": {"description": "The list of Views\n"}}, "tags": ["Views"]}}, "/_api/view/{view-name}/properties#searchalias": {"put": {"description": "Replaces the list of indexes of a `search-alias` View.\n", "operationId": " modifyViewSearchAlias", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"indexes": {"$ref": "#/components/schemas/put_api_view_searchalias_indexes", "items": {"type": "put_api_view_searchalias_indexes"}, "description": "A list of inverted indexes for the View.\n"}}, "required": []}}}}, "responses": {"200": {"description": "On success, an object with the following attributes is returned\n"}, "400": {"description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "The identifier of the View.\n"}, "name": {"type": "string", "description": "The name of the View.\n"}, "type": {"type": "string", "description": "The View type (`\"search-alias\"`).\n"}, "indexes": {"$ref": "#/components/schemas/put_api_view_searchalias_indexes_reply", "items": {"type": "put_api_view_searchalias_indexes_reply"}, "description": "The list of inverted indexes that are part of the View.\n"}}, "required": ["id", "name", "type", "indexes"]}}}}}, "tags": ["Views"]}, "patch": {"description": "Updates the list of indexes of a `search-alias` View.\n", "operationId": " modifyViewPartialSearchAlias", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"indexes": {"$ref": "#/components/schemas/patch_api_view_searchalias_indexes", "items": {"type": "patch_api_view_searchalias_indexes"}, "description": "A list of inverted indexes to add to or remove from the View.\n"}}, "required": []}}}}, "responses": {"200": {"description": "On success, an object with the following attributes is returned\n"}, "400": {"description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"id": {"type": "string", "description": "The identifier of the View.\n"}, "name": {"type": "string", "description": "The name of the View.\n"}, "type": {"type": "string", "description": "The View type (`\"search-alias\"`).\n"}, "indexes": {"$ref": "#/components/schemas/patch_api_view_searchalias_indexes_reply", "items": {"type": "patch_api_view_searchalias_indexes_reply"}, "description": "The list of inverted indexes that are part of the View.\n"}}, "required": ["id", "name", "type", "indexes"]}}}}}, "tags": ["Views"]}}, "/_api/view/{view-name}/rename": {"put": {"description": "Renames a View. Expects an object with the attribute(s)\n- *name*: The new name\nIt returns an object with the attributes\n- *id*: The identifier of the View.\n- *name*: The new name of the View.\n- *type*: The View type.\n**Note**: This method is not available in a cluster.\n", "operationId": " modifyView:rename", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View to rename.\n", "in": "path"}], "responses": {"400": {"description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Views"]}}, "/_api/view#arangosearch": {"post": {"description": "Creates a new View with a given name and properties if it does not\nalready exist.\n", "operationId": " createView", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the View.\n"}, "type": {"type": "string", "description": "The type of the View. Must be equal to `\"arangosearch\"`.\nThis option is immutable.\n"}, "links": {"type": "object", "description": "Expects an object with the attribute keys being names of to be linked collections,\nand the link properties as attribute values. See\n[ArangoSearch View Link Properties](https://www.arangodb.com/docs/stable/arangosearch-views.html#link-properties)\nfor details.\n"}, "primarySort": {"type": "array", "format": "object", "items": {"type": "object"}, "description": "A primary sort order can be defined to enable an AQL optimization. If a query\niterates over all documents of a View, wants to sort them by attribute values\nand the (left-most) fields to sort by as well as their sorting direction match\nwith the *primarySort* definition, then the `SORT` operation is optimized away.\nThis option is immutable.\n\nExpects an array of objects, each specifying a field (attribute path) and a\nsort direction (`\"asc` for ascending, `\"desc\"` for descending):\n`[ { \"field\": \"attr\", \"direction\": \"asc\"}, \u2026 ]`\n\n"}, "primarySortCompression": {"type": "string", "description": "Defines how to compress the primary sort data (introduced in v3.7.1).\nArangoDB v3.5 and v3.6 always compress the index using LZ4.\nThis option is immutable.\n- `\"lz4\"` (default): use LZ4 fast compression.\n- `\"none\"`: disable compression to trade space for speed.\n"}, "storedValues": {"type": "array", "format": "object", "items": {"type": "object"}, "description": "An array of objects to describe which document attributes to store in the View\nindex (introduced in v3.7.1). It can then cover search queries, which means the\ndata can be taken from the index directly and accessing the storage engine can\nbe avoided.\nEach object is expected in the form\n`{ \"fields\": [ \"attr1\", \"attr2\", ... \"attrN\" ], \"compression\": \"none\" }`,\nwhere the required `fields` attribute is an array of strings with one or more\ndocument attribute paths. The specified attributes are placed into a single\ncolumn of the index. A column with all fields that are involved in common\nsearch queries is ideal for performance. The column should not include too many\nunneeded fields however. The optional `compression` attribute defines the\ncompression type used for the internal column-store, which can be `\"lz4\"`\n(LZ4 fast compression, default) or `\"none\"` (no compression).\nThis option is immutable. Not to be confused with `storeValues`, which allows\nto store meta data about attribute values in the View index.\n"}, "cleanupIntervalStep": {"type": "integer", "format": "int64", "description": "Wait at least this many commits between removing unused files in the\nArangoSearch data directory (default: 2, to disable use: 0).\nFor the case where the consolidation policies merge segments often (i.e. a lot\nof commit+consolidate), a lower value will cause a lot of disk space to be\nwasted.\nFor the case where the consolidation policies rarely merge segments (i.e. few\ninserts/deletes), a higher value will impact performance without any added\nbenefits.\n_Background:_\n  With every \"commit\" or \"consolidate\" operation a new state of the View\n  internal data-structures is created on disk.\n  Old states/snapshots are released once there are no longer any users\n  remaining.\n  However, the files for the released states/snapshots are left on disk, and\n  only removed by \"cleanup\" operation.\n"}, "commitIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between committing View data store\nchanges and making documents visible to queries (default: 1000, to disable\nuse: 0).\nFor the case where there are a lot of inserts/updates, a lower value, until\ncommit, will cause the index not to account for them and memory usage would\ncontinue to grow.\nFor the case where there are a few inserts/updates, a higher value will impact\nperformance and waste disk space for each commit call without any added\nbenefits.\n_Background:_\n  For data retrieval ArangoSearch Views follow the concept of\n  \"eventually-consistent\", i.e. eventually all the data in ArangoDB will be\n  matched by corresponding query expressions.\n  The concept of ArangoSearch View \"commit\" operation is introduced to\n  control the upper-bound on the time until document addition/removals are\n  actually reflected by corresponding query expressions.\n  Once a \"commit\" operation is complete all documents added/removed prior to\n  the start of the \"commit\" operation will be reflected by queries invoked in\n  subsequent ArangoDB transactions, in-progress ArangoDB transactions will\n  still continue to return a repeatable-read state.\n"}, "consolidationIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between applying 'consolidationPolicy' to\nconsolidate View data store and possibly release space on the filesystem\n(default: 10000, to disable use: 0).\nFor the case where there are a lot of data modification operations, a higher\nvalue could potentially have the data store consume more space and file handles.\nFor the case where there are a few data modification operations, a lower value\nwill impact performance due to no segment candidates available for\nconsolidation.\n_Background:_\n  For data modification ArangoSearch Views follow the concept of a\n  \"versioned data store\". Thus old versions of data may be removed once there\n  are no longer any users of the old data. The frequency of the cleanup and\n  compaction operations are governed by 'consolidationIntervalMsec' and the\n  candidates for compaction are selected via 'consolidationPolicy'.\n"}, "consolidationPolicy": {"type": "object", "description": "The consolidation policy to apply for selecting which segments should be merged\n(default: {})\n_Background:_\n  With each ArangoDB transaction that inserts documents one or more\n  ArangoSearch internal segments gets created.\n  Similarly for removed documents the segments that contain such documents\n  will have these documents marked as 'deleted'.\n  Over time this approach causes a lot of small and sparse segments to be\n  created.\n  A \"consolidation\" operation selects one or more segments and copies all of\n  their valid documents into a single new segment, thereby allowing the\n  search algorithm to perform more optimally and for extra file handles to be\n  released once old segments are no longer used.\nSub-properties:\n  - `type` (string, _optional_):\n    The segment candidates for the \"consolidation\" operation are selected based\n    upon several possible configurable formulas as defined by their types.\n    The currently supported types are:\n    - `\"tier\"` (default): consolidate based on segment byte size and live\n      document count as dictated by the customization attributes. If this type\n      is used, then below `segments*` and `minScore` properties are available.\n    - `\"bytes_accum\"`: consolidate if and only if\n      `{threshold} > (segment_bytes + sum_of_merge_candidate_segment_bytes) / all_segment_bytes`\n      i.e. the sum of all candidate segment byte size is less than the total\n      segment byte size multiplied by the `{threshold}`. If this type is used,\n      then below `threshold` property is available.\n  - `threshold` (number, _optional_): value in the range `[0.0, 1.0]`\n  - `segmentsBytesFloor` (number, _optional_): Defines the value (in bytes) to\n    treat all smaller segments as equal for consolidation selection\n    (default: 2097152)\n  - `segmentsBytesMax` (number, _optional_): Maximum allowed size of all\n    consolidated segments in bytes (default: 5368709120)\n  - `segmentsMax` (number, _optional_): The maximum number of segments that will\n    be evaluated as candidates for consolidation (default: 10)\n  - `segmentsMin` (number, _optional_): The minimum number of segments that will\n    be evaluated as candidates for consolidation (default: 1)\n  - `minScore` (number, _optional_): (default: 0)\n"}, "writebufferIdle": {"type": "integer", "format": "int64", "description": "Maximum number of writers (segments) cached in the pool\n(default: 64, use 0 to disable, immutable)\n"}, "writebufferActive": {"type": "integer", "format": "int64", "description": "Maximum number of concurrent active writers (segments) that perform a\ntransaction. Other writers (segments) wait till current active writers\n(segments) finish (default: 0, use 0 to disable, immutable)\n"}, "writebufferSizeMax": {"type": "integer", "format": "int64", "description": "Maximum memory byte size per writer (segment) before a writer (segment) flush\nis triggered. `0` value turns off this limit for any writer (buffer) and data\nwill be flushed periodically based on the value defined for the flush thread\n(ArangoDB server startup option). `0` value should be used carefully due to\nhigh potential memory consumption\n(default: 33554432, use 0 to disable, immutable)\n"}}, "required": ["name", "type"]}}}}, "responses": {"400": {"description": "If the *name* or *type* attribute are missing or invalid, then an *HTTP 400*\nerror is returned.\n"}, "409": {"description": "If a View called *name* already exists, then an *HTTP 409* error is returned.\n"}}, "tags": ["Views"]}}, "/_api/view/{view-name}/properties#ArangoSearch": {"put": {"description": "Changes the properties of a View by replacing them.\nOn success an object with the following attributes is returned:\n- *id*: The identifier of the View\n- *name*: The name of the View\n- *type*: The View type\n- all additional ArangoSearch View implementation specific properties\n", "operationId": " modifyView", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"links": {"type": "object", "description": "Expects an object with the attribute keys being names of to be linked collections,\nand the link properties as attribute values. See\n[ArangoSearch View Link Properties](https://www.arangodb.com/docs/stable/arangosearch-views.html#link-properties)\nfor details.\n"}, "cleanupIntervalStep": {"type": "integer", "format": "int64", "description": "Wait at least this many commits between removing unused files in the\nArangoSearch data directory (default: 2, to disable use: 0).\nFor the case where the consolidation policies merge segments often (i.e. a lot\nof commit+consolidate), a lower value will cause a lot of disk space to be\nwasted.\nFor the case where the consolidation policies rarely merge segments (i.e. few\ninserts/deletes), a higher value will impact performance without any added\nbenefits.\n_Background:_\n  With every \"commit\" or \"consolidate\" operation a new state of the View\n  internal data-structures is created on disk.\n  Old states/snapshots are released once there are no longer any users\n  remaining.\n  However, the files for the released states/snapshots are left on disk, and\n  only removed by \"cleanup\" operation.\n"}, "commitIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between committing View data store\nchanges and making documents visible to queries (default: 1000, to disable\nuse: 0).\nFor the case where there are a lot of inserts/updates, a lower value, until\ncommit, will cause the index not to account for them and memory usage would\ncontinue to grow.\nFor the case where there are a few inserts/updates, a higher value will impact\nperformance and waste disk space for each commit call without any added\nbenefits.\n_Background:_\n  For data retrieval ArangoSearch Views follow the concept of\n  \"eventually-consistent\", i.e. eventually all the data in ArangoDB will be\n  matched by corresponding query expressions.\n  The concept of ArangoSearch View \"commit\" operation is introduced to\n  control the upper-bound on the time until document addition/removals are\n  actually reflected by corresponding query expressions.\n  Once a \"commit\" operation is complete all documents added/removed prior to\n  the start of the \"commit\" operation will be reflected by queries invoked in\n  subsequent ArangoDB transactions, in-progress ArangoDB transactions will\n  still continue to return a repeatable-read state.\n"}, "consolidationIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between applying 'consolidationPolicy' to\nconsolidate View data store and possibly release space on the filesystem\n(default: 10000, to disable use: 0).\nFor the case where there are a lot of data modification operations, a higher\nvalue could potentially have the data store consume more space and file handles.\nFor the case where there are a few data modification operations, a lower value\nwill impact performance due to no segment candidates available for\nconsolidation.\n_Background:_\n  For data modification ArangoSearch Views follow the concept of a\n  \"versioned data store\". Thus old versions of data may be removed once there\n  are no longer any users of the old data. The frequency of the cleanup and\n  compaction operations are governed by 'consolidationIntervalMsec' and the\n  candidates for compaction are selected via 'consolidationPolicy'.\n"}, "consolidationPolicy": {"type": "object", "description": "The consolidation policy to apply for selecting which segments should be merged\n(default: {})\n_Background:_\n  With each ArangoDB transaction that inserts documents one or more\n  ArangoSearch internal segments gets created.\n  Similarly for removed documents the segments that contain such documents\n  will have these documents marked as 'deleted'.\n  Over time this approach causes a lot of small and sparse segments to be\n  created.\n  A \"consolidation\" operation selects one or more segments and copies all of\n  their valid documents into a single new segment, thereby allowing the\n  search algorithm to perform more optimally and for extra file handles to be\n  released once old segments are no longer used.\nSub-properties:\n  - `type` (string, _optional_):\n    The segment candidates for the \"consolidation\" operation are selected based\n    upon several possible configurable formulas as defined by their types.\n    The currently supported types are:\n    - `\"tier\"` (default): consolidate based on segment byte size and live\n      document count as dictated by the customization attributes. If this type\n      is used, then below `segments*` and `minScore` properties are available.\n    - `\"bytes_accum\"`: consolidate if and only if\n      `{threshold} > (segment_bytes + sum_of_merge_candidate_segment_bytes) / all_segment_bytes`\n      i.e. the sum of all candidate segment byte size is less than the total\n      segment byte size multiplied by the `{threshold}`. If this type is used,\n      then below `threshold` property is available.\n  - `threshold` (number, _optional_): value in the range `[0.0, 1.0]`\n  - `segmentsBytesFloor` (number, _optional_): Defines the value (in bytes) to\n    treat all smaller segments as equal for consolidation selection\n    (default: 2097152)\n  - `segmentsBytesMax` (number, _optional_): Maximum allowed size of all\n    consolidated segments in bytes (default: 5368709120)\n  - `segmentsMax` (number, _optional_): The maximum number of segments that will\n    be evaluated as candidates for consolidation (default: 10)\n  - `segmentsMin` (number, _optional_): The minimum number of segments that will\n    be evaluated as candidates for consolidation (default: 1)\n  - `minScore` (number, _optional_): (default: 0)\n"}}, "required": []}}}}, "responses": {"400": {"description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Views"]}, "patch": {"description": "Changes the properties of a View by updating the specified attributes.\nOn success an object with the following attributes is returned:\n- *id*: The identifier of the View\n- *name*: The name of the View\n- *type*: The View type\n- all additional ArangoSearch View implementation specific properties\n", "operationId": " modifyViewPartial", "parameters": [{"name": "view-name", "schema": {"type": "string"}, "required": true, "description": "The name of the View.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"links": {"type": "object", "description": "Expects an object with the attribute keys being names of to be linked collections,\nand the link properties as attribute values. See\n[ArangoSearch View Link Properties](https://www.arangodb.com/docs/stable/arangosearch-views.html#link-properties)\nfor details.\n"}, "cleanupIntervalStep": {"type": "integer", "format": "int64", "description": "Wait at least this many commits between removing unused files in the\nArangoSearch data directory (default: 2, to disable use: 0).\nFor the case where the consolidation policies merge segments often (i.e. a lot\nof commit+consolidate), a lower value will cause a lot of disk space to be\nwasted.\nFor the case where the consolidation policies rarely merge segments (i.e. few\ninserts/deletes), a higher value will impact performance without any added\nbenefits.\n_Background:_\n  With every \"commit\" or \"consolidate\" operation a new state of the View\n  internal data-structures is created on disk.\n  Old states/snapshots are released once there are no longer any users\n  remaining.\n  However, the files for the released states/snapshots are left on disk, and\n  only removed by \"cleanup\" operation.\n"}, "commitIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between committing View data store\nchanges and making documents visible to queries (default: 1000, to disable\nuse: 0).\nFor the case where there are a lot of inserts/updates, a lower value, until\ncommit, will cause the index not to account for them and memory usage would\ncontinue to grow.\nFor the case where there are a few inserts/updates, a higher value will impact\nperformance and waste disk space for each commit call without any added\nbenefits.\n_Background:_\n  For data retrieval ArangoSearch Views follow the concept of\n  \"eventually-consistent\", i.e. eventually all the data in ArangoDB will be\n  matched by corresponding query expressions.\n  The concept of ArangoSearch View \"commit\" operation is introduced to\n  control the upper-bound on the time until document addition/removals are\n  actually reflected by corresponding query expressions.\n  Once a \"commit\" operation is complete all documents added/removed prior to\n  the start of the \"commit\" operation will be reflected by queries invoked in\n  subsequent ArangoDB transactions, in-progress ArangoDB transactions will\n  still continue to return a repeatable-read state.\n"}, "consolidationIntervalMsec": {"type": "integer", "format": "int64", "description": "Wait at least this many milliseconds between applying 'consolidationPolicy' to\nconsolidate View data store and possibly release space on the filesystem\n(default: 10000, to disable use: 0).\nFor the case where there are a lot of data modification operations, a higher\nvalue could potentially have the data store consume more space and file handles.\nFor the case where there are a few data modification operations, a lower value\nwill impact performance due to no segment candidates available for\nconsolidation.\n_Background:_\n  For data modification ArangoSearch Views follow the concept of a\n  \"versioned data store\". Thus old versions of data may be removed once there\n  are no longer any users of the old data. The frequency of the cleanup and\n  compaction operations are governed by 'consolidationIntervalMsec' and the\n  candidates for compaction are selected via 'consolidationPolicy'.\n"}, "consolidationPolicy": {"type": "object", "description": "The consolidation policy to apply for selecting which segments should be merged\n(default: {})\n_Background:_\n  With each ArangoDB transaction that inserts documents one or more\n  ArangoSearch internal segments gets created.\n  Similarly for removed documents the segments that contain such documents\n  will have these documents marked as 'deleted'.\n  Over time this approach causes a lot of small and sparse segments to be\n  created.\n  A \"consolidation\" operation selects one or more segments and copies all of\n  their valid documents into a single new segment, thereby allowing the\n  search algorithm to perform more optimally and for extra file handles to be\n  released once old segments are no longer used.\nSub-properties:\n  - `type` (string, _optional_):\n    The segment candidates for the \"consolidation\" operation are selected based\n    upon several possible configurable formulas as defined by their types.\n    The currently supported types are:\n    - `\"tier\"` (default): consolidate based on segment byte size and live\n      document count as dictated by the customization attributes. If this type\n      is used, then below `segments*` and `minScore` properties are available.\n    - `\"bytes_accum\"`: consolidate if and only if\n      `{threshold} > (segment_bytes + sum_of_merge_candidate_segment_bytes) / all_segment_bytes`\n      i.e. the sum of all candidate segment byte size is less than the total\n      segment byte size multiplied by the `{threshold}`. If this type is used,\n      then below `threshold` property is available.\n  - `threshold` (number, _optional_): value in the range `[0.0, 1.0]`\n  - `segmentsBytesFloor` (number, _optional_): Defines the value (in bytes) to\n    treat all smaller segments as equal for consolidation selection\n    (default: 2097152)\n  - `segmentsBytesMax` (number, _optional_): Maximum allowed size of all\n    consolidated segments in bytes (default: 5368709120)\n  - `segmentsMax` (number, _optional_): The maximum number of segments that will\n    be evaluated as candidates for consolidation (default: 10)\n  - `segmentsMin` (number, _optional_): The minimum number of segments that will\n    be evaluated as candidates for consolidation (default: 1)\n  - `minScore` (number, _optional_): (default: 0)\n"}}, "required": []}}}}, "responses": {"400": {"description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n"}, "404": {"description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n"}}, "tags": ["Views"]}}, "/_api/replication/server-id": {"get": {"description": "Returns the servers id. The id is also returned by other replication API\nmethods, and this method is an easy means of determining a server's id.\nThe body of the response is a JSON object with the attribute *serverId*. The\nserver id is returned as a string.\n", "operationId": " handleCommandServerId", "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/applier-config": {"get": {"description": "Returns the configuration of the replication applier.\nThe body of the response is a JSON object with the configuration. The\nfollowing attributes may be present in the configuration:\n- *endpoint*: the logger server to connect to (e.g. \"tcp://192.168.173.13:8529\").\n- *database*: the name of the database to connect to (e.g. \"_system\").\n- *username*: an optional ArangoDB username to use when connecting to the endpoint.\n- *password*: the password to use when connecting to the endpoint.\n- *maxConnectRetries*: the maximum number of connection attempts the applier\n  will make in a row. If the applier cannot establish a connection to the\n  endpoint in this number of attempts, it will stop itself.\n- *connectTimeout*: the timeout (in seconds) when attempting to connect to the\n  endpoint. This value is used for each connection attempt.\n- *requestTimeout*: the timeout (in seconds) for individual requests to the endpoint.\n- *chunkSize*: the requested maximum size for log transfer packets that\n  is used when the endpoint is contacted.\n- *autoStart*: whether or not to auto-start the replication applier on\n  (next and following) server starts\n- *adaptivePolling*: whether or not the replication applier will use\n  adaptive polling.\n- *includeSystem*: whether or not system collection operations will be applied\n- *autoResync*: whether or not the follower should perform a full automatic\n  resynchronization with the leader in case the leader cannot serve log data\n  requested by the follower, or when the replication is started and no tick\n  value\n  can be found.\n- *autoResyncRetries*: number of resynchronization retries that will be performed\n  in a row when automatic resynchronization is enabled and kicks in. Setting this\n  to *0* will effectively disable *autoResync*. Setting it to some other value\n  will limit the number of retries that are performed. This helps preventing endless\n  retries in case resynchronizations always fail.\n- *initialSyncMaxWaitTime*: the maximum wait time (in seconds) that the initial\n  synchronization will wait for a response from the leader when fetching initial\n  collection data.\n  This wait time can be used to control after what time the initial synchronization\n  will give up waiting for a response and fail. This value is relevant even\n  for continuous replication when *autoResync* is set to *true* because this\n  may re-start the initial synchronization when the leader cannot provide\n  log data the follwer requires.\n  This value will be ignored if set to *0*.\n- *connectionRetryWaitTime*: the time (in seconds) that the applier will\n  intentionally idle before it retries connecting to the leader in case of\n  connection problems.\n  This value will be ignored if set to *0*.\n- *idleMinWaitTime*: the minimum wait time (in seconds) that the applier will\n  intentionally idle before fetching more log data from the leader in case\n  the leader has already sent all its log data. This wait time can be used\n  to control the frequency with which the replication applier sends HTTP log\n  fetch requests to the leader in case there is no write activity on the leader.\n  This value will be ignored if set to *0*.\n- *idleMaxWaitTime*: the maximum wait time (in seconds) that the applier will\n  intentionally idle before fetching more log data from the leader in case the\n  leader has already sent all its log data and there have been previous log\n  fetch attempts that resulted in no more log data. This wait time can be used\n  to control the maximum frequency with which the replication applier sends HTTP\n  log fetch requests to the leader in case there is no write activity on the\n  leader for longer periods. This configuration value will only be used if the\n  option *adaptivePolling* is set to *true*.\n  This value will be ignored if set to *0*.\n- *requireFromPresent*: if set to *true*, then the replication applier will check\n  at start whether the start tick from which it starts or resumes replication is\n  still present on the leader. If not, then there would be data loss. If\n  *requireFromPresent* is *true*, the replication applier will abort with an\n  appropriate error message. If set to *false*, then the replication applier will\n  still start, and ignore the data loss.\n- *verbose*: if set to *true*, then a log line will be emitted for all operations\n  performed by the replication applier. This should be used for debugging\n  replication\n  problems only.\n- *restrictType*: the configuration for *restrictCollections*\n- *restrictCollections*: the optional array of collections to include or exclude,\n  based on the setting of *restrictType*\n", "operationId": " handleCommandApplierGetConfig", "parameters": [{"name": "global", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, returns the configuration of the global replication applier for all\ndatabases. If set to *false*, returns the configuration of the replication applier in the\nselected database.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}, "put": {"description": "Sets the configuration of the replication applier. The configuration can\nonly be changed while the applier is not running. The updated configuration\nwill be saved immediately but only become active with the next start of the\napplier.\nIn case of success, the body of the response is a JSON object with the updated\nconfiguration.\n", "operationId": "handleCommandApplierSetConfig", "parameters": [{"name": "global", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, adjusts the configuration of the global replication applier for all\ndatabases. If set to *false*, adjusts the configuration of the replication applier in the\nselected database.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"endpoint": {"type": "string", "description": "the logger server to connect to (e.g. \"tcp://192.168.173.13:8529\"). The endpoint must be specified.\n"}, "database": {"type": "string", "description": "the name of the database on the endpoint. If not specified, defaults to the current local database name.\n"}, "username": {"type": "string", "description": "an optional ArangoDB username to use when connecting to the endpoint.\n"}, "password": {"type": "string", "description": "the password to use when connecting to the endpoint.\n"}, "maxConnectRetries": {"type": "integer", "format": "int64", "description": "the maximum number of connection attempts the applier\nwill make in a row. If the applier cannot establish a connection to the\nendpoint in this number of attempts, it will stop itself.\n"}, "connectTimeout": {"type": "integer", "format": "int64", "description": "the timeout (in seconds) when attempting to connect to the\nendpoint. This value is used for each connection attempt.\n"}, "requestTimeout": {"type": "integer", "format": "int64", "description": "the timeout (in seconds) for individual requests to the endpoint.\n"}, "chunkSize": {"type": "integer", "format": "int64", "description": "the requested maximum size for log transfer packets that\nis used when the endpoint is contacted.\n"}, "autoStart": {"type": "boolean", "description": "whether or not to auto-start the replication applier on\n(next and following) server starts\n"}, "adaptivePolling": {"type": "boolean", "description": "if set to *true*, the replication applier will fall\nto sleep for an increasingly long period in case the logger server at the\nendpoint does not have any more replication events to apply. Using\nadaptive polling is thus useful to reduce the amount of work for both the\napplier and the logger server for cases when there are only infrequent\nchanges. The downside is that when using adaptive polling, it might take\nlonger for the replication applier to detect that there are new replication\nevents on the logger server.\nSetting *adaptivePolling* to false will make the replication applier\ncontact the logger server in a constant interval, regardless of whether\nthe logger server provides updates frequently or seldom.\n"}, "includeSystem": {"type": "boolean", "description": "whether or not system collection operations will be applied\n"}, "autoResync": {"type": "boolean", "description": "whether or not the follower should perform a full automatic resynchronization\nwith the leader in case the leader cannot serve log data requested by the\nfollower, or when the replication is started and no tick value can be found.\n"}, "autoResyncRetries": {"type": "integer", "format": "int64", "description": "number of resynchronization retries that will be performed in a row when\nautomatic resynchronization is enabled and kicks in. Setting this to *0*\nwill\neffectively disable *autoResync*. Setting it to some other value will limit\nthe number of retries that are performed. This helps preventing endless\nretries\nin case resynchronizations always fail.\n"}, "initialSyncMaxWaitTime": {"type": "integer", "format": "int64", "description": "the maximum wait time (in seconds) that the initial synchronization will\nwait for a response from the leader when fetching initial collection data.\nThis wait time can be used to control after what time the initial\nsynchronization\nwill give up waiting for a response and fail. This value is relevant even\nfor continuous replication when *autoResync* is set to *true* because this\nmay re-start the initial synchronization when the leader cannot provide\nlog data the follower requires.\nThis value will be ignored if set to *0*.\n"}, "connectionRetryWaitTime": {"type": "integer", "format": "int64", "description": "the time (in seconds) that the applier will intentionally idle before\nit retries connecting to the leader in case of connection problems.\nThis value will be ignored if set to *0*.\n"}, "idleMinWaitTime": {"type": "integer", "format": "int64", "description": "the minimum wait time (in seconds) that the applier will intentionally idle\nbefore fetching more log data from the leader in case the leader has\nalready sent all its log data. This wait time can be used to control the\nfrequency with which the replication applier sends HTTP log fetch requests\nto the leader in case there is no write activity on the leader.\nThis value will be ignored if set to *0*.\n"}, "idleMaxWaitTime": {"type": "integer", "format": "int64", "description": "the maximum wait time (in seconds) that the applier will intentionally idle\nbefore fetching more log data from the leader in case the leader has\nalready sent all its log data and there have been previous log fetch attempts\nthat resulted in no more log data. This wait time can be used to control the\nmaximum frequency with which the replication applier sends HTTP log fetch\nrequests to the leader in case there is no write activity on the leader for\nlonger periods. This configuration value will only be used if the option\n*adaptivePolling* is set to *true*.\nThis value will be ignored if set to *0*.\n"}, "requireFromPresent": {"type": "boolean", "description": "if set to *true*, then the replication applier will check\nat start whether the start tick from which it starts or resumes replication is\nstill present on the leader. If not, then there would be data loss. If\n*requireFromPresent* is *true*, the replication applier will abort with an\nappropriate error message. If set to *false*, then the replication applier will\nstill start, and ignore the data loss.\n"}, "verbose": {"type": "boolean", "description": "if set to *true*, then a log line will be emitted for all operations\nperformed by the replication applier. This should be used for debugging replication\nproblems only.\n"}, "restrictType": {"type": "string", "description": "the configuration for *restrictCollections*; Has to be either *include* or *exclude*\n"}, "restrictCollections": {"type": "array", "items": {"type": "string"}, "description": "the array of collections to include or exclude,\nbased on the setting of *restrictType*\n"}}, "required": ["endpoint", "database", "password", "maxConnectRetries", "connectTimeout", "requestTimeout", "chunkSize", "autoStart", "adaptivePolling", "includeSystem", "requireFromPresent", "verbose", "restrictType"]}}}}, "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "400": {"description": "is returned if the configuration is incomplete or malformed, or if the\nreplication applier is currently running.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/applier-start": {"put": {"description": "Starts the replication applier. This will return immediately if the\nreplication applier is already running.\nIf the replication applier is not already running, the applier configuration\nwill be checked, and if it is complete, the applier will be started in a\nbackground thread. This means that even if the applier will encounter any\nerrors while running, they will not be reported in the response to this\nmethod.\nTo detect replication applier errors after the applier was started, use the\n*/_api/replication/applier-state* API instead.\n", "operationId": "handleCommandApplierStart", "parameters": [{"name": "global", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, starts the global replication applier for all\ndatabases. If set to *false*, starts the replication applier in the\nselected database.\n", "in": "query"}, {"name": "from", "schema": {"type": "string"}, "required": false, "description": "The remote *lastLogTick* value from which to start applying. If not specified,\nthe last saved tick from the previous applier run is used. If there is no\nprevious applier state saved, the applier will start at the beginning of the\nlogger server's log.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "400": {"description": "is returned if the replication applier is not fully configured or the\nconfiguration is invalid.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/applier-stop": {"put": {"description": "Stops the replication applier. This will return immediately if the\nreplication applier is not running.\n", "operationId": "handleCommandApplierStop", "parameters": [{"name": "global", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, stops the global replication applier for all\ndatabases. If set to *false*, stops the replication applier in the\nselected database.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/applier-state": {"get": {"description": "Returns the state of the replication applier, regardless of whether the\napplier is currently running or not.\nThe response is a JSON object with the following attributes:\n- *state*: a JSON object with the following sub-attributes:\n  - *running*: whether or not the applier is active and running\n  - *lastAppliedContinuousTick*: the last tick value from the continuous\n    replication log the applier has applied.\n  - *lastProcessedContinuousTick*: the last tick value from the continuous\n    replication log the applier has processed.\n    Regularly, the last applied and last processed tick values should be\n    identical. For transactional operations, the replication applier will first\n    process incoming log events before applying them, so the processed tick\n    value might be higher than the applied tick value. This will be the case\n    until the applier encounters the *transaction commit* log event for the\n    transaction.\n  - *lastAvailableContinuousTick*: the last tick value the remote server can\n    provide, for all databases.\n  - *ticksBehind*: this attribute will be present only if the applier is currently\n    running. It will provide the number of log ticks between what the applier\n    has applied/seen and the last log tick value provided by the remote server.\n    If this value is zero, then both servers are in sync. If this is non-zero,\n    then the remote server has additional data that the applier has not yet\n    fetched and processed, or the remote server may have more data that is not\n    applicable to the applier.\n    Client applications can use it to determine approximately how far the applier\n    is behind the remote server, and can periodically check if the value is\n    increasing (applier is falling behind) or decreasing (applier is catching up).\n    Please note that as the remote server will only keep one last log tick value\n    for all of its databases, but replication may be restricted to just certain\n    databases on the applier, this value is more meaningful when the global applier\n    is used.\n    Additionally, the last log tick provided by the remote server may increase\n    due to writes into system collections that are not replicated due to replication\n    configuration. So the reported value may exaggerate the reality a bit for\n    some scenarios.\n  - *time*: the time on the applier server.\n  - *totalRequests*: the total number of requests the applier has made to the\n    endpoint.\n  - *totalFailedConnects*: the total number of failed connection attempts the\n    applier has made.\n  - *totalEvents*: the total number of log events the applier has processed.\n  - *totalOperationsExcluded*: the total number of log events excluded because\n    of *restrictCollections*.\n  - *progress*: a JSON object with details about the replication applier progress.\n    It contains the following sub-attributes if there is progress to report:\n    - *message*: a textual description of the progress\n    - *time*: the date and time the progress was logged\n    - *failedConnects*: the current number of failed connection attempts\n  - *lastError*: a JSON object with details about the last error that happened on\n    the applier. It contains the following sub-attributes if there was an error:\n    - *errorNum*: a numerical error code\n    - *errorMessage*: a textual error description\n    - *time*: the date and time the error occurred\n    In case no error has occurred, *lastError* will be empty.\n- *server*: a JSON object with the following sub-attributes:\n  - *version*: the applier server's version\n  - *serverId*: the applier server's id\n- *endpoint*: the endpoint the applier is connected to (if applier is\n  active) or will connect to (if applier is currently inactive)\n- *database*: the name of the database the applier is connected to (if applier is\n  active) or will connect to (if applier is currently inactive)\nPlease note that all \"tick\" values returned do not have a specific unit. Tick\nvalues are only meaningful when compared to each other. Higher tick values mean\n\"later in time\" than lower tick values.\n", "operationId": "handleCommandApplierGetState", "parameters": [{"name": "global", "schema": {"type": "boolean"}, "required": false, "description": "If set to *true*, returns the state of the global replication applier for all\ndatabases. If set to *false*, returns the state of the replication applier in the\nselected database.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/make-follower": {"put": {"description": "Starts a full data synchronization from a remote endpoint into the local ArangoDB\ndatabase and afterwards starts the continuous replication.\nThe operation works on a per-database level.\nAll local database data will be removed prior to the synchronization.\nIn case of success, the body of the response is a JSON object with the following\nattributes:\n- *state*: a JSON object with the following sub-attributes:\n  - *running*: whether or not the applier is active and running\n  - *lastAppliedContinuousTick*: the last tick value from the continuous\n    replication log the applier has applied.\n  - *lastProcessedContinuousTick*: the last tick value from the continuous\n    replication log the applier has processed.\n    Regularly, the last applied and last processed tick values should be\n    identical. For transactional operations, the replication applier will first\n    process incoming log events before applying them, so the processed tick\n    value might be higher than the applied tick value. This will be the case\n    until the applier encounters the *transaction commit* log event for the\n    transaction.\n  - *lastAvailableContinuousTick*: the last tick value the remote server can\n    provide.\n  - *ticksBehind*: this attribute will be present only if the applier is currently\n    running. It will provide the number of log ticks between what the applier\n    has applied/seen and the last log tick value provided by the remote server.\n    If this value is zero, then both servers are in sync. If this is non-zero,\n    then the remote server has additional data that the applier has not yet\n    fetched and processed, or the remote server may have more data that is not\n    applicable to the applier.\n    Client applications can use it to determine approximately how far the applier\n    is behind the remote server, and can periodically check if the value is\n    increasing (applier is falling behind) or decreasing (applier is catching up).\n    Please note that as the remote server will only keep one last log tick value\n    for all of its databases, but replication may be restricted to just certain\n    databases on the applier, this value is more meaningful when the global applier\n    is used.\n    Additionally, the last log tick provided by the remote server may increase\n    due to writes into system collections that are not replicated due to replication\n    configuration. So the reported value may exaggerate the reality a bit for\n    some scenarios.\n  - *time*: the time on the applier server.\n  - *totalRequests*: the total number of requests the applier has made to the\n    endpoint.\n  - *totalFailedConnects*: the total number of failed connection attempts the\n    applier has made.\n  - *totalEvents*: the total number of log events the applier has processed.\n  - *totalOperationsExcluded*: the total number of log events excluded because\n    of *restrictCollections*.\n  - *progress*: a JSON object with details about the replication applier progress.\n    It contains the following sub-attributes if there is progress to report:\n    - *message*: a textual description of the progress\n    - *time*: the date and time the progress was logged\n    - *failedConnects*: the current number of failed connection attempts\n  - *lastError*: a JSON object with details about the last error that happened on\n    the applier. It contains the following sub-attributes if there was an error:\n    - *errorNum*: a numerical error code\n    - *errorMessage*: a textual error description\n    - *time*: the date and time the error occurred\n    In case no error has occurred, *lastError* will be empty.\n- *server*: a JSON object with the following sub-attributes:\n  - *version*: the applier server's version\n  - *serverId*: the applier server's id\n- *endpoint*: the endpoint the applier is connected to (if applier is\n  active) or will connect to (if applier is currently inactive)\n- *database*: the name of the database the applier is connected to (if applier is\n  active) or will connect to (if applier is currently inactive)\nPlease note that all \"tick\" values returned do not have a specific unit. Tick\nvalues are only meaningful when compared to each other. Higher tick values mean\n\"later in time\" than lower tick values.\nWARNING: calling this method will synchronize data from the collections found\non the remote leader to the local ArangoDB database. All data in the local\ncollections will be purged and replaced with data from the leader.\nUse with caution!\nPlease also keep in mind that this command may take a long time to complete\nand return. This is because it will first do a full data synchronization with\nthe leader, which will take time roughly proportional to the amount of data.\n**Note**: this method is not supported on a Coordinator in a cluster.\n", "operationId": " handleCommandMakeFollower", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"endpoint": {"type": "string", "description": "the leader endpoint to connect to (e.g. \"tcp://192.168.173.13:8529\").\n"}, "database": {"type": "string", "description": "the database name on the leader (if not specified, defaults to the\nname of the local current database).\n"}, "username": {"type": "string", "description": "an optional ArangoDB username to use when connecting to the leader.\n"}, "password": {"type": "string", "description": "the password to use when connecting to the leader.\n"}, "includeSystem": {"type": "boolean", "description": "whether or not system collection operations will be applied\n"}, "restrictType": {"type": "string", "description": "an optional string value for collection filtering. When\nspecified, the allowed values are *include* or *exclude*.\n"}, "restrictCollections": {"type": "array", "items": {"type": "string"}, "description": "an optional array of collections for use with *restrictType*.\nIf *restrictType* is *include*, only the specified collections\nwill be synchronized. If *restrictType* is *exclude*, all but the specified\ncollections will be synchronized.\n"}, "maxConnectRetries": {"type": "integer", "format": "int64", "description": "the maximum number of connection attempts the applier\nwill make in a row. If the applier cannot establish a connection to the\nendpoint in this number of attempts, it will stop itself.\n"}, "connectTimeout": {"type": "integer", "format": "int64", "description": "the timeout (in seconds) when attempting to connect to the\nendpoint. This value is used for each connection attempt.\n"}, "requestTimeout": {"type": "integer", "format": "int64", "description": "the timeout (in seconds) for individual requests to the endpoint.\n"}, "chunkSize": {"type": "integer", "format": "int64", "description": "the requested maximum size for log transfer packets that\nis used when the endpoint is contacted.\n"}, "adaptivePolling": {"type": "boolean", "description": "whether or not the replication applier will use adaptive polling.\n"}, "autoResync": {"type": "boolean", "description": "whether or not the follower should perform an automatic resynchronization with\nthe leader in case the leader cannot serve log data requested by the follower,\nor when the replication is started and no tick value can be found.\n"}, "autoResyncRetries": {"type": "integer", "format": "int64", "description": "number of resynchronization retries that will be performed in a row when\nautomatic resynchronization is enabled and kicks in. Setting this to *0* will\neffectively disable *autoResync*. Setting it to some other value will limit\nthe number of retries that are performed. This helps preventing endless retries\nin case resynchronizations always fail.\n"}, "initialSyncMaxWaitTime": {"type": "integer", "format": "int64", "description": "the maximum wait time (in seconds) that the initial synchronization will\nwait for a response from the leader when fetching initial collection data.\nThis wait time can be used to control after what time the initial synchronization\nwill give up waiting for a response and fail. This value is relevant even\nfor continuous replication when *autoResync* is set to *true* because this\nmay re-start the initial synchronization when the leader cannot provide\nlog data the follower requires.\nThis value will be ignored if set to *0*.\n"}, "connectionRetryWaitTime": {"type": "integer", "format": "int64", "description": "the time (in seconds) that the applier will intentionally idle before\nit retries connecting to the leader in case of connection problems.\nThis value will be ignored if set to *0*.\n"}, "idleMinWaitTime": {"type": "integer", "format": "int64", "description": "the minimum wait time (in seconds) that the applier will intentionally idle\nbefore fetching more log data from the leader in case the leader has\nalready sent all its log data. This wait time can be used to control the\nfrequency with which the replication applier sends HTTP log fetch requests\nto the leader in case there is no write activity on the leader.\nThis value will be ignored if set to *0*.\n"}, "idleMaxWaitTime": {"type": "integer", "format": "int64", "description": "the maximum wait time (in seconds) that the applier will intentionally idle\nbefore fetching more log data from the leader in case the leader has\nalready sent all its log data and there have been previous log fetch attempts\nthat resulted in no more log data. This wait time can be used to control the\nmaximum frequency with which the replication applier sends HTTP log fetch\nrequests to the leader in case there is no write activity on the leader for\nlonger periods. This configuration value will only be used if the option\n*adaptivePolling* is set to *true*.\nThis value will be ignored if set to *0*.\n"}, "requireFromPresent": {"type": "boolean", "description": "if set to *true*, then the replication applier will check\nat start of its continuous replication if the start tick from the dump phase\nis still present on the leader. If not, then there would be data loss. If\n*requireFromPresent* is *true*, the replication applier will abort with an\nappropriate error message. If set to *false*, then the replication applier will\nstill start, and ignore the data loss.\n"}, "verbose": {"type": "boolean", "description": "if set to *true*, then a log line will be emitted for all operations\nperformed by the replication applier. This should be used for debugging\nreplication\nproblems only.\n"}}, "required": ["endpoint", "database", "password", "includeSystem"]}}}}, "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "400": {"description": "is returned if the configuration is incomplete or malformed.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred during synchronization or when starting the\ncontinuous replication.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/replication/inventory": {"get": {"description": "\nReturns the array of collections and their indexes, and the array of views available. These\narrays can be used by replication clients to initiate an initial synchronization with the\nserver. \nThe response will contain all collections, their indexes and views in the requested database\nif *global* is not set, and all collections, indexes and views in all databases if *global*\nis set.\nIn case *global* is not set, it is possible to restrict the response to a single collection\nby setting the *collection* parameter. In this case the response will contain only information\nabout the requested collection in the *collections* array, and no information about views\n(i.e. the *views* response attribute will be an empty array).\n\nThe response will contain a JSON object with the *collections*, *views*, *state* and\n*tick* attributes.\n\n*collections* is an array of collections with the following sub-attributes:\n\n- *parameters*: the collection properties\n\n- *indexes*: an array of the indexes of a the collection. Primary indexes and edge indexes\n   are not included in this array.\n\nThe *state* attribute contains the current state of the replication logger. It\ncontains the following sub-attributes:\n\n- *running*: whether or not the replication logger is currently active. Note:\n  since ArangoDB 2.2, the value will always be *true*\n\n- *lastLogTick*: the value of the last tick the replication logger has written\n\n- *time*: the current time on the server\n\n*views* is an array of available views.\n\nReplication clients should note the *lastLogTick* value returned. They can then\nfetch collections' data using the dump method up to the value of lastLogTick, and\nquery the continuous replication log for log events after this tick value.\n\nTo create a full copy of the collections on the server, a replication client\ncan execute these steps:\n\n- call the */inventory* API method. This returns the *lastLogTick* value and the\n  array of collections and indexes from the server.\n\n- for each collection returned by */inventory*, create the collection locally and\n  call */dump* to stream the collection data to the client, up to the value of\n  *lastLogTick*.\n  After that, the client can create the indexes on the collections as they were\n  reported by */inventory*.\n\nIf the clients wants to continuously stream replication log events from the logger\nserver, the following additional steps need to be carried out:\n\n- the client should call */_api/wal/tail* initially to fetch the first batch of\n  replication events that were logged after the client's call to */inventory*.\n\n  The call to */_api/wal/tail* should use a *from* parameter with the value of the\n  *lastLogTick* as reported by */inventory*. The call to */_api/wal/tail* will\n  return the *x-arango-replication-lastincluded* header which will contain the\n  last tick value included in the response.\n\n- the client can then continuously call */_api/wal/tail* to incrementally fetch new\n  replication events that occurred after the last transfer.\n\n  Calls should use a *from* parameter with the value of the *x-arango-replication-lastincluded*\n  header of the previous response. If there are no more replication events, the\n  response will be empty and clients can go to sleep for a while and try again\n  later.\n\n**Note**: on a Coordinator, this request must have the query parameter\n*DBserver* which must be an ID of a DB-Server.\nThe very same request is forwarded synchronously to that DB-Server.\nIt is an error if this attribute is not bound in the Coordinator case.\n\n**Note**: Using the `global` parameter the top-level object contains a key `databases`\nunder which each key represents a database name, and the value conforms to the above description.\n\n", "operationId": " handleCommandInventory", "parameters": [{"name": "includeSystem", "schema": {"type": "boolean"}, "required": false, "description": "Include system collections in the result. The default value is *true*.\n", "in": "query"}, {"name": "global", "schema": {"type": "boolean"}, "required": false, "description": "Include all databases in the response. Only works on `_system` The default value is *false*.\n", "in": "query"}, {"name": "batchId", "schema": {"type": "number"}, "required": true, "description": "A valid batchId is required for this API call\n", "in": "query"}, {"name": "collection", "schema": {"type": "string"}, "required": false, "description": "If this parameter is set, the response will be restricted to a single collection (the one\nspecified), and no views will be returned. This can be used as an optimization to reduce\nthe size of the response.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/batch": {"post": {"description": "Creates a new dump batch and returns the batch's id.\nThe response is a JSON object with the following attributes:\n- *id*: the id of the batch\n- *lastTick*: snapshot tick value using when creating the batch\n- *state*: additional leader state information (only present if the\n  `state` URL parameter was set to `true` in the request)\n**Note**: on a Coordinator, this request must have the query parameter\n*DBserver* which must be an ID of a DB-Server.\nThe very same request is forwarded synchronously to that DB-Server.\nIt is an error if this attribute is not bound in the Coordinator case.\n", "operationId": " handleCommandBatch:Create", "parameters": [{"name": "state", "schema": {"type": "boolean"}, "required": false, "description": "setting `state` to true will make the response also contain\na `state` attribute with information about the leader state.\nThis is used only internally during the replication process \nand should not be used by client applications.\n\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"ttl": {"type": "integer", "format": "int64", "description": "The time-to-live for the new batch (in seconds).\n"}}, "required": ["ttl"]}}}}, "responses": {"200": {"description": "is returned if the batch was created successfully.\n"}, "400": {"description": "is returned if the ttl value is invalid or if *DBserver* attribute\nis not specified or illegal on a Coordinator.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}}, "tags": ["Replication"]}}, "/_api/replication/batch/{id}": {"delete": {"description": "Deletes the existing dump batch, allowing compaction and cleanup to resume.\n**Note**: on a Coordinator, this request must have the query parameter\n*DBserver* which must be an ID of a DB-Server.\nThe very same request is forwarded synchronously to that DB-Server.\nIt is an error if this attribute is not bound in the Coordinator case.\n", "operationId": "handleCommandBatch:DELETE", "parameters": [{"name": "id", "schema": {"type": "string"}, "required": true, "description": "The id of the batch.\n", "in": "path"}], "responses": {"204": {"description": "is returned if the batch was deleted successfully.\n"}, "400": {"description": "is returned if the batch was not found.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}}, "tags": ["Replication"]}, "put": {"description": "Extends the ttl of an existing dump batch, using the batch's id and\nthe provided ttl value.\nIf the batch's ttl can be extended successfully, the response is empty.\n**Note**: on a Coordinator, this request must have the query parameter\n*DBserver* which must be an ID of a DB-Server.\nThe very same request is forwarded synchronously to that DB-Server.\nIt is an error if this attribute is not bound in the Coordinator case.\n", "operationId": " handleCommandBatch:Prolong", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"ttl": {"type": "integer", "format": "int64", "description": "the time-to-live for the new batch (in seconds)\n"}}, "required": ["ttl"]}}}}, "parameters": [{"name": "id", "schema": {"type": "string"}, "required": true, "description": "The id of the batch.\n", "in": "path"}], "responses": {"204": {"description": "is returned if the batch's ttl was extended successfully.\n"}, "400": {"description": "is returned if the ttl value is invalid or the batch was not found.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}}, "tags": ["Replication"]}}, "/_api/replication/dump": {"get": {"description": "Returns the data from the collection for the requested range.\nThe *chunkSize* query parameter can be used to control the size of the result.\nIt must be specified in bytes. The *chunkSize* value will only be honored\napproximately. Otherwise a too low *chunkSize* value could cause the server\nto not be able to put just one entry into the result and return it.\nTherefore, the *chunkSize* value will only be consulted after an entry has\nbeen written into the result. If the result size is then bigger than\n*chunkSize*, the server will respond with as many entries as there are\nin the response already. If the result size is still smaller than *chunkSize*,\nthe server will try to return more data if there's more data left to return.\nIf *chunkSize* is not specified, some server-side default value will be used.\nThe *Content-Type* of the result is *application/x-arango-dump*. This is an\neasy-to-process format, with all entries going onto separate lines in the\nresponse body.\nEach line itself is a JSON object, with at least the following attributes:\n- *tick*: the operation's tick attribute\n- *key*: the key of the document/edge or the key used in the deletion operation\n- *rev*: the revision id of the document/edge or the deletion operation\n- *data*: the actual document/edge data for types 2300 and 2301. The full\n  document/edge data will be returned even for updates.\n- *type*: the type of entry. Possible values for *type* are:\n  - 2300: document insertion/update\n  - 2301: edge insertion/update\n  - 2302: document/edge deletion\n**Note**: there will be no distinction between inserts and updates when calling this method.\n", "operationId": "handleCommandDump", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name or id of the collection to dump.\n", "in": "query"}, {"name": "chunkSize", "schema": {"type": "number"}, "required": false, "description": "Approximate maximum size of the returned result.\n", "in": "query"}, {"name": "batchId", "schema": {"type": "number"}, "required": true, "description": "The id of the snapshot to use\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully and data was returned. The header\n`x-arango-replication-lastincluded` is set to the tick of the last document returned.\n"}, "204": {"description": "is returned if the request was executed successfully, but there was no content available.\nThe header `x-arango-replication-lastincluded` is `0` in this case.\n"}, "404": {"description": "is returned when the collection could not be found.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/revisions/tree": {"get": {"description": "Returns the Merkle tree from the collection.\nThe result will be JSON/VelocyPack in the following format:\n"}, "post": {"description": "Rebuilds the Merkle tree for the collection.\nIf successful, there will be no return body.\n", "operationId": "handleCommandRebuildRevisionTree", "parameters": [{"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name or id of the collection to query.\n", "in": "query"}], "responses": {"204": {"description": "is returned if the request was executed successfully.\n"}, "401": {"description": "is returned if necessary parameters are missing\n"}, "404": {"description": "is returned when the collection or could not be found.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}, "501": {"description": "is returned if called on a collection which doesn't support sync-by-revision\n"}}, "tags": ["Replication"]}}, "/_api/replication/revisions/ranges": {"put": {"description": "Returns the revision IDs of documents within requested ranges\nThe body of the request should be JSON/VelocyPack and should consist of an\narray of pairs of string-encoded revision IDs:\n"}}, "/_api/replication/revisions/documents": {"put": {"description": "Returns documents by revision\nThe body of the request should be JSON/VelocyPack and should consist of an\narray of string-encoded revision IDs:\n"}}, "/_api/replication/sync": {"put": {"description": "Starts a full data synchronization from a remote endpoint into the local\nArangoDB database.\nThe *sync* method can be used by replication clients to connect an ArangoDB database\nto a remote endpoint, fetch the remote list of collections and indexes, and collection\ndata. It will thus create a local backup of the state of data at the remote ArangoDB\ndatabase. *sync* works on a per-database level.\n*sync* will first fetch the list of collections and indexes from the remote endpoint.\nIt does so by calling the *inventory* API of the remote database. It will then purge\ndata in the local ArangoDB database, and after start will transfer collection data\nfrom the remote database to the local ArangoDB database. It will extract data from the\nremote database by calling the remote database's *dump* API until all data are fetched.\nIn case of success, the body of the response is a JSON object with the following\nattributes:\n- *collections*: an array of collections that were transferred from the endpoint\n- *lastLogTick*: the last log tick on the endpoint at the time the transfer\n  was started. Use this value as the *from* value when starting the continuous\n  synchronization later.\nWARNING: calling this method will synchronize data from the collections found\non the remote endpoint to the local ArangoDB database. All data in the local\ncollections will be purged and replaced with data from the endpoint.\nUse with caution!\n**Note**: this method is not supported on a Coordinator in a cluster.\n", "operationId": " handleCommandSync", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"endpoint": {"type": "string", "description": "the leader endpoint to connect to (e.g. \"tcp://192.168.173.13:8529\").\n"}, "database": {"type": "string", "description": "the database name on the leader (if not specified, defaults to the\nname of the local current database).\n"}, "username": {"type": "string", "description": "an optional ArangoDB username to use when connecting to the endpoint.\n"}, "password": {"type": "string", "description": "the password to use when connecting to the endpoint.\n"}, "includeSystem": {"type": "boolean", "description": "whether or not system collection operations will be applied\n"}, "incremental": {"type": "boolean", "description": "if set to *true*, then an incremental synchronization method will be used\nfor synchronizing data in collections. This method is useful when\ncollections already exist locally, and only the remaining differences need\nto be transferred from the remote endpoint. In this case, the incremental\nsynchronization can be faster than a full synchronization.\nThe default value is *false*, meaning that the complete data from the remote\ncollection will be transferred.\n"}, "restrictType": {"type": "string", "description": "an optional string value for collection filtering. When\nspecified, the allowed values are *include* or *exclude*.\n"}, "restrictCollections": {"type": "array", "items": {"type": "string"}, "description": "an optional array of collections for use with\n*restrictType*. If *restrictType* is *include*, only the specified collections\nwill be synchronized. If *restrictType* is *exclude*, all but the specified\ncollections will be synchronized.\n"}, "initialSyncMaxWaitTime": {"type": "integer", "format": "int64", "description": "the maximum wait time (in seconds) that the initial synchronization will\nwait for a response from the leader when fetching initial collection data.\nThis wait time can be used to control after what time the initial synchronization\nwill give up waiting for a response and fail.\nThis value will be ignored if set to *0*.\n"}}, "required": ["endpoint", "password"]}}}}, "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "400": {"description": "is returned if the configuration is incomplete or malformed.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred during synchronization.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/replication/clusterInventory": {"get": {"description": "Returns the array of collections and indexes available on the cluster.\nThe response will be an array of JSON objects, one for each collection.\nEach collection containscontains exactly two keys \"parameters\" and\n\"indexes\". This\ninformation comes from Plan/Collections/{DB-Name}/* in the Agency,\njust that the *indexes* attribute there is relocated to adjust it to\nthe data format of arangodump.\n", "operationId": " handleCommandClusterInventory", "parameters": [{"name": "includeSystem", "schema": {"type": "boolean"}, "required": false, "description": "Include system collections in the result. The default value is *true*.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}}, "tags": ["Replication"]}}, "/_api/replication/logger-state": {"get": {"description": "Returns the current state of the server's replication logger. The state will\ninclude information about whether the logger is running and about the last\nlogged tick value. This tick value is important for incremental fetching of\ndata.\nThe body of the response contains a JSON object with the following\nattributes:\n- *state*: the current logger state as a JSON object with the following\n  sub-attributes:\n  - *running*: whether or not the logger is running\n  - *lastLogTick*: the tick value of the latest tick the logger has logged.\n    This value can be used for incremental fetching of log data.\n  - *totalEvents*: total number of events logged since the server was started.\n    The value is not reset between multiple stops and re-starts of the logger.\n  - *time*: the current date and time on the logger server\n- *server*: a JSON object with the following sub-attributes:\n  - *version*: the logger server's version\n  - *serverId*: the logger server's id\n- *clients*: returns the last fetch status by replication clients connected to\n  the logger. Each client is returned as a JSON object with the following attributes:\n  - *syncerId*: id of the client syncer\n  - *serverId*: server id of client\n  - *lastServedTick*: last tick value served to this client via the WAL tailing API\n  - *time*: date and time when this client last called the WAL tailing API\n", "operationId": " handleCommandLoggerState", "responses": {"200": {"description": "is returned if the logger state could be determined successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if the logger state could not be determined.\n"}}, "tags": ["Replication"]}}, "/_api/replication/logger-follow": {"get": {"description": "Returns data from the server's replication log. This method can be called\nby replication clients after an initial synchronization of data. The method\nwill return all \"recent\" log entries from the logger server, and the clients\ncan replay and apply these entries locally so they get to the same data\nstate as the logger server.\nClients can call this method repeatedly to incrementally fetch all changes\nfrom the logger server. In this case, they should provide the *from* value so\nthey will only get returned the log events since their last fetch.\nWhen the *from* query parameter is not used, the logger server will return log\nentries starting at the beginning of its replication log. When the *from*\nparameter is used, the logger server will only return log entries which have\nhigher tick values than the specified *from* value (note: the log entry with a\ntick value equal to *from* will be excluded). Use the *from* value when\nincrementally fetching log data.\nThe *to* query parameter can be used to optionally restrict the upper bound of\nthe result to a certain tick value. If used, the result will contain only log events\nwith tick values up to (including) *to*. In incremental fetching, there is no\nneed to use the *to* parameter. It only makes sense in special situations,\nwhen only parts of the change log are required.\nThe *chunkSize* query parameter can be used to control the size of the result.\nIt must be specified in bytes. The *chunkSize* value will only be honored\napproximately. Otherwise a too low *chunkSize* value could cause the server\nto not be able to put just one log entry into the result and return it.\nTherefore, the *chunkSize* value will only be consulted after a log entry has\nbeen written into the result. If the result size is then bigger than\n*chunkSize*, the server will respond with as many log entries as there are\nin the response already. If the result size is still smaller than *chunkSize*,\nthe server will try to return more data if there's more data left to return.\nIf *chunkSize* is not specified, some server-side default value will be used.\nThe *Content-Type* of the result is *application/x-arango-dump*. This is an\neasy-to-process format, with all log events going onto separate lines in the\nresponse body. Each log event itself is a JSON object, with at least the\nfollowing attributes:\n- *tick*: the log event tick value\n- *type*: the log event type\nIndividual log events will also have additional attributes, depending on the\nevent type. A few common attributes which are used for multiple events types\nare:\n- *cid*: id of the collection the event was for\n- *tid*: id of the transaction the event was contained in\n- *key*: document key\n- *rev*: document revision id\n- *data*: the original document data\nThe response will also contain the following HTTP headers:\n- *x-arango-replication-active*: whether or not the logger is active. Clients\n  can use this flag as an indication for their polling frequency. If the\n  logger is not active and there are no more replication events available, it\n  might be sensible for a client to abort, or to go to sleep for a long time\n  and try again later to check whether the logger has been activated.\n- *x-arango-replication-lastincluded*: the tick value of the last included\n  value in the result. In incremental log fetching, this value can be used\n  as the *from* value for the following request. **Note** that if the result is\n  empty, the value will be *0*. This value should not be used as *from* value\n  by clients in the next request (otherwise the server would return the log\n  events from the start of the log again).\n- *x-arango-replication-lasttick*: the last tick value the logger server has\n  logged (not necessarily included in the result). By comparing the the last\n  tick and last included tick values, clients have an approximate indication of\n  how many events there are still left to fetch.\n- *x-arango-replication-checkmore*: whether or not there already exists more\n  log data which the client could fetch immediately. If there is more log data\n  available, the client could call *logger-follow* again with an adjusted *from*\n  value to fetch remaining log entries until there are no more.\n  If there isn't any more log data to fetch, the client might decide to go\n  to sleep for a while before calling the logger again.\n**Note**: this method is not supported on a Coordinator in a cluster.\n", "operationId": " handleCommandLoggerFollow", "parameters": [{"name": "from", "schema": {"type": "number"}, "required": false, "description": "Exclusive lower bound tick value for results.\n", "in": "query"}, {"name": "to", "schema": {"type": "number"}, "required": false, "description": "Inclusive upper bound tick value for results.\n", "in": "query"}, {"name": "chunkSize", "schema": {"type": "number"}, "required": false, "description": "Approximate maximum size of the returned result.\n", "in": "query"}, {"name": "includeSystem", "schema": {"type": "boolean"}, "required": false, "description": "Include system collections in the result. The default value is *true*.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully, and there are log\nevents available for the requested range. The response body will not be empty\nin this case.\n"}, "204": {"description": "is returned if the request was executed successfully, but there are no log\nevents available for the requested range. The response body will be empty\nin this case.\n"}, "400": {"description": "is returned if either the *from* or *to* values are invalid.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/replication/logger-first-tick": {"get": {"description": "Returns the first available tick value that can be served from the server's\nreplication log. This method can be called by replication clients after to\ndetermine if certain data (identified by a tick value) is still available\nfor replication.\nThe result is a JSON object containing the attribute *firstTick*. This\nattribute contains the minimum tick value available in the server's\nreplication\nlog.\n**Note**: this method is not supported on a Coordinator in a cluster.\n", "operationId": " handleCommandLoggerFirstTick", "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/replication/logger-tick-ranges": {"get": {"description": "Returns the currently available ranges of tick values for all currently\navailable WAL logfiles. The tick values can be used to determine if certain\ndata (identified by tick value) are still available for replication.\nThe body of the response contains a JSON array. Each array member is an\nobject\nthat describes a single logfile. Each object has the following attributes:\n* *datafile*: name of the logfile\n* *status*: status of the datafile, in textual form (e.g. \"sealed\", \"open\")\n* *tickMin*: minimum tick value contained in logfile\n* *tickMax*: maximum tick value contained in logfile\n", "operationId": "handleCommandLoggerTickRanges", "responses": {"200": {"description": "is returned if the tick ranges could be determined successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if the logger state could not be determined.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/wal/range": {"get": {"description": "Returns the currently available ranges of tick values for all WAL files.\nThe tick values can be used to determine if certain\ndata (identified by tick value) are still available for replication.\nThe body of the response contains a JSON object.\n* *tickMin*: minimum tick available\n* *tickMax*: maximum tick available\n* *time*: the server time as string in format \"YYYY-MM-DDTHH:MM:SSZ\"\n* *server*: An object with fields *version* and *serverId*\n", "operationId": " handleCommandTickRange", "responses": {"200": {"description": "is returned if the tick ranges could be determined successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if the server operations state could not be determined.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/wal/lastTick": {"get": {"description": "Returns the last available tick value that can be served from the server's\nreplication log. This corresponds to the tick of the latest successfull operation.\nThe result is a JSON object containing the attributes *tick*, *time* and *server*.\n* *tick*: contains the last available tick, *time*\n* *time*: the server time as string in format \"YYYY-MM-DDTHH:MM:SSZ\"\n* *server*: An object with fields *version* and *serverId*\n**Note**: this method is not supported on a Coordinator in a cluster.\n", "operationId": " handleCommandLastTick", "responses": {"200": {"description": "is returned if the request was executed successfully.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/wal/tail": {"get": {"description": "Returns data from the server's write-ahead log (also named replication log). This method can be called\nby replication clients after an initial synchronization of data. The method\nreturns all \"recent\" logged operations from the server. Clients\ncan replay and apply these operations locally so they get to the same data\nstate as the server.\nClients can call this method repeatedly to incrementally fetch all changes\nfrom the server. In this case, they should provide the `from` value so\nthey only get returned the log events since their last fetch.\nWhen the `from` query parameter is not used, the server returns log\nentries starting at the beginning of its replication log. When the `from`\nparameter is used, the server only returns log entries which have\nhigher tick values than the specified `from` value (note: the log entry with a\ntick value equal to `from` is excluded). Use the `from` value when\nincrementally fetching log data.\nThe `to` query parameter can be used to optionally restrict the upper bound of\nthe result to a certain tick value. If used, the result contains only log events\nwith tick values up to (including) `to`. In incremental fetching, there is no\nneed to use the `to` parameter. It only makes sense in special situations,\nwhen only parts of the change log are required.\nThe `chunkSize` query parameter can be used to control the size of the result.\nIt must be specified in bytes. The `chunkSize` value is only honored\napproximately. Otherwise, a too low `chunkSize` value could cause the server\nto not be able to put just one log entry into the result and return it.\nTherefore, the `chunkSize` value is only consulted after a log entry has\nbeen written into the result. If the result size is then bigger than\n`chunkSize`, the server responds with as many log entries as there are\nin the response already. If the result size is still smaller than `chunkSize`,\nthe server tries to return more data if there's more data left to return.\nIf `chunkSize` is not specified, some server-side default value is used.\nThe `Content-Type` of the result is `application/x-arango-dump`. This is an\neasy-to-process format, with all log events going onto separate lines in the\nresponse body. Each log event itself is a JSON object, with at least the\nfollowing attributes:\n- `tick`: the log event tick value\n- `type`: the log event type\nIndividual log events also have additional attributes, depending on the\nevent type. A few common attributes which are used for multiple events types\nare:\n- `cuid`: globally unique id of the View or collection the event was for\n- `db`: the database name the event was for\n- `tid`: id of the transaction the event was contained in\n- `data`: the original document data\nA more detailed description of the individual replication event types and their\ndata structures can be found in [Operation Types](#operation-types).\nThe response also contains the following HTTP headers:\n- `x-arango-replication-active`: whether or not the logger is active. Clients\n  can use this flag as an indication for their polling frequency. If the\n  logger is not active and there are no more replication events available, it\n  might be sensible for a client to abort, or to go to sleep for a long time\n  and try again later to check whether the logger has been activated.\n- `x-arango-replication-lastincluded`: the tick value of the last included\n  value in the result. In incremental log fetching, this value can be used\n  as the `from` value for the following request. **Note** that if the result is\n  empty, the value is `0`. This value should not be used as `from` value\n  by clients in the next request (otherwise the server would return the log\n  events from the start of the log again).\n- `x-arango-replication-lastscanned`: the last tick the server scanned while\n  computing the operation log. This might include operations the server did not\n  returned to you due to various reasons (i.e. the value was filtered or skipped).\n  You may use this value in the `lastScanned` header to allow the RocksDB storage engine\n  to break up requests over multiple responses.\n- `x-arango-replication-lasttick`: the last tick value the server has\n  logged in its write ahead log (not necessarily included in the result). By comparing the the last\n  tick and last included tick values, clients have an approximate indication of\n  how many events there are still left to fetch.\n- `x-arango-replication-frompresent`: is set to _true_ if server returned\n  all tick values starting from the specified tick in the _from_ parameter.\n  Should this be set to false the server did not have these operations anymore\n  and the client might have missed operations.\n- `x-arango-replication-checkmore`: whether or not there already exists more\n  log data which the client could fetch immediately. If there is more log data\n  available, the client could call the tailing API again with an adjusted `from`\n  value to fetch remaining log entries until there are no more.\n  If there isn't any more log data to fetch, the client might decide to go\n  to sleep for a while before calling the logger again.\n**Note**: this method is not supported on a Coordinator in a cluster.\n", "operationId": " handleCommandTail", "parameters": [{"name": "global", "schema": {"type": "boolean"}, "required": false, "description": "Whether operations for all databases should be included. If set to `false`,\nonly the operations for the current database are included. The value `true` is\nonly valid on the `_system` database. The default is `false`.\n", "in": "query"}, {"name": "from", "schema": {"type": "number"}, "required": false, "description": "Exclusive lower bound tick value for results. On successive calls\nto this API you should set this to the value returned\nwith the `x-arango-replication-lastincluded` header (unless that header\ncontains 0).\n", "in": "query"}, {"name": "to", "schema": {"type": "number"}, "required": false, "description": "Inclusive upper bound tick value for results.\n", "in": "query"}, {"name": "lastScanned", "schema": {"type": "number"}, "required": false, "description": "Should be set to the value of the `x-arango-replication-lastscanned` header\nor alternatively 0 on first try. This allows the RocksDB storage engine to break up\nlarge transactions over multiple responses.\n", "in": "query"}, {"name": "chunkSize", "schema": {"type": "number"}, "required": false, "description": "Approximate maximum size of the returned result.\n", "in": "query"}, {"name": "syncerId", "schema": {"type": "number"}, "required": false, "description": "The ID of the client used to tail results. The server uses this to\nkeep operations until the client has fetched them. Must be a positive integer.\n**Note** `syncerId` or `serverId` is required to have a chance at fetching all\noperations with the RocksDB storage engine.\n", "in": "query"}, {"name": "serverId", "schema": {"type": "number"}, "required": false, "description": "The ID of the client machine. If `syncerId` is unset, the server uses\nthis to keep operations until the client has fetched them. Must be a positive\ninteger.\n**Note** `serverId` or `syncerId` is required to have a chance at fetching all\noperations with the RocksDB storage engine.\n", "in": "query"}, {"name": "clientInfo", "schema": {"type": "string"}, "required": false, "description": "Short description of the client, used for informative purposes only.\n", "in": "query"}], "responses": {"200": {"description": "is returned if the request was executed successfully, and there are log\nevents available for the requested range. The response body is not empty\nin this case.\n"}, "204": {"description": "is returned if the request was executed successfully, but there are no log\nevents available for the requested range. The response body is empty\nin this case.\n"}, "400": {"description": "is returned if either the `from` or `to` values are invalid.\n"}, "405": {"description": "is returned when an invalid HTTP method is used.\n"}, "500": {"description": "is returned if an error occurred while assembling the response.\n"}, "501": {"description": "is returned when this operation is called on a Coordinator in a cluster.\n"}}, "tags": ["Replication"]}}, "/_api/gharial/{graph}/edge/{collection}": {"post": {"description": "Creates a new edge in the collection.\nWithin the body the edge has to contain a *_from* and *_to* value referencing to valid vertices in the graph.\nFurthermore the edge has to be valid in the definition of the used edge collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the edge collection the edge belongs to.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Define if the response should contain the complete\nnew version of the document.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"_from": {"type": "string", "description": "The source vertex of this edge. Has to be valid within\nthe used edge definition.\n"}, "_to": {"type": "string", "description": "The target vertex of this edge. Has to be valid within\nthe used edge definition.\n"}}, "required": ["_from", "_to"]}}}}, "responses": {"201": {"description": "Returned if the edge could be created and waitForSync is true.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "400": {"description": "Returned if the input document is invalid.\nThis can for instance be the case if the `_from` or `_to` attribute is missing\nor malformed, or if the referenced vertex collection is not part of the graph.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to insert edges into the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in any of the following cases\n* no graph with this name could be found.\n* the edge collection is not part of the graph.\n* the vertex collection is part of the graph, but does not exist.\n* `_from` or `_to` vertex does not exist.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "edge": {"$ref": "#/components/schemas/edge_representation", "description": "The internal attributes for the edge.\n"}, "new": {"$ref": "#/components/schemas/edge_representation", "description": "The complete newly written edge document.\nIncludes all written attributes in the request body\nand all internal attributes generated by ArangoDB.\nWill only be present if returnNew is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "edge", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial/{graph}/edge/{collection}/{edge}": {"get": {"description": "Gets an edge from the given collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the edge collection the edge belongs to.\n", "in": "path"}, {"name": "edge", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the edge.\n", "in": "path"}, {"name": "rev", "schema": {"type": "string"}, "required": false, "description": "Must contain a revision.\nIf this is set a document is only returned if\nit has exactly this revision.\nAlso see if-match header as an alternative to this.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is returned,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n", "in": "header"}, {"name": "if-none-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-None-Match\" header is given, then it must contain exactly one Etag. The document is returned,\nonly if it has a different revision as the given Etag. Otherwise a HTTP 304 is returned.\n", "in": "header"}], "responses": {"200": {"description": "Returned if the edge could be found.\n"}, "304": {"description": "Returned if the if-none-match header is given and the\ncurrently stored edge still has this revision value.\nSo there was no update between the last time the edge\nwas fetched by the caller.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge does not exist.\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "edge": {"$ref": "#/components/schemas/edge_representation", "description": "The complete edge.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "edge", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "patch": {"description": "Updates the data of the specific edge in the collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the edge collection the edge belongs to.\n", "in": "path"}, {"name": "edge", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the vertex.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "Define if values set to null should be stored.\nBy default (true) the given documents attribute(s) will be set to null.\nIf this parameter is false the attribute(s) will instead be deleted from the\ndocument.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the new document should\nbe returned within the response object.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"edge": {"type": "object", "description": "The body has to contain a JSON object containing exactly the attributes that should be overwritten, all other attributes remain unchanged.\n"}}, "required": ["edge"]}}}}, "responses": {"200": {"description": "Returned if the edge could be updated, and waitForSync is false.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to update edges in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge to update does not exist.\n* either `_from` or `_to` vertex does not exist (if updated).\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "edge": {"$ref": "#/components/schemas/edge_representation", "description": "The internal attributes for the edge.\n"}, "new": {"$ref": "#/components/schemas/edge_representation", "description": "The complete newly written edge document.\nIncludes all written attributes in the request body\nand all internal attributes generated by ArangoDB.\nWill only be present if returnNew is true.\n"}, "old": {"$ref": "#/components/schemas/edge_representation", "description": "The complete overwritten edge document.\nIncludes all attributes stored before this operation.\nWill only be present if returnOld is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "edge", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "put": {"description": "Replaces the data of an edge in the collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the edge collection the edge belongs to.\n", "in": "path"}, {"name": "edge", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the vertex.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "Define if values set to null should be stored. By default the key is not removed from the document.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the new document should\nbe returned within the response object.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"_from": {"type": "string", "description": "The source vertex of this edge. Has to be valid within\nthe used edge definition.\n"}, "_to": {"type": "string", "description": "The target vertex of this edge. Has to be valid within\nthe used edge definition.\n"}}, "required": ["_from", "_to"]}}}}, "responses": {"201": {"description": "Returned if the request was successful but waitForSync is true.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to replace edges in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge to replace does not exist.\n* either `_from` or `_to` vertex does not exist.\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "edge": {"$ref": "#/components/schemas/edge_representation", "description": "The internal attributes for the edge\n"}, "new": {"$ref": "#/components/schemas/edge_representation", "description": "The complete newly written edge document.\nIncludes all written attributes in the request body\nand all internal attributes generated by ArangoDB.\nWill only be present if returnNew is true.\n"}, "old": {"$ref": "#/components/schemas/edge_representation", "description": "The complete overwritten edge document.\nIncludes all attributes stored before this operation.\nWill only be present if returnOld is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "edge", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "delete": {"description": "Removes an edge from the collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the edge collection the edge belongs to.\n", "in": "path"}, {"name": "edge", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the edge.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n", "in": "header"}], "responses": {"200": {"description": "Returned if the edge could be removed.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to delete vertices in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge to remove does not exist.\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "removed": {"type": "boolean", "description": "Is set to true if the remove was successful.\n"}, "old": {"$ref": "#/components/schemas/edge_representation", "description": "The complete deleted edge document.\nIncludes all attributes stored before this operation.\nWill only be present if returnOld is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "removed", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial/{graph}/vertex/{collection}": {"post": {"description": "Adds a vertex to the given collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the vertex collection the vertex should be inserted into.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Define if the response should contain the complete\nnew version of the document.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"vertex": {"type": "object", "description": "The body has to be the JSON object to be stored.\n"}}, "required": ["vertex"]}}}}, "responses": {"201": {"description": "Returned if the vertex could be added and waitForSync is true.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to insert vertices into the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned if no graph with this name could be found.\nOr if a graph is found but this collection is not part of the graph.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "vertex": {"$ref": "#/components/schemas/vertex_representation", "description": "The internal attributes generated while storing the vertex.\nDoes not include any attribute given in request body.\n"}, "new": {"$ref": "#/components/schemas/vertex_representation", "description": "The complete newly written vertex document.\nIncludes all written attributes in the request body\nand all internal attributes generated by ArangoDB.\nWill only be present if returnNew is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "vertex", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "delete": {"description": "Removes a vertex collection from the graph and optionally deletes the collection,\nif it is not used in any other graph.\nIt can only remove vertex collections that are no longer part of edge definitions,\nif they are used in edge definitions you are required to modify those first.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the vertex collection.\n", "in": "path"}, {"name": "dropCollection", "schema": {"type": "boolean"}, "required": false, "description": "Drop the collection as well.\nCollection will only be dropped if it is not used in other graphs.\n", "in": "query"}], "responses": {"200": {"description": "Returned if the vertex collection was removed from the graph successfully\nand waitForSync is true.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "400": {"description": "Returned if the vertex collection is still used in an edge definition.\nIn this case it cannot be removed from the graph yet, it has to be\nremoved from the edge definition first.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges\n  1. `Administrate` access on the Database.\n"}, "404": {"description": "Returned if no graph with this name could be found.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graph": {"$ref": "#/components/schemas/graph_representation", "description": "The information about the newly created graph\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "graph", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial/{graph}/vertex/{collection}/{vertex}": {"get": {"description": "Gets a vertex from the given collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the vertex collection the vertex belongs to.\n", "in": "path"}, {"name": "vertex", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the vertex.\n", "in": "path"}, {"name": "rev", "schema": {"type": "string"}, "required": false, "description": "Must contain a revision.\nIf this is set a document is only returned if\nit has exactly this revision.\nAlso see if-match header as an alternative to this.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is returned,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an query parameter *rev*.\n", "in": "header"}, {"name": "if-none-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-None-Match\" header is given, then it must contain exactly one Etag. The document is returned,\nonly if it has a different revision as the given Etag. Otherwise a HTTP 304 is returned.\n", "in": "header"}], "responses": {"200": {"description": "Returned if the vertex could be found.\n"}, "304": {"description": "Returned if the if-none-match header is given and the\ncurrently stored vertex still has this revision value.\nSo there was no update between the last time the vertex\nwas fetched by the caller.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex does not exist.\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "vertex": {"$ref": "#/components/schemas/vertex_representation", "description": "The complete vertex.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "vertex", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "patch": {"description": "Updates the data of the specific vertex in the collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the vertex collection the vertex belongs to.\n", "in": "path"}, {"name": "vertex", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the vertex.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "Define if values set to null should be stored.\nBy default (true) the given documents attribute(s) will be set to null.\nIf this parameter is false the attribute(s) will instead be delete from the\ndocument.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the new document should\nbe returned within the response object.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"vertex": {"type": "object", "description": "The body has to contain a JSON object containing exactly the attributes that should be overwritten, all other attributes remain unchanged.\n"}}, "required": ["vertex"]}}}}, "responses": {"200": {"description": "Returned if the vertex could be updated, and waitForSync is true.\n"}, "202": {"description": "Returned if the request was successful, and waitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to update does not exist.\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "vertex": {"$ref": "#/components/schemas/vertex_representation", "description": "The internal attributes for the vertex.\n"}, "new": {"$ref": "#/components/schemas/vertex_representation", "description": "The complete newly written vertex document.\nIncludes all written attributes in the request body\nand all internal attributes generated by ArangoDB.\nWill only be present if returnNew is true.\n"}, "old": {"$ref": "#/components/schemas/vertex_representation", "description": "The complete overwritten vertex document.\nIncludes all attributes stored before this operation.\nWill only be present if returnOld is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "vertex", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "put": {"description": "Replaces the data of a vertex in the collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the vertex collection the vertex belongs to.\n", "in": "path"}, {"name": "vertex", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the vertex.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "keepNull", "schema": {"type": "boolean"}, "required": false, "description": "Define if values set to null should be stored. By default the key is not removed from the document.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n", "in": "query"}, {"name": "returnNew", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the new document should\nbe returned within the response object.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"vertex": {"type": "object", "description": "The body has to be the JSON object to be stored.\n"}}, "required": ["vertex"]}}}}, "responses": {"200": {"description": "Returned if the vertex could be replaced, and waitForSync is true.\n"}, "202": {"description": "Returned if the vertex could be replaced, and waitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to replace vertices in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to replace does not exist.\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "vertex": {"$ref": "#/components/schemas/vertex_representation", "description": "The internal attributes for the vertex.\n"}, "new": {"$ref": "#/components/schemas/vertex_representation", "description": "The complete newly written vertex document.\nIncludes all written attributes in the request body\nand all internal attributes generated by ArangoDB.\nWill only be present if returnNew is true.\n"}, "old": {"$ref": "#/components/schemas/vertex_representation", "description": "The complete overwritten vertex document.\nIncludes all attributes stored before this operation.\nWill only be present if returnOld is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "vertex", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "delete": {"description": "Removes a vertex from the collection.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "collection", "schema": {"type": "string"}, "required": true, "description": "The name of the vertex collection the vertex belongs to.\n", "in": "path"}, {"name": "vertex", "schema": {"type": "string"}, "required": true, "description": "The *_key* attribute of the vertex.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "returnOld", "schema": {"type": "boolean"}, "required": false, "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n", "in": "query"}, {"name": "if-match", "schema": {"type": "string"}, "required": false, "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n", "in": "header"}], "responses": {"200": {"description": "Returned if the vertex could be removed.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to delete vertices in the graph  you at least need to have the following privileges\n"}, "404": {"description": "Returned in the following cases\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to remove does not exist.\n"}, "412": {"description": "Returned if if-match header is given, but the stored documents revision is different.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "removed": {"type": "boolean", "description": "Is set to true if the remove was successful.\n"}, "old": {"$ref": "#/components/schemas/vertex_representation", "description": "The complete deleted vertex document.\nIncludes all attributes stored before this operation.\nWill only be present if returnOld is true.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "removed", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial": {"get": {"description": "Lists all graphs stored in this database.\n", "responses": {"200": {"description": "Is returned if the module is available and the graphs could be listed.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graphs": {"$ref": "#/components/schemas/graph_list", "items": {"type": "graph_list"}, "description": ""}}, "required": ["error", "code", "graphs"]}}}}}, "tags": ["Graph"]}, "post": {"description": "The creation of a graph requires the name of the graph and a\ndefinition of its edges.\n", "parameters": [{"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "define if the request should wait until everything is synced to disc.\nWill change the success response code.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"name": {"type": "string", "description": "Name of the graph.\n"}, "edgeDefinitions": {"$ref": "#/components/schemas/graph_edge_definition", "items": {"type": "graph_edge_definition"}, "description": "An array of definitions for the relations of the graph.\nEach has the following type:\n"}, "orphanCollections": {"type": "array", "items": {"type": "string"}, "description": "An array of additional vertex collections.\nDocuments within these collections do not have edges within this graph.\n"}, "isSmart": {"type": "boolean", "description": "Define if the created graph should be smart (Enterprise Edition only).\n"}, "isDisjoint": {"type": "boolean", "description": "Whether to create a Disjoint SmartGraph instead of a regular SmartGraph\n(Enterprise Edition only).\n"}, "options": {"$ref": "#/components/schemas/post_api_gharial_create_opts", "description": "a JSON object to define options for creating collections within this graph.\nIt can contain the following attributes:\n"}}, "required": ["name"]}}}}, "responses": {"201": {"description": "Is returned if the graph could be created and waitForSync is enabled\nfor the `_graphs` collection, or given in the request.\nThe response body contains the graph configuration that has been stored.\n"}, "202": {"description": "Is returned if the graph could be created and waitForSync is disabled\nfor the `_graphs` collection and not given in the request.\nThe response body contains the graph configuration that has been stored.\n"}, "400": {"description": "Returned if the request is in a wrong format.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to create a graph you at least need to have the following privileges\n"}, "409": {"description": "Returned if there is a conflict storing the graph. This can occur\neither if a graph with this name is already stored, or if there is one\nedge definition with a the same edge collection but a different signature\nused in any other graph.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graph": {"$ref": "#/components/schemas/graph_representation", "description": "The information about the newly created graph.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "graph", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial/{graph}": {"get": {"description": "Selects information for a given graph.\nWill return the edge definitions as well as the orphan collections.\nOr returns a 404 if the graph does not exist.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}], "responses": {"200": {"description": "Returns the graph if it could be found.\nThe result will have the following format\n"}, "404": {"description": "Returned if no graph with this name could be found.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graph": {"$ref": "#/components/schemas/graph_representation", "description": "The information about the newly created graph\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}}, "required": ["error", "code", "graph", "errorNum"]}}}}}, "tags": ["Graph"]}, "delete": {"description": "Drops an existing graph object by name.\nOptionally all collections not used by other graphs\ncan be dropped as well.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "dropCollections", "schema": {"type": "boolean"}, "required": false, "description": "Drop collections of this graph as well.  Collections will only be\ndropped if they are not used in other graphs.\n", "in": "query"}], "responses": {"201": {"description": "Is returned if the graph could be dropped and waitForSync is enabled\nfor the `_graphs` collection, or given in the request.\n"}, "202": {"description": "Is returned if the graph could be dropped and waitForSync is disabled\nfor the `_graphs` collection and not given in the request.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to drop a graph you at least need to have the following privileges\n  1. `Administrate` access on the Database.\n"}, "404": {"description": "Returned if no graph with this name could be found.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial/{graph}/vertex": {"get": {"description": "Lists all vertex collections within this graph.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}], "responses": {"200": {"description": "Is returned if the collections could be listed.\n"}, "404": {"description": "Returned if no graph with this name could be found.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "collections": {"type": "array", "items": {"type": "string"}, "description": "The list of all vertex collections within this graph.\nIncludes collections in edgeDefinitions as well as orphans.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}}, "required": ["error", "code", "collections", "errorNum"]}}}}}, "tags": ["Graph"]}, "post": {"description": "Adds a vertex collection to the set of orphan collections of the graph.\nIf the collection does not exist, it will be created.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"options": {"$ref": "#/components/schemas/post_api_vertex_create_opts", "description": "A JSON object to set options for creating vertex collections.\n"}}, "required": []}}}}, "responses": {"201": {"description": "Is returned if the collection could be created and waitForSync is enabled\nfor the `_graphs` collection, or given in the request.\nThe response body contains the graph configuration that has been stored.\n"}, "202": {"description": "Is returned if the collection could be created and waitForSync is disabled\nfor the `_graphs` collection, or given in the request.\nThe response body contains the graph configuration that has been stored.\n"}, "400": {"description": "Returned if the request is in an invalid format.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to modify a graph you at least need to have the following privileges\n"}, "404": {"description": "Returned if no graph with this name could be found.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graph": {"$ref": "#/components/schemas/graph_representation", "description": "The information about the newly created graph\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "graph", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial/{graph}/edge": {"get": {"description": "Lists all edge collections within this graph.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}], "responses": {"200": {"description": "Is returned if the edge definitions could be listed.\n"}, "404": {"description": "Returned if no graph with this name could be found.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "collections": {"type": "array", "items": {"type": "string"}, "description": "The list of all vertex collections within this graph.\nIncludes collections in edgeDefinitions as well as orphans.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}}, "required": ["error", "code", "collections", "errorNum"]}}}}}, "tags": ["Graph"]}, "post": {"description": "Adds an additional edge definition to the graph.\nThis edge definition has to contain a *collection* and an array of\neach *from* and *to* vertex collections.  An edge definition can only\nbe added if this definition is either not used in any other graph, or\nit is used with exactly the same definition. It is not possible to\nstore a definition \"e\" from \"v1\" to \"v2\" in the one graph, and \"e\"\nfrom \"v2\" to \"v1\" in the other graph.\nAdditionally, collection creation options can be set.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"collection": {"type": "string", "description": "The name of the edge collection to be used.\n"}, "from": {"type": "array", "items": {"type": "string"}, "description": "One or many vertex collections that can contain source vertices.\n"}, "to": {"type": "array", "items": {"type": "string"}, "description": "One or many vertex collections that can contain target vertices.\n"}, "options": {"$ref": "#/components/schemas/post_api_edgedef_create_opts", "description": "A JSON object to set options for creating collections within this\nedge definition.\n"}}, "required": ["collection", "from", "to"]}}}}, "responses": {"201": {"description": "Returned if the definition could be added successfully and\nwaitForSync is enabled for the `_graphs` collection.\nThe response body contains the graph configuration that has been stored.\n"}, "202": {"description": "Returned if the definition could be added successfully and\nwaitForSync is disabled for the `_graphs` collection.\nThe response body contains the graph configuration that has been stored.\n"}, "400": {"description": "Returned if the definition could not be added.\nThis could be because it is ill-formed, or\nif the definition is used in an other graph with a different signature.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to modify a graph you at least need to have the following privileges\n"}, "404": {"description": "Returned if no graph with this name could be found.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graph": {"$ref": "#/components/schemas/graph_representation", "description": "The information about the modified graph.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "graph", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/gharial/{graph}/edge/{definition}#definition": {"put": {"description": "Change one specific edge definition.\nThis will modify all occurrences of this definition in all graphs known to your database.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "definition", "schema": {"type": "string"}, "required": true, "description": "The name of the edge collection used in the definition.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "dropCollections", "schema": {"type": "boolean"}, "required": false, "description": "Drop the collection as well.\nCollection will only be dropped if it is not used in other graphs.\n", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"collection": {"type": "string", "description": "The name of the edge collection to be used.\n"}, "from": {"type": "array", "items": {"type": "string"}, "description": "One or many vertex collections that can contain source vertices.\n"}, "to": {"type": "array", "items": {"type": "string"}, "description": "One or many vertex collections that can contain target vertices.\n"}, "options": {"$ref": "#/components/schemas/post_api_edgedef_modify_opts", "description": "A JSON object to set options for modifying collections within this\nedge definition.\n"}}, "required": ["collection", "from", "to"]}}}}, "responses": {"201": {"description": "Returned if the request was successful and waitForSync is true.\n"}, "202": {"description": "Returned if the request was successful but waitForSync is false.\n"}, "400": {"description": "Returned if the new edge definition is ill-formed and cannot be used.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges\n  1. `Administrate` access on the Database.\n"}, "404": {"description": "Returned if no graph with this name could be found, or if no edge definition\nwith this name is found in the graph.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graph": {"$ref": "#/components/schemas/graph_representation", "description": "The information about the modified graph.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "graph", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}, "delete": {"description": "Remove one edge definition from the graph.  This will only remove the\nedge collection, the vertex collections remain untouched and can still\nbe used in your queries.\n", "parameters": [{"name": "graph", "schema": {"type": "string"}, "required": true, "description": "The name of the graph.\n", "in": "path"}, {"name": "definition", "schema": {"type": "string"}, "required": true, "description": "The name of the edge collection used in the definition.\n", "in": "path"}, {"name": "waitForSync", "schema": {"type": "boolean"}, "required": false, "description": "Define if the request should wait until synced to disk.\n", "in": "query"}, {"name": "dropCollections", "schema": {"type": "boolean"}, "required": false, "description": "Drop the collection as well.\nCollection will only be dropped if it is not used in other graphs.\n", "in": "query"}], "responses": {"201": {"description": "Returned if the edge definition could be removed from the graph\nand waitForSync is true.\n"}, "202": {"description": "Returned if the edge definition could be removed from the graph and\nwaitForSync is false.\n"}, "403": {"description": "Returned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges\n  1. `Administrate` access on the Database.\n"}, "404": {"description": "Returned if no graph with this name could be found,\nor if no edge definition with this name is found in the graph.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n"}, "code": {"type": "integer", "description": "The response code.\n"}, "graph": {"$ref": "#/components/schemas/graph_representation", "description": "The information about the modified graph.\n"}, "errorNum": {"type": "integer", "description": "ArangoDB error number for the error that occurred.\n"}, "errorMessage": {"type": "string", "description": "A message created for this error.\n"}}, "required": ["error", "code", "graph", "errorNum", "errorMessage"]}}}}}, "tags": ["Graph"]}}, "/_api/cursor": {"post": {"description": "The query details include the query string plus optional query options and\nbind parameters. These values need to be passed in a JSON representation in\nthe body of the POST request.\n", "operationId": " createQueryCursor", "parameters": [{"name": "x-arango-allow-dirty-read", "schema": {"type": "boolean"}, "required": false, "description": "Set this header to `true` to allow the Coordinator to ask any shard replica for\nthe data, not only the shard leader. This may result in \"dirty reads\".\nThe header is ignored if this operation is part of a Stream Transaction\n(`x-arango-trx-id` header). The header set when creating the transaction decides\nabout dirty reads for the entire transaction, not the individual read operations.\n", "in": "header"}, {"name": "x-arango-trx-id", "schema": {"type": "string"}, "required": false, "description": "To make this operation a part of a Stream Transaction, set this header to the\ntransaction ID returned by the `POST /_api/transaction/begin` call.\n", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"query": {"type": "string", "description": "contains the query string to be executed\n"}, "count": {"type": "boolean", "description": "indicates whether the number of documents in the result set should be returned in\nthe \"count\" attribute of the result.\nCalculating the \"count\" attribute might have a performance impact for some queries\nin the future so this option is turned off by default, and \"count\"\nis only returned when requested.\n"}, "batchSize": {"type": "integer", "format": "int64", "description": "maximum number of result documents to be transferred from\nthe server to the client in one roundtrip. If this attribute is\nnot set, a server-controlled default value will be used. A *batchSize* value of\n*0* is disallowed.\n"}, "ttl": {"type": "integer", "format": "int64", "description": "The time-to-live for the cursor (in seconds). If the result set is small enough\n(less than or equal to `batchSize`) then results are returned right away.\nOtherwise they are stored in memory and will be accessible via the cursor with\nrespect to the `ttl`. The cursor will be removed on the server automatically\nafter the specified amount of time. This is useful to ensure garbage collection\nof cursors that are not fully fetched by clients. If not set, a server-defined\nvalue will be used (default: 30 seconds).\n"}, "cache": {"type": "boolean", "description": "flag to determine whether the AQL query results cache\nshall be used. If set to *false*, then any query cache lookup will be skipped\nfor the query. If set to *true*, it will lead to the query cache being checked\nfor the query if the query cache mode is either *on* or *demand*.\n"}, "memoryLimit": {"type": "integer", "format": "int64", "description": "the maximum number of memory (measured in bytes) that the query is allowed to\nuse. If set, then the query will fail with error \"resource limit exceeded\" in\ncase it allocates too much memory. A value of *0* indicates that there is no\nmemory limit.\n"}, "bindVars": {"type": "array", "format": "object", "items": {"type": "object"}, "description": "key/value pairs representing the bind parameters.\n"}, "options": {"$ref": "#/components/schemas/post_api_cursor_opts", "description": "key/value object with extra options for the query.\n"}}, "required": ["query"]}}}}, "responses": {"201": {"description": "is returned if the result set can be created by the server.\n"}, "400": {"description": "is returned if the JSON representation is malformed or the query specification is\nmissing from the request.\n"}, "404": {"description": "The server will respond with *HTTP 404* in case a non-existing collection is\naccessed in the query.\n"}, "405": {"description": "The server will respond with *HTTP 405* if an unsupported HTTP method is used.\n"}, "410": {"description": "\nThe server will respond with *HTTP 410* if a server which processes the query\nor is the leader for a shard which is used in the query stops responding, but \nthe connection has not been closed.\n"}, "503": {"description": "\nThe server will respond with *HTTP 503* if a server which processes the query\nor is the leader for a shard which is used in the query is down, either for \ngoing through a restart, a failure or connectivity issues.\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "boolean flag to indicate that an error occurred (*true* in this case)\n"}, "code": {"type": "integer", "format": "int64", "description": "the HTTP status code\n"}, "result": {"type": "array", "items": {"type": "string"}, "description": "An array of result documents (might be empty if query has no results).\n"}, "hasMore": {"type": "boolean", "description": "A boolean indicator whether there are more results\navailable for the cursor on the server.\n"}, "count": {"type": "integer", "format": "int64", "description": "The total number of result documents available (only\navailable if the query was executed with the `count` attribute set).\n"}, "id": {"type": "string", "description": "The ID of a temporary cursor created on the server for fetching more result batches.\n"}, "extra": {"$ref": "#/components/schemas/post_api_cursor_extra", "description": "An optional JSON object with extra information about the query result.\n"}, "cached": {"type": "boolean", "description": "A boolean flag indicating whether the query result was served\nfrom the query cache or not. If the query result is served from the query\ncache, the `extra` return attribute will not contain any `stats` sub-attribute\nand no `profile` sub-attribute.\n"}, "errorNum": {"type": "integer", "format": "int64", "description": "the server error number\n"}, "errorMessage": {"type": "string", "description": "A descriptive error message.\nIf the query specification is complete, the server will process the query. If an\nerror occurs during query processing, the server will respond with *HTTP 400*.\nAgain, the body of the response will contain details about the error.\n"}}, "required": ["error", "code", "hasMore", "cached", "errorNum", "errorMessage"]}}}}}, "tags": ["Cursors"]}}, "/_api/cursor/{cursor-identifier}": {"post": {"description": "If the cursor is still alive, returns an object with the following\nattributes:\n- *id*: a *cursor-identifier*\n- *result*: a list of documents for the current batch\n- *hasMore*: *false* if this was the last batch\n- *count*: if present the total number of elements\n- *code*: an HTTP status code\n- *error*: a boolean flag to indicate whether an error occurred\n- *errorNum*: a server error number (if *error* is *true*)\n- *errorMessage*: a descriptive error message (if *error* is *true*)\n- *extra*: an object with additional information about the query result, with\n  the nested objects *stats* and *warnings*. Only delivered as part of the last\n  batch in case of a cursor with the *stream* option enabled.\nNote that even if *hasMore* returns *true*, the next call might\nstill return no documents. If, however, *hasMore* is *false*, then\nthe cursor is exhausted.  Once the *hasMore* attribute has a value of\n*false*, the client can stop.\n", "operationId": " modifyQueryCursorPost", "parameters": [{"name": "cursor-identifier", "schema": {"type": "string"}, "required": true, "description": "The name of the cursor\n", "in": "path"}], "responses": {"200": {"description": "The server will respond with *HTTP 200* in case of success.\n"}, "400": {"description": "If the cursor identifier is omitted, the server will respond with *HTTP 404*.\n"}, "404": {"description": "If no cursor with the specified identifier can be found, the server will respond\nwith *HTTP 404*.\n"}, "410": {"description": "\nThe server will respond with *HTTP 410* if a server which processes the query\nor is the leader for a shard which is used in the query stops responding, but \nthe connection has not been closed.\n"}, "503": {"description": "\nThe server will respond with *HTTP 503* if a server which processes the query\nor is the leader for a shard which is used in the query is down, either for \ngoing through a restart, a failure or connectivity issues.\n"}}, "tags": ["Cursors"]}, "put": {"description": "If the cursor is still alive, returns an object with the following\nattributes:\n- *id*: a *cursor-identifier*\n- *result*: a list of documents for the current batch\n- *hasMore*: *false* if this was the last batch\n- *count*: if present the total number of elements\n- *code*: an HTTP status code\n- *error*: a boolean flag to indicate whether an error occurred\n- *errorNum*: a server error number (if *error* is *true*)\n- *errorMessage*: a descriptive error message (if *error* is *true*)\n- *extra*: an object with additional information about the query result, with\n  the nested objects *stats* and *warnings*. Only delivered as part of the last\n  batch in case of a cursor with the *stream* option enabled.\nNote that even if *hasMore* returns *true*, the next call might\nstill return no documents. If, however, *hasMore* is *false*, then\nthe cursor is exhausted.  Once the *hasMore* attribute has a value of\n*false*, the client can stop.\n", "operationId": " modifyQueryCursorPut", "parameters": [{"name": "cursor-identifier", "schema": {"type": "string"}, "required": true, "description": "The name of the cursor\n", "in": "path"}], "responses": {"200": {"description": "The server will respond with *HTTP 200* in case of success.\n"}, "400": {"description": "If the cursor identifier is omitted, the server will respond with *HTTP 404*.\n"}, "404": {"description": "If no cursor with the specified identifier can be found, the server will respond\nwith *HTTP 404*.\n"}, "410": {"description": "\nThe server will respond with *HTTP 410* if a server which processes the query\nor is the leader for a shard which is used in the query stops responding, but \nthe connection has not been closed.\n"}, "503": {"description": "\nThe server will respond with *HTTP 503* if a server which processes the query\nor is the leader for a shard which is used in the query is down, either for \ngoing through a restart, a failure or connectivity issues.\n"}}, "tags": ["Cursors"]}, "delete": {"description": "Deletes the cursor and frees the resources associated with it.\nThe cursor will automatically be destroyed on the server when the client has\nretrieved all documents from it. The client can also explicitly destroy the\ncursor at any earlier time using an HTTP DELETE request. The cursor id must\nbe included as part of the URL.\nNote: the server will also destroy abandoned cursors automatically after a\ncertain server-controlled timeout to avoid resource leakage.\n", "operationId": " deleteQueryCursor", "parameters": [{"name": "cursor-identifier", "schema": {"type": "string"}, "required": true, "description": "The id of the cursor\n", "in": "path"}], "responses": {"202": {"description": "is returned if the server is aware of the cursor.\n"}, "404": {"description": "is returned if the server is not aware of the cursor. It is also\nreturned if a cursor is used after it has been destroyed.\n"}}, "tags": ["Cursors"]}}, "/_admin/cluster/maintenance": {"put": {"description": "\nThis API allows to temporarily enable the supervision maintenance mode. Please be aware that no\nautomatic failovers of any kind will take place while the maintenance mode is enabled.\nThe cluster supervision reactivates itself automatically at some point after disabling it.\n\nTo enable the maintenance mode the request body must contain the string `\"on\"`\n(Please note it _must_ be lowercase as well as include the quotes). This will enable the\nmaintenance mode for 60 minutes, i.e. the supervision maintenance will reactivate itself\nafter 60 minutes.\n\nSince ArangoDB 3.8.3 it is possible to enable the maintenance mode for a different \nduration than 60 minutes, it is possible to send the desired duration value (in seconds) \nas a string in the request body. For example, sending `\"7200\"`\n(including the quotes) will enable the maintenance mode for 7200 seconds, i.e. 2 hours.\n\nTo disable the maintenance mode the request body must contain the string `\"off\"` \n(Please note it _must_ be lowercase as well as include the quotes).\n\n", "responses": {"200": {"description": "is returned when everything went well.\n"}, "400": {"description": "if the request contained an invalid body\n"}, "501": {"description": "if the request was sent to a node other than a Coordinator or single-server\n"}, "504": {"description": "if the request timed out while enabling the maintenance mode\n"}}, "tags": ["Cluster"]}}, "/_admin/cluster/maintenance/{DB-Server-ID}": {"get": {"description": "Check whether the specified DB-Server is in maintenance mode and until when.\n", "parameters": [{"name": "DB-Server-ID", "schema": {"type": "string"}, "required": true, "description": "The ID of a DB-Server.\n", "in": "path"}], "responses": {"200": {"description": "The request was successful.\n"}, "400": {"description": "if the request contained an invalid body\n"}, "412": {"description": "if the request was sent to an Agent node\n"}, "504": {"description": "if the request timed out while enabling the maintenance mode\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Whether an error occurred. `false` in this case.\n"}, "code": {"type": "integer", "description": "The status code. `200` in this case.\n"}, "result": {"$ref": "#/components/schemas/get_cluster_maintenance_dbserver_result", "description": "The result object with the status. This attribute is omitted if the DB-Server\nis in normal mode.\n"}}, "required": ["error", "code"]}}}}}, "tags": ["Cluster"]}, "put": {"description": "For rolling upgrades or rolling restarts, DB-Servers can be put into\nmaintenance mode, so that no attempts are made to re-distribute the data in a\ncluster for such planned events. DB-Servers in maintenance mode are not\nconsidered viable failover targets because they are likely restarted soon.\n", "parameters": [{"name": "DB-Server-ID", "schema": {"type": "string"}, "required": true, "description": "The ID of a DB-Server.\n", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"mode": {"type": "string", "description": "The mode to put the DB-Server in. Possible values:\n- `\"maintenance\"`\n- `\"normal\"`\n"}, "timeout": {"type": "integer", "description": "After how many seconds the maintenance mode shall automatically end.\nYou can send another request when the DB-Server is already in maintenance mode\nto extend the timeout.\n"}}, "required": ["mode"]}}}}, "responses": {"200": {"description": "The request was successful.\n"}, "400": {"description": "if the request contained an invalid body\n"}, "412": {"description": "if the request was sent to an Agency node\n"}, "504": {"description": "if the request timed out while enabling the maintenance mode\n", "content": {"application/json": {"schema": {"type": "object", "properties": {"error": {"type": "boolean", "description": "Whether an error occurred. `false` in this case.\n"}, "code": {"type": "integer", "description": "The status code. `200` in this case.\n"}}, "required": ["error", "code"]}}}}}, "tags": ["Cluster"]}}, "/_api/transaction": {"post": {"description": "The transaction description must be passed in the body of the POST request.\nIf the transaction is fully executed and committed on the server,\n*HTTP 200* will be returned. Additionally, the return value of the\ncode defined in *action* will be returned in the *result* attribute.\nFor successfully committed transactions, the returned JSON object has the\nfollowing properties:\n- *error*: boolean flag to indicate if an error occurred (*false*\n  in this case)\n- *code*: the HTTP status code\n- *result*: the return value of the transaction\nIf the transaction specification is either missing or malformed, the server\nwill respond with *HTTP 400*.\nThe body of the response will then contain a JSON object with additional error\ndetails. The object has the following attributes:\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message\nIf a transaction fails to commit, either by an exception thrown in the\n*action* code, or by an internal error, the server will respond with\nan error.\nAny other errors will be returned with any of the return codes\n*HTTP 400*, *HTTP 409*, or *HTTP 500*.\n", "operationId": " executeCommit", "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"collections": {"type": "string", "description": "*collections* must be a JSON object that can have one or all sub-attributes\n*read*, *write* or *exclusive*, each being an array of collection names or a\nsingle collection name as string. Collections that will be written to in the\ntransaction must be declared with the *write* or *exclusive* attribute or it\nwill fail, whereas non-declared collections from which is solely read will be\nadded lazily. The optional sub-attribute *allowImplicit* can be set to *false*\nto let transactions fail in case of undeclared collections for reading.\nCollections for reading should be fully declared if possible, to avoid\ndeadlocks.\n"}, "action": {"type": "string", "description": "the actual transaction operations to be executed, in the\nform of stringified JavaScript code. The code will be executed on server\nside, with late binding. It is thus critical that the code specified in\n*action* properly sets up all the variables it needs.\nIf the code specified in *action* ends with a return statement, the\nvalue returned will also be returned by the REST API in the *result*\nattribute if the transaction committed successfully.\n"}, "waitForSync": {"type": "boolean", "description": "an optional boolean flag that, if set, will force the\ntransaction to write all data to disk before returning.\n"}, "allowImplicit": {"type": "boolean", "description": "Allow reading from undeclared collections.\n"}, "lockTimeout": {"type": "integer", "format": "int64", "description": "an optional numeric value that can be used to set a\ntimeout in seconds for waiting on collection locks. This option is only\nmeaningful when using exclusive locks. If not specified, a default value of\n900 seconds will be used. Setting *lockTimeout* to *0* will make ArangoDB\nnot time out waiting for a lock.\n"}, "params": {"type": "string", "description": "optional arguments passed to *action*.\n"}, "maxTransactionSize": {"type": "integer", "format": "int64", "description": "Transaction size limit in bytes.\n"}}, "required": ["collections", "action"]}}}}, "responses": {"200": {"description": "If the transaction is fully executed and committed on the server,\n*HTTP 200* will be returned.\n"}, "400": {"description": "If the transaction specification is either missing or malformed, the server\nwill respond with *HTTP 400*.\n"}, "404": {"description": "If the transaction specification contains an unknown collection, the server\nwill respond with *HTTP 404*.\n"}, "500": {"description": "Exceptions thrown by users will make the server respond with a return code of\n*HTTP 500*\n"}}, "tags": ["Transactions"]}, "get": {"description": "The result is an object with the attribute *transactions*, which contains\nan array of transactions.\nIn a cluster the array will contain the transactions from all Coordinators.\nEach array entry contains an object with the following attributes:\n- *id*: the transaction's id\n- *state*: the transaction's status\n", "operationId": " executeGetState:transactions", "responses": {"200": {"description": "If the list of transactions can be retrieved successfully, *HTTP 200* will be returned.\n"}}, "tags": ["Transactions"]}}, "/_api/transaction/begin": {"post": {"description": "The transaction description must be passed in the body of the POST request.\nIf the transaction can be started on the server, *HTTP 201* will be returned.\nFor successfully started transactions, the returned JSON object has the\nfollowing properties:\n- *error*: boolean flag to indicate if an error occurred (*false*\n  in this case)\n- *code*: the HTTP status code\n- *result*: result containing\n    - *id*: the identifier of the transaction\n    - *status*: containing the string 'running'\nIf the transaction specification is either missing or malformed, the server\nwill respond with *HTTP 400* or *HTTP 404*.\nThe body of the response will then contain a JSON object with additional error\ndetails. The object has the following attributes:\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message\n", "operationId": " executeBegin", "parameters": [{"name": "x-arango-allow-dirty-read", "schema": {"type": "boolean"}, "required": false, "description": "Set this header to `true` to allow the Coordinator to ask any shard replica for\nthe data, not only the shard leader. This may result in \"dirty reads\".\nThis header decides about dirty reads for the entire transaction. Individual\nread operations, that are performed as part of the transaction, cannot override it.\n", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"type": "object", "properties": {"collections": {"type": "string", "description": "*collections* must be a JSON object that can have one or all sub-attributes\n*read*, *write* or *exclusive*, each being an array of collection names or a\nsingle collection name as string. Collections that will be written to in the\ntransaction must be declared with the *write* or *exclusive* attribute or it\nwill fail, whereas non-declared collections from which is solely read will be\nadded lazily.\n"}, "waitForSync": {"type": "boolean", "description": "an optional boolean flag that, if set, will force the\ntransaction to write all data to disk before returning.\n"}, "allowImplicit": {"type": "boolean", "description": "Allow reading from undeclared collections. \n\n"}, "lockTimeout": {"type": "integer", "format": "int64", "description": "an optional numeric value that can be used to set a\ntimeout in seconds for waiting on collection locks. This option is only\nmeaningful when using exclusive locks. If not specified, a default\nvalue will be used. Setting *lockTimeout* to *0* will make ArangoDB\nnot time out waiting for a lock.\n"}, "maxTransactionSize": {"type": "integer", "format": "int64", "description": "Transaction size limit in bytes.\n"}}, "required": ["collections"]}}}}, "responses": {"201": {"description": "If the transaction is running on the server,\n*HTTP 201* will be returned.\n"}, "400": {"description": "If the transaction specification is either missing or malformed, the server\nwill respond with *HTTP 400*.\n"}, "404": {"description": "If the transaction specification contains an unknown collection, the server\nwill respond with *HTTP 404*.\n"}}, "tags": ["Transactions"]}}, "/_api/transaction/{transaction-id}": {"get": {"description": "The result is an object describing the status of the transaction.\nIt has at least the following attributes:\n- *id*: the identifier of the transaction\n- *status*: the status of the transaction. One of \"running\", \"committed\" or \"aborted\".\n", "operationId": " executeGetState:transaction", "parameters": [{"name": "transaction-id", "schema": {"type": "string"}, "required": true, "description": "The transaction identifier.\n", "in": "path"}], "responses": {"200": {"description": "If the transaction is fully executed and committed on the server,\n*HTTP 200* will be returned.\n"}, "400": {"description": "If the transaction identifier specified is either missing or malformed, the server\nwill respond with *HTTP 400*.\n"}, "404": {"description": "If the transaction was not found with the specified identifier, the server\nwill respond with *HTTP 404*.\n"}}, "tags": ["Transactions"]}, "put": {"description": "Commit a running server-side transaction. Committing is an idempotent operation.\nIt is not an error to commit a transaction more than once.\nIf the transaction can be committed, *HTTP 200* will be returned.\nThe returned JSON object has the following properties:\n- *error*: boolean flag to indicate if an error occurred (*false*\n  in this case)\n- *code*: the HTTP status code\n- *result*: result containing\n    - *id*: the identifier of the transaction\n    - *status*: containing the string 'committed'\nIf the transaction cannot be found, committing is not allowed or the\ntransaction was aborted, the server\nwill respond with *HTTP 400*, *HTTP 404* or *HTTP 409*.\nThe body of the response will then contain a JSON object with additional error\ndetails. The object has the following attributes:\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message\n", "operationId": " executeCommit:Transaction", "parameters": [{"name": "transaction-id", "schema": {"type": "string"}, "required": true, "description": "The transaction identifier,\n", "in": "path"}], "responses": {"200": {"description": "If the transaction was committed,\n*HTTP 200* will be returned.\n"}, "400": {"description": "If the transaction cannot be committed, the server\nwill respond with *HTTP 400*.\n"}, "404": {"description": "If the transaction was not found, the server\nwill respond with *HTTP 404*.\n"}, "409": {"description": "If the transaction was already aborted, the server\nwill respond with *HTTP 409*.\n"}}, "tags": ["Transactions"]}, "delete": {"description": "Abort a running server-side transaction. Aborting is an idempotent operation.\nIt is not an error to abort a transaction more than once.\nIf the transaction can be aborted, *HTTP 200* will be returned.\nThe returned JSON object has the following properties:\n- *error*: boolean flag to indicate if an error occurred (*false*\n  in this case)\n- *code*: the HTTP status code\n- *result*: result containing\n    - *id*: the identifier of the transaction\n    - *status*: containing the string 'aborted'\nIf the transaction cannot be found, aborting is not allowed or the\ntransaction was already committed, the server\nwill respond with *HTTP 400*, *HTTP 404* or *HTTP 409*.\nThe body of the response will then contain a JSON object with additional error\ndetails. The object has the following attributes:\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message\n", "operationId": " executeAbort:transaction", "parameters": [{"name": "transaction-id", "schema": {"type": "string"}, "required": true, "description": "The transaction identifier,\n", "in": "path"}], "responses": {"200": {"description": "If the transaction was aborted,\n*HTTP 200* will be returned.\n"}, "400": {"description": "If the transaction cannot be aborted, the server\nwill respond with *HTTP 400*.\n"}, "404": {"description": "If the transaction was not found, the server\nwill respond with *HTTP 404*.\n"}, "409": {"description": "If the transaction was already committed, the server\nwill respond with *HTTP 409*.\n"}}, "tags": ["Transactions"]}}}}